package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"strconv"
	"strings"

	"github.com/paloaltonetworks/scm-go"
	ivVDSwf "github.com/paloaltonetworks/scm-go/netsec/schemas/dynamic/user/groups"
	alljvhu "github.com/paloaltonetworks/scm-go/netsec/services/dynamicusergroups"

	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Data source (listing).
var (
	_ datasource.DataSource              = &dynamicUserGroupListDataSource{}
	_ datasource.DataSourceWithConfigure = &dynamicUserGroupListDataSource{}
)

func NewDynamicUserGroupListDataSource() datasource.DataSource {
	return &dynamicUserGroupListDataSource{}
}

type dynamicUserGroupListDataSource struct {
	client *scm.Client
}

// dynamicUserGroupListDsModel is the model.
type dynamicUserGroupListDsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	Device  types.String `tfsdk:"device"`
	Folder  types.String `tfsdk:"folder"`
	Limit   types.Int64  `tfsdk:"limit"`
	Name    types.String `tfsdk:"name"`
	Offset  types.Int64  `tfsdk:"offset"`
	Snippet types.String `tfsdk:"snippet"`

	// Output.
	Data []dynamicUserGroupListDsModel_ivVDSwf_Config `tfsdk:"data"`
	// omit input: limit
	// omit input: offset
	Total types.Int64 `tfsdk:"total"`
}

type dynamicUserGroupListDsModel_ivVDSwf_Config struct {
	Description types.String `tfsdk:"description"`
	Filter      types.String `tfsdk:"filter"`
	Id          types.String `tfsdk:"id"`
	Name        types.String `tfsdk:"name"`
	Tags        types.List   `tfsdk:"tags"`
}

// Metadata returns the data source type name.
func (d *dynamicUserGroupListDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_dynamic_user_group_list"
}

// Schema defines the schema for this listing data source.
func (d *dynamicUserGroupListDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = dsschema.Schema{
		Description: "Retrieves a listing of config items.",

		Attributes: map[string]dsschema.Attribute{
			// inputs:map[string]bool{"device":true, "folder":true, "limit":true, "name":true, "offset":true, "snippet":true} outputs:map[string]bool{"data":true, "limit":true, "offset":true, "tfid":true, "total":true} forceNew:map[string]bool{"device":true, "folder":true, "limit":true, "name":true, "offset":true, "snippet":true}
			"data": dsschema.ListNestedAttribute{
				Description: "The Data param.",
				Computed:    true,
				NestedObject: dsschema.NestedAttributeObject{
					Attributes: map[string]dsschema.Attribute{
						// inputs:map[string]bool{} outputs:map[string]bool{"description":true, "filter":true, "id":true, "name":true, "tag":true} forceNew:map[string]bool(nil)
						"description": dsschema.StringAttribute{
							Description: "The Description param. String length must not exceed 1023 characters.",
							Computed:    true,
						},
						"filter": dsschema.StringAttribute{
							Description: "tag-based filter. String length must not exceed 2047 characters.",
							Computed:    true,
						},
						"id": dsschema.StringAttribute{
							Description: "UUID of the resource.",
							Computed:    true,
						},
						"name": dsschema.StringAttribute{
							Description: "Alphanumeric string [ 0-9a-zA-Z._-]. String length must not exceed 63 characters.",
							Computed:    true,
						},
						"tags": dsschema.ListAttribute{
							Description: "Tags for dynamic user group object. List must contain at most 64 elements. Individual elements in this list are subject to additional validation. String length must not exceed 127 characters.",
							Computed:    true,
							ElementType: types.StringType,
						},
					},
				},
			},
			"device": dsschema.StringAttribute{
				Description: "The Device param.",
				Optional:    true,
			},
			"folder": dsschema.StringAttribute{
				Description: "The Folder param.",
				Optional:    true,
			},
			"limit": dsschema.Int64Attribute{
				Description: "The Limit param. A limit of -1 will return all configured items. Default: `200`.",
				Optional:    true,
				Computed:    true,
			},
			"name": dsschema.StringAttribute{
				Description: "The Name param.",
				Optional:    true,
			},
			"offset": dsschema.Int64Attribute{
				Description: "The Offset param. Default: `0`.",
				Optional:    true,
				Computed:    true,
			},
			"snippet": dsschema.StringAttribute{
				Description: "The Snippet param.",
				Optional:    true,
			},
			"tfid": dsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
			},
			"total": dsschema.Int64Attribute{
				Description: "The Total param.",
				Computed:    true,
			},
		},
	}
}

// Configure prepares the struct.
func (d *dynamicUserGroupListDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*scm.Client)
}

// Read performs Read for the struct.
func (d *dynamicUserGroupListDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state dynamicUserGroupListDsModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing data source listing", map[string]any{
		"data_source_name":            "scm_dynamic_user_group_list",
		"terraform_provider_function": "Read",
		"name":                        state.Name.ValueString(),
		"folder":                      state.Folder.ValueString(),
		"snippet":                     state.Snippet.ValueString(),
		"device":                      state.Device.ValueString(),
		"offset":                      state.Offset.ValueInt64(),
		"limit":                       state.Limit.ValueInt64(),
	})

	// Prepare to run the command.
	svc := alljvhu.NewClient(d.client)

	// Prepare input for the API endpoint.
	input := alljvhu.ListInput{}

	input.Name = state.Name.ValueStringPointer()

	input.Folder = state.Folder.ValueStringPointer()

	input.Snippet = state.Snippet.ValueStringPointer()

	input.Device = state.Device.ValueStringPointer()

	input.Offset = state.Offset.ValueInt64Pointer()

	input.Limit = state.Limit.ValueInt64Pointer()

	// Perform the operation.
	ans, err := svc.List(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error getting listing", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	if input.Name != nil {
		idBuilder.WriteString(*input.Name)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Folder != nil {
		idBuilder.WriteString(*input.Folder)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Snippet != nil {
		idBuilder.WriteString(*input.Snippet)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Device != nil {
		idBuilder.WriteString(*input.Device)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Offset != nil {
		idBuilder.WriteString(strconv.FormatInt(*input.Offset, 10))
	}

	idBuilder.WriteString(IdSeparator)
	if input.Limit != nil {
		idBuilder.WriteString(strconv.FormatInt(*input.Limit, 10))
	}

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	if len(ans.Data) == 0 {
		state.Data = nil
	} else {
		state.Data = make([]dynamicUserGroupListDsModel_ivVDSwf_Config, 0, len(ans.Data))
		for _, var0 := range ans.Data {
			var1 := dynamicUserGroupListDsModel_ivVDSwf_Config{}

			var1.Description = types.StringPointerValue(var0.Description)

			var1.Filter = types.StringValue(var0.Filter)

			var1.Id = types.StringPointerValue(var0.Id)

			var1.Name = types.StringValue(var0.Name)

			var2, var3 := types.ListValueFrom(ctx, types.StringType, var0.Tags)
			var1.Tags = var2
			resp.Diagnostics.Append(var3.Errors()...)
			state.Data = append(state.Data, var1)
		}
	}

	state.Limit = types.Int64PointerValue(ans.Limit)

	state.Offset = types.Int64PointerValue(ans.Offset)

	state.Total = types.Int64PointerValue(ans.Total)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Data source.
var (
	_ datasource.DataSource              = &dynamicUserGroupDataSource{}
	_ datasource.DataSourceWithConfigure = &dynamicUserGroupDataSource{}
)

func NewDynamicUserGroupDataSource() datasource.DataSource {
	return &dynamicUserGroupDataSource{}
}

type dynamicUserGroupDataSource struct {
	client *scm.Client
}

// dynamicUserGroupDsModel is the model.
type dynamicUserGroupDsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	Id types.String `tfsdk:"id"`

	// Output.
	Description types.String `tfsdk:"description"`
	Filter      types.String `tfsdk:"filter"`
	// omit input: id
	Name types.String `tfsdk:"name"`
	Tags types.List   `tfsdk:"tags"`
}

// Metadata returns the data source type name.
func (d *dynamicUserGroupDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_dynamic_user_group"
}

// Schema defines the schema for this data source.
func (d *dynamicUserGroupDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = dsschema.Schema{
		Description: "Retrieves a config item.",

		Attributes: map[string]dsschema.Attribute{
			// inputs:map[string]bool{"id":true} outputs:map[string]bool{"description":true, "filter":true, "id":true, "name":true, "tag":true, "tfid":true} forceNew:map[string]bool{"id":true}
			"description": dsschema.StringAttribute{
				Description: "The Description param. String length must not exceed 1023 characters.",
				Computed:    true,
			},
			"filter": dsschema.StringAttribute{
				Description: "tag-based filter. String length must not exceed 2047 characters.",
				Computed:    true,
			},
			"id": dsschema.StringAttribute{
				Description: "The Id param.",
				Required:    true,
			},
			"name": dsschema.StringAttribute{
				Description: "Alphanumeric string [ 0-9a-zA-Z._-]. String length must not exceed 63 characters.",
				Computed:    true,
			},
			"tags": dsschema.ListAttribute{
				Description: "Tags for dynamic user group object. List must contain at most 64 elements. Individual elements in this list are subject to additional validation. String length must not exceed 127 characters.",
				Computed:    true,
				ElementType: types.StringType,
			},
			"tfid": dsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
			},
		},
	}
}

// Configure prepares the struct.
func (d *dynamicUserGroupDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*scm.Client)
}

// Read performs Read for the struct.
func (d *dynamicUserGroupDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state dynamicUserGroupDsModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing data source read", map[string]any{
		"data_source_name":            "scm_dynamic_user_group",
		"terraform_provider_function": "Read",
		"id":                          state.Id.ValueString(),
	})

	// Prepare to run the command.
	svc := alljvhu.NewClient(d.client)

	// Prepare input for the API endpoint.
	input := alljvhu.ReadInput{}

	input.Id = state.Id.ValueString()

	// Perform the operation.
	ans, err := svc.Read(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error reading config", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	idBuilder.WriteString(input.Id)

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	state.Description = types.StringPointerValue(ans.Description)

	state.Filter = types.StringValue(ans.Filter)

	state.Id = types.StringPointerValue(ans.Id)

	state.Name = types.StringValue(ans.Name)

	var0, var1 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var0
	resp.Diagnostics.Append(var1.Errors()...)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Resource.
var (
	_ resource.Resource                = &dynamicUserGroupResource{}
	_ resource.ResourceWithConfigure   = &dynamicUserGroupResource{}
	_ resource.ResourceWithImportState = &dynamicUserGroupResource{}
)

func NewDynamicUserGroupResource() resource.Resource {
	return &dynamicUserGroupResource{}
}

type dynamicUserGroupResource struct {
	client *scm.Client
}

// dynamicUserGroupRsModel is the model.
type dynamicUserGroupRsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	Description types.String `tfsdk:"description"`
	Device      types.String `tfsdk:"device"`
	Filter      types.String `tfsdk:"filter"`
	Folder      types.String `tfsdk:"folder"`
	Id          types.String `tfsdk:"id"`
	Name        types.String `tfsdk:"name"`
	Snippet     types.String `tfsdk:"snippet"`
	Tags        types.List   `tfsdk:"tags"`

	// Output.
	// omit input: description
	// omit input: filter
	// omit input: id
	// omit input: name
	// omit input: tags
}

// Metadata returns the data source type name.
func (r *dynamicUserGroupResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_dynamic_user_group"
}

// Schema defines the schema for this data source.
func (r *dynamicUserGroupResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = rsschema.Schema{
		Description: "Retrieves a config item.",

		Attributes: map[string]rsschema.Attribute{
			// inputs:map[string]bool{"description":true, "device":true, "filter":true, "folder":true, "id":true, "name":true, "snippet":true, "tag":true} outputs:map[string]bool{"description":true, "filter":true, "id":true, "name":true, "tag":true, "tfid":true} forceNew:map[string]bool{"device":true, "folder":true, "snippet":true}
			"description": rsschema.StringAttribute{
				Description: "The Description param. String length must not exceed 1023 characters.",
				Optional:    true,
				Validators: []validator.String{
					stringvalidator.LengthAtMost(1023),
				},
			},
			"device": rsschema.StringAttribute{
				Description: "The Device param.",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"filter": rsschema.StringAttribute{
				Description: "tag-based filter. String length must not exceed 2047 characters.",
				Required:    true,
				Validators: []validator.String{
					stringvalidator.LengthAtMost(2047),
				},
			},
			"folder": rsschema.StringAttribute{
				Description: "The Folder param.",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"id": rsschema.StringAttribute{
				Description: "UUID of the resource.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"name": rsschema.StringAttribute{
				Description: "Alphanumeric string [ 0-9a-zA-Z._-]. String length must not exceed 63 characters.",
				Required:    true,
				Validators: []validator.String{
					stringvalidator.LengthAtMost(63),
				},
			},
			"snippet": rsschema.StringAttribute{
				Description: "The Snippet param.",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"tags": rsschema.ListAttribute{
				Description: "Tags for dynamic user group object. List must contain at most 64 elements. Individual elements in this list are subject to additional validation. String length must not exceed 127 characters.",
				Optional:    true,
				ElementType: types.StringType,
				Validators: []validator.List{
					listvalidator.SizeAtMost(64),
					listvalidator.ValueStringsAre(
						stringvalidator.LengthAtMost(127),
					),
				},
			},
			"tfid": rsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
	}
}

// Configure prepares the struct.
func (r *dynamicUserGroupResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*scm.Client)
}

// Create resource.
func (r *dynamicUserGroupResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state dynamicUserGroupRsModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name":               "scm_dynamic_user_group",
		"terraform_provider_function": "Create",
		"folder":                      state.Folder.ValueString(),
		"snippet":                     state.Snippet.ValueString(),
		"device":                      state.Device.ValueString(),
	})

	// Prepare to create the config.
	svc := alljvhu.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := alljvhu.CreateInput{}

	input.Folder = state.Folder.ValueStringPointer()

	input.Snippet = state.Snippet.ValueStringPointer()

	input.Device = state.Device.ValueStringPointer()
	input.Request = &ivVDSwf.Config{}

	input.Request.Description = state.Description.ValueStringPointer()

	input.Request.Filter = state.Filter.ValueString()

	input.Request.Name = state.Name.ValueString()

	resp.Diagnostics.Append(state.Tags.ElementsAs(ctx, &input.Request.Tags, false)...)
	//if len(state.Tags) != 0 {
	//    input.Request.Tags = make([]string, 0, len(state.Tags))
	//    for _, var0 := range state.Tags {
	//        input.Request.Tags = append(input.Request.Tags, var0.ValueString())
	//    }
	//}

	// Perform the operation.
	ans, err := svc.Create(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error creating config", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	if input.Folder != nil {
		idBuilder.WriteString(*input.Folder)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Snippet != nil {
		idBuilder.WriteString(*input.Snippet)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Device != nil {
		idBuilder.WriteString(*input.Device)
	}

	idBuilder.WriteString(IdSeparator)
	if ans.Id == nil {
		resp.Diagnostics.AddError("Undefined param required for ID", "Id")
		return
	}
	if ans.Id != nil {
		idBuilder.WriteString(*ans.Id)
	}

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	state.Description = types.StringPointerValue(ans.Description)

	state.Filter = types.StringValue(ans.Filter)

	state.Id = types.StringPointerValue(ans.Id)

	state.Name = types.StringValue(ans.Name)

	var1, var2 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var1
	resp.Diagnostics.Append(var2.Errors()...)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Read performs Read for the struct.
func (r *dynamicUserGroupResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var savestate, state dynamicUserGroupRsModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	tfid := savestate.Tfid.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 4 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 4 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"terraform_provider_function": "Read",
		"resource_name":               "scm_dynamic_user_group",
		"locMap":                      map[string]int{"device": 2, "folder": 0, "id": 3, "snippet": 1},
		"tokens":                      tokens,
	})

	// Prepare to read the config.
	svc := alljvhu.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := alljvhu.ReadInput{}

	input.Id = tokens[3]

	// Perform the operation.
	ans, err := svc.Read(ctx, input)
	if err != nil {
		if IsObjectNotFound(err) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading config", err.Error())
		}
		return
	}

	// Store the answer to state.

	if tokens[0] == "" {
		state.Folder = types.StringNull()
	} else {
		state.Folder = types.StringValue(tokens[0])
	}

	if tokens[1] == "" {
		state.Snippet = types.StringNull()
	} else {
		state.Snippet = types.StringValue(tokens[1])
	}

	if tokens[2] == "" {
		state.Device = types.StringNull()
	} else {
		state.Device = types.StringValue(tokens[2])
	}
	state.Tfid = savestate.Tfid

	state.Description = types.StringPointerValue(ans.Description)

	state.Filter = types.StringValue(ans.Filter)

	state.Id = types.StringPointerValue(ans.Id)

	state.Name = types.StringValue(ans.Name)

	var0, var1 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var0
	resp.Diagnostics.Append(var1.Errors()...)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Update performs the Update for the struct.
func (r *dynamicUserGroupResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, state dynamicUserGroupRsModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	tfid := state.Tfid.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 4 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 4 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"terraform_provider_function": "Update",
		"resource_name":               "scm_dynamic_user_group",
		"tfid":                        state.Tfid.ValueString(),
	})

	// Prepare to update the config.
	svc := alljvhu.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := alljvhu.UpdateInput{}

	if tokens[3] != "" {
		input.Id = tokens[3]
	}
	input.Request = &ivVDSwf.Config{}

	input.Request.Description = plan.Description.ValueStringPointer()

	input.Request.Filter = plan.Filter.ValueString()

	input.Request.Name = plan.Name.ValueString()

	resp.Diagnostics.Append(plan.Tags.ElementsAs(ctx, &input.Request.Tags, false)...)
	//if len(plan.Tags) != 0 {
	//    input.Request.Tags = make([]string, 0, len(plan.Tags))
	//    for _, var0 := range plan.Tags {
	//        input.Request.Tags = append(input.Request.Tags, var0.ValueString())
	//    }
	//}

	// Perform the operation.
	ans, err := svc.Update(ctx, input)
	if err != nil {
		if IsObjectNotFound(err) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error updating resource", err.Error())
		}
		return
	}

	// Store the answer to state.
	// Note: when supporting importing a resource, this will need to change to taking
	// values from the savestate.Tfid param and locMap.

	state.Description = types.StringPointerValue(ans.Description)

	state.Filter = types.StringValue(ans.Filter)

	state.Id = types.StringPointerValue(ans.Id)

	state.Name = types.StringValue(ans.Name)

	var1, var2 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var1
	resp.Diagnostics.Append(var2.Errors()...)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Delete performs delete for the struct.
func (r *dynamicUserGroupResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var idType types.String
	resp.Diagnostics.Append(req.State.GetAttribute(ctx, path.Root("tfid"), &idType)...)
	if resp.Diagnostics.HasError() {
		return
	}
	tfid := idType.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 4 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 4 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"terraform_provider_function": "Delete",
		"resource_name":               "scm_dynamic_user_group",
		"locMap":                      map[string]int{"device": 2, "folder": 0, "id": 3, "snippet": 1},
		"tokens":                      tokens,
	})

	svc := alljvhu.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := alljvhu.DeleteInput{}

	input.Id = tokens[3]

	// Perform the operation.
	if _, err := svc.Delete(ctx, input); err != nil && !IsObjectNotFound(err) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}
}

func (r *dynamicUserGroupResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("tfid"), req, resp)
}
