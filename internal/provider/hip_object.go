package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"regexp"
	"strconv"
	"strings"

	"github.com/paloaltonetworks/scm-go"
	suxdMuj "github.com/paloaltonetworks/scm-go/netsec/schemas/hip/objects"
	sdhSKaQ "github.com/paloaltonetworks/scm-go/netsec/services/hipobjects"

	"github.com/hashicorp/terraform-plugin-framework-validators/boolvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Data source (listing).
var (
	_ datasource.DataSource              = &hipObjectListDataSource{}
	_ datasource.DataSourceWithConfigure = &hipObjectListDataSource{}
)

func NewHipObjectListDataSource() datasource.DataSource {
	return &hipObjectListDataSource{}
}

type hipObjectListDataSource struct {
	client *scm.Client
}

// hipObjectListDsModel is the model.
type hipObjectListDsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	Device  types.String `tfsdk:"device"`
	Folder  types.String `tfsdk:"folder"`
	Limit   types.Int64  `tfsdk:"limit"`
	Name    types.String `tfsdk:"name"`
	Offset  types.Int64  `tfsdk:"offset"`
	Snippet types.String `tfsdk:"snippet"`

	// Output.
	Data []hipObjectListDsModel_suxdMuj_Config `tfsdk:"data"`
	// omit input: limit
	// omit input: offset
	Total types.Int64 `tfsdk:"total"`
}

type hipObjectListDsModel_suxdMuj_Config struct {
	AntiMalware        *hipObjectListDsModel_suxdMuj_AntiMalwareObject        `tfsdk:"anti_malware"`
	Certificate        *hipObjectListDsModel_suxdMuj_CertificateObject        `tfsdk:"certificate"`
	CustomChecks       *hipObjectListDsModel_suxdMuj_CustomChecksObject       `tfsdk:"custom_checks"`
	DataLossPrevention *hipObjectListDsModel_suxdMuj_DataLossPreventionObject `tfsdk:"data_loss_prevention"`
	Description        types.String                                           `tfsdk:"description"`
	DiskBackup         *hipObjectListDsModel_suxdMuj_DiskBackupObject         `tfsdk:"disk_backup"`
	DiskEncryption     *hipObjectListDsModel_suxdMuj_DiskEncryptionObject     `tfsdk:"disk_encryption"`
	Firewall           *hipObjectListDsModel_suxdMuj_FirewallObject           `tfsdk:"firewall"`
	HostInfo           *hipObjectListDsModel_suxdMuj_HostInfoObject           `tfsdk:"host_info"`
	Id                 types.String                                           `tfsdk:"id"`
	MobileDevice       *hipObjectListDsModel_suxdMuj_MobileDeviceObject       `tfsdk:"mobile_device"`
	Name               types.String                                           `tfsdk:"name"`
	NetworkInfo        *hipObjectListDsModel_suxdMuj_NetworkInfoObject        `tfsdk:"network_info"`
	PatchManagement    *hipObjectListDsModel_suxdMuj_PatchManagementObject    `tfsdk:"patch_management"`
}

type hipObjectListDsModel_suxdMuj_AntiMalwareObject struct {
	Criteria      *hipObjectListDsModel_suxdMuj_AntiMalwareCriteriaObject `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                              `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectListDsModel_suxdMuj_AntiMalwareVendorObject  `tfsdk:"vendors"`
}

type hipObjectListDsModel_suxdMuj_AntiMalwareCriteriaObject struct {
	IsInstalled        types.Bool                                         `tfsdk:"is_installed"`
	LastScanTime       *hipObjectListDsModel_suxdMuj_LastScanTimeObject   `tfsdk:"last_scan_time"`
	ProductVersion     *hipObjectListDsModel_suxdMuj_ProductVersionObject `tfsdk:"product_version"`
	RealTimeProtection types.String                                       `tfsdk:"real_time_protection"`
	VirdefVersion      *hipObjectListDsModel_suxdMuj_VirdefVersionObject  `tfsdk:"virdef_version"`
}

type hipObjectListDsModel_suxdMuj_LastScanTimeObject struct {
	NotAvailable types.Bool                                                `tfsdk:"not_available"`
	NotWithin    *hipObjectListDsModel_suxdMuj_LastScanTimeNotWithinObject `tfsdk:"not_within"`
	Within       *hipObjectListDsModel_suxdMuj_LastScanTimeWithinObject    `tfsdk:"within"`
}

type hipObjectListDsModel_suxdMuj_LastScanTimeNotWithinObject struct {
	Days  types.Int64 `tfsdk:"days"`
	Hours types.Int64 `tfsdk:"hours"`
}

type hipObjectListDsModel_suxdMuj_LastScanTimeWithinObject struct {
	Days  types.Int64 `tfsdk:"days"`
	Hours types.Int64 `tfsdk:"hours"`
}

type hipObjectListDsModel_suxdMuj_ProductVersionObject struct {
	Contains     types.String                                                `tfsdk:"contains"`
	GreaterEqual types.String                                                `tfsdk:"greater_equal"`
	GreaterThan  types.String                                                `tfsdk:"greater_than"`
	Is           types.String                                                `tfsdk:"is"`
	IsNot        types.String                                                `tfsdk:"is_not"`
	LessEqual    types.String                                                `tfsdk:"less_equal"`
	LessThan     types.String                                                `tfsdk:"less_than"`
	NotWithin    *hipObjectListDsModel_suxdMuj_ProductVersionNotWithinObject `tfsdk:"not_within"`
	Within       *hipObjectListDsModel_suxdMuj_ProductVersionWithinObject    `tfsdk:"within"`
}

type hipObjectListDsModel_suxdMuj_ProductVersionNotWithinObject struct {
	Versions types.Int64 `tfsdk:"versions"`
}

type hipObjectListDsModel_suxdMuj_ProductVersionWithinObject struct {
	Versions types.Int64 `tfsdk:"versions"`
}

type hipObjectListDsModel_suxdMuj_VirdefVersionObject struct {
	NotWithin *hipObjectListDsModel_suxdMuj_VirdefVersionNotWithinObject `tfsdk:"not_within"`
	Within    *hipObjectListDsModel_suxdMuj_VirdefVersionWithinObject    `tfsdk:"within"`
}

type hipObjectListDsModel_suxdMuj_VirdefVersionNotWithinObject struct {
	Days     types.Int64 `tfsdk:"days"`
	Versions types.Int64 `tfsdk:"versions"`
}

type hipObjectListDsModel_suxdMuj_VirdefVersionWithinObject struct {
	Days     types.Int64 `tfsdk:"days"`
	Versions types.Int64 `tfsdk:"versions"`
}

type hipObjectListDsModel_suxdMuj_AntiMalwareVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

type hipObjectListDsModel_suxdMuj_CertificateObject struct {
	Criteria *hipObjectListDsModel_suxdMuj_CertificateCriteriaObject `tfsdk:"criteria"`
}

type hipObjectListDsModel_suxdMuj_CertificateCriteriaObject struct {
	CertificateAttributes []hipObjectListDsModel_suxdMuj_CertificateAttributeObject `tfsdk:"certificate_attributes"`
	CertificateProfile    types.String                                              `tfsdk:"certificate_profile"`
}

type hipObjectListDsModel_suxdMuj_CertificateAttributeObject struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}

type hipObjectListDsModel_suxdMuj_CustomChecksObject struct {
	Criteria hipObjectListDsModel_suxdMuj_CustomChecksCriteriaObject `tfsdk:"criteria"`
}

type hipObjectListDsModel_suxdMuj_CustomChecksCriteriaObject struct {
	Plist        []hipObjectListDsModel_suxdMuj_PlistObject       `tfsdk:"plist"`
	ProcessList  []hipObjectListDsModel_suxdMuj_ProcessListObject `tfsdk:"process_list"`
	RegistryKeys []hipObjectListDsModel_suxdMuj_RegistryKeyObject `tfsdk:"registry_keys"`
}

type hipObjectListDsModel_suxdMuj_PlistObject struct {
	Keys   []hipObjectListDsModel_suxdMuj_KeyObject `tfsdk:"keys"`
	Name   types.String                             `tfsdk:"name"`
	Negate types.Bool                               `tfsdk:"negate"`
}

type hipObjectListDsModel_suxdMuj_KeyObject struct {
	Name   types.String `tfsdk:"name"`
	Negate types.Bool   `tfsdk:"negate"`
	Value  types.String `tfsdk:"value"`
}

type hipObjectListDsModel_suxdMuj_ProcessListObject struct {
	Name    types.String `tfsdk:"name"`
	Running types.Bool   `tfsdk:"running"`
}

type hipObjectListDsModel_suxdMuj_RegistryKeyObject struct {
	DefaultValueData types.String                                       `tfsdk:"default_value_data"`
	Name             types.String                                       `tfsdk:"name"`
	Negate           types.Bool                                         `tfsdk:"negate"`
	RegistryValues   []hipObjectListDsModel_suxdMuj_RegistryValueObject `tfsdk:"registry_values"`
}

type hipObjectListDsModel_suxdMuj_RegistryValueObject struct {
	Name      types.String `tfsdk:"name"`
	Negate    types.Bool   `tfsdk:"negate"`
	ValueData types.String `tfsdk:"value_data"`
}

type hipObjectListDsModel_suxdMuj_DataLossPreventionObject struct {
	Criteria      *hipObjectListDsModel_suxdMuj_DataLossPreventionCriteriaObject `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                                     `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectListDsModel_suxdMuj_DataLossPreventionVendorObject  `tfsdk:"vendors"`
}

type hipObjectListDsModel_suxdMuj_DataLossPreventionCriteriaObject struct {
	IsEnabled   types.String `tfsdk:"is_enabled"`
	IsInstalled types.Bool   `tfsdk:"is_installed"`
}

type hipObjectListDsModel_suxdMuj_DataLossPreventionVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

type hipObjectListDsModel_suxdMuj_DiskBackupObject struct {
	Criteria      *hipObjectListDsModel_suxdMuj_DiskBackupCriteriaObject `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                             `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectListDsModel_suxdMuj_DiskBackupVendorObject  `tfsdk:"vendors"`
}

type hipObjectListDsModel_suxdMuj_DiskBackupCriteriaObject struct {
	IsInstalled    types.Bool                                         `tfsdk:"is_installed"`
	LastBackupTime *hipObjectListDsModel_suxdMuj_LastBackupTimeObject `tfsdk:"last_backup_time"`
}

type hipObjectListDsModel_suxdMuj_LastBackupTimeObject struct {
	NotAvailable types.Bool                                                  `tfsdk:"not_available"`
	NotWithin    *hipObjectListDsModel_suxdMuj_LastBackupTimeNotWithinObject `tfsdk:"not_within"`
	Within       *hipObjectListDsModel_suxdMuj_LastBackupTimeWithinObject    `tfsdk:"within"`
}

type hipObjectListDsModel_suxdMuj_LastBackupTimeNotWithinObject struct {
	Days  types.Int64 `tfsdk:"days"`
	Hours types.Int64 `tfsdk:"hours"`
}

type hipObjectListDsModel_suxdMuj_LastBackupTimeWithinObject struct {
	Days  types.Int64 `tfsdk:"days"`
	Hours types.Int64 `tfsdk:"hours"`
}

type hipObjectListDsModel_suxdMuj_DiskBackupVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

type hipObjectListDsModel_suxdMuj_DiskEncryptionObject struct {
	Criteria      *hipObjectListDsModel_suxdMuj_DiskEncryptionCriteriaObject `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                                 `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectListDsModel_suxdMuj_DiskEncryptionVendorObject  `tfsdk:"vendors"`
}

type hipObjectListDsModel_suxdMuj_DiskEncryptionCriteriaObject struct {
	EncryptedLocations []hipObjectListDsModel_suxdMuj_EncryptedLocationObject `tfsdk:"encrypted_locations"`
	IsInstalled        types.Bool                                             `tfsdk:"is_installed"`
}

type hipObjectListDsModel_suxdMuj_EncryptedLocationObject struct {
	EncryptionState *hipObjectListDsModel_suxdMuj_EncryptionStateObject `tfsdk:"encryption_state"`
	Name            types.String                                        `tfsdk:"name"`
}

type hipObjectListDsModel_suxdMuj_EncryptionStateObject struct {
	Is    types.String `tfsdk:"is"`
	IsNot types.String `tfsdk:"is_not"`
}

type hipObjectListDsModel_suxdMuj_DiskEncryptionVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

type hipObjectListDsModel_suxdMuj_FirewallObject struct {
	Criteria      *hipObjectListDsModel_suxdMuj_FirewallCriteriaObject `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                           `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectListDsModel_suxdMuj_FirewallVendorObject  `tfsdk:"vendors"`
}

type hipObjectListDsModel_suxdMuj_FirewallCriteriaObject struct {
	IsEnabled   types.String `tfsdk:"is_enabled"`
	IsInstalled types.Bool   `tfsdk:"is_installed"`
}

type hipObjectListDsModel_suxdMuj_FirewallVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

type hipObjectListDsModel_suxdMuj_HostInfoObject struct {
	Criteria hipObjectListDsModel_suxdMuj_HostInfoCriteriaObject `tfsdk:"criteria"`
}

type hipObjectListDsModel_suxdMuj_HostInfoCriteriaObject struct {
	ClientVersion *hipObjectListDsModel_suxdMuj_ClientVersionObject `tfsdk:"client_version"`
	Domain        *hipObjectListDsModel_suxdMuj_DomainObject        `tfsdk:"domain"`
	HostId        *hipObjectListDsModel_suxdMuj_HostIdObject        `tfsdk:"host_id"`
	HostName      *hipObjectListDsModel_suxdMuj_HostNameObject      `tfsdk:"host_name"`
	Managed       types.Bool                                        `tfsdk:"managed"`
	Os            *hipObjectListDsModel_suxdMuj_OsObject            `tfsdk:"os"`
	SerialNumber  *hipObjectListDsModel_suxdMuj_SerialNumberObject  `tfsdk:"serial_number"`
}

type hipObjectListDsModel_suxdMuj_ClientVersionObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectListDsModel_suxdMuj_DomainObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectListDsModel_suxdMuj_HostIdObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectListDsModel_suxdMuj_HostNameObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectListDsModel_suxdMuj_OsObject struct {
	Contains *hipObjectListDsModel_suxdMuj_ContainsObject `tfsdk:"contains"`
}

type hipObjectListDsModel_suxdMuj_ContainsObject struct {
	Apple     types.String `tfsdk:"apple"`
	Google    types.String `tfsdk:"google"`
	Linux     types.String `tfsdk:"linux"`
	Microsoft types.String `tfsdk:"microsoft"`
	Other     types.String `tfsdk:"other"`
}

type hipObjectListDsModel_suxdMuj_SerialNumberObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectListDsModel_suxdMuj_MobileDeviceObject struct {
	Criteria *hipObjectListDsModel_suxdMuj_MobileDeviceCriteriaObject `tfsdk:"criteria"`
}

type hipObjectListDsModel_suxdMuj_MobileDeviceCriteriaObject struct {
	Applications    *hipObjectListDsModel_suxdMuj_ApplicationsObject    `tfsdk:"applications"`
	DiskEncrypted   types.Bool                                          `tfsdk:"disk_encrypted"`
	Imei            *hipObjectListDsModel_suxdMuj_ImeiObject            `tfsdk:"imei"`
	Jailbroken      types.Bool                                          `tfsdk:"jailbroken"`
	LastCheckinTime *hipObjectListDsModel_suxdMuj_LastCheckinTimeObject `tfsdk:"last_checkin_time"`
	Model           *hipObjectListDsModel_suxdMuj_ModelObject           `tfsdk:"model"`
	PasscodeSet     types.Bool                                          `tfsdk:"passcode_set"`
	PhoneNumber     *hipObjectListDsModel_suxdMuj_PhoneNumberObject     `tfsdk:"phone_number"`
	Tag             *hipObjectListDsModel_suxdMuj_TagObject             `tfsdk:"tag"`
}

type hipObjectListDsModel_suxdMuj_ApplicationsObject struct {
	HasMalware      *hipObjectListDsModel_suxdMuj_HasMalwareObject `tfsdk:"has_malware"`
	HasUnmanagedApp types.Bool                                     `tfsdk:"has_unmanaged_app"`
	Includes        []hipObjectListDsModel_suxdMuj_IncludeObject   `tfsdk:"includes"`
}

type hipObjectListDsModel_suxdMuj_HasMalwareObject struct {
	No  types.Bool                              `tfsdk:"no"`
	Yes *hipObjectListDsModel_suxdMuj_YesObject `tfsdk:"yes"`
}

type hipObjectListDsModel_suxdMuj_YesObject struct {
	Excludes []hipObjectListDsModel_suxdMuj_ExcludeObject `tfsdk:"excludes"`
}

type hipObjectListDsModel_suxdMuj_ExcludeObject struct {
	Hash    types.String `tfsdk:"hash"`
	Name    types.String `tfsdk:"name"`
	Package types.String `tfsdk:"package"`
}

type hipObjectListDsModel_suxdMuj_IncludeObject struct {
	Hash    types.String `tfsdk:"hash"`
	Name    types.String `tfsdk:"name"`
	Package types.String `tfsdk:"package"`
}

type hipObjectListDsModel_suxdMuj_ImeiObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectListDsModel_suxdMuj_LastCheckinTimeObject struct {
	NotWithin *hipObjectListDsModel_suxdMuj_LastCheckinTimeNotWithinObject `tfsdk:"not_within"`
	Within    *hipObjectListDsModel_suxdMuj_LastCheckinTimeWithinObject    `tfsdk:"within"`
}

type hipObjectListDsModel_suxdMuj_LastCheckinTimeNotWithinObject struct {
	Days types.Int64 `tfsdk:"days"`
}

type hipObjectListDsModel_suxdMuj_LastCheckinTimeWithinObject struct {
	Days types.Int64 `tfsdk:"days"`
}

type hipObjectListDsModel_suxdMuj_ModelObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectListDsModel_suxdMuj_PhoneNumberObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectListDsModel_suxdMuj_TagObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectListDsModel_suxdMuj_NetworkInfoObject struct {
	Criteria *hipObjectListDsModel_suxdMuj_NetworkInfoCriteriaObject `tfsdk:"criteria"`
}

type hipObjectListDsModel_suxdMuj_NetworkInfoCriteriaObject struct {
	Network *hipObjectListDsModel_suxdMuj_NetworkObject `tfsdk:"network"`
}

type hipObjectListDsModel_suxdMuj_NetworkObject struct {
	Is    *hipObjectListDsModel_suxdMuj_IsObject    `tfsdk:"is"`
	IsNot *hipObjectListDsModel_suxdMuj_IsNotObject `tfsdk:"is_not"`
}

type hipObjectListDsModel_suxdMuj_IsObject struct {
	Mobile  *hipObjectListDsModel_suxdMuj_IsMobileObject `tfsdk:"mobile"`
	Unknown types.Bool                                   `tfsdk:"unknown"`
	Wifi    *hipObjectListDsModel_suxdMuj_IsWifiObject   `tfsdk:"wifi"`
}

type hipObjectListDsModel_suxdMuj_IsMobileObject struct {
	Carrier types.String `tfsdk:"carrier"`
}

type hipObjectListDsModel_suxdMuj_IsWifiObject struct {
	Ssid types.String `tfsdk:"ssid"`
}

type hipObjectListDsModel_suxdMuj_IsNotObject struct {
	Ethernet types.Bool                                      `tfsdk:"ethernet"`
	Mobile   *hipObjectListDsModel_suxdMuj_IsNotMobileObject `tfsdk:"mobile"`
	Unknown  types.Bool                                      `tfsdk:"unknown"`
	Wifi     *hipObjectListDsModel_suxdMuj_IsNotWifiObject   `tfsdk:"wifi"`
}

type hipObjectListDsModel_suxdMuj_IsNotMobileObject struct {
	Carrier types.String `tfsdk:"carrier"`
}

type hipObjectListDsModel_suxdMuj_IsNotWifiObject struct {
	Ssid types.String `tfsdk:"ssid"`
}

type hipObjectListDsModel_suxdMuj_PatchManagementObject struct {
	Criteria      *hipObjectListDsModel_suxdMuj_CriteriaObject               `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                                 `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectListDsModel_suxdMuj_PatchManagementVendorObject `tfsdk:"vendors"`
}

type hipObjectListDsModel_suxdMuj_CriteriaObject struct {
	IsEnabled      types.String                                       `tfsdk:"is_enabled"`
	IsInstalled    types.Bool                                         `tfsdk:"is_installed"`
	MissingPatches *hipObjectListDsModel_suxdMuj_MissingPatchesObject `tfsdk:"missing_patches"`
}

type hipObjectListDsModel_suxdMuj_MissingPatchesObject struct {
	Check    types.String                                 `tfsdk:"check"`
	Patches  types.List                                   `tfsdk:"patches"`
	Severity *hipObjectListDsModel_suxdMuj_SeverityObject `tfsdk:"severity"`
}

type hipObjectListDsModel_suxdMuj_SeverityObject struct {
	GreaterEqual types.Int64 `tfsdk:"greater_equal"`
	GreaterThan  types.Int64 `tfsdk:"greater_than"`
	Is           types.Int64 `tfsdk:"is"`
	IsNot        types.Int64 `tfsdk:"is_not"`
	LessEqual    types.Int64 `tfsdk:"less_equal"`
	LessThan     types.Int64 `tfsdk:"less_than"`
}

type hipObjectListDsModel_suxdMuj_PatchManagementVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

// Metadata returns the data source type name.
func (d *hipObjectListDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_hip_object_list"
}

// Schema defines the schema for this listing data source.
func (d *hipObjectListDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = dsschema.Schema{
		Description: "Retrieves a listing of config items.",

		Attributes: map[string]dsschema.Attribute{
			// inputs:map[string]bool{"device":true, "folder":true, "limit":true, "name":true, "offset":true, "snippet":true} outputs:map[string]bool{"data":true, "limit":true, "offset":true, "tfid":true, "total":true} forceNew:map[string]bool{"device":true, "folder":true, "limit":true, "name":true, "offset":true, "snippet":true}
			"data": dsschema.ListNestedAttribute{
				Description: "The Data param.",
				Computed:    true,
				NestedObject: dsschema.NestedAttributeObject{
					Attributes: map[string]dsschema.Attribute{
						// inputs:map[string]bool{} outputs:map[string]bool{"anti_malware":true, "certificate":true, "custom_checks":true, "data_loss_prevention":true, "description":true, "disk_backup":true, "disk_encryption":true, "firewall":true, "host_info":true, "id":true, "mobile_device":true, "name":true, "network_info":true, "patch_management":true} forceNew:map[string]bool(nil)
						"anti_malware": dsschema.SingleNestedAttribute{
							Description: "The AntiMalware param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
								"criteria": dsschema.SingleNestedAttribute{
									Description: "The Criteria param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"is_installed":true, "last_scan_time":true, "product_version":true, "real_time_protection":true, "virdef_version":true} forceNew:map[string]bool(nil)
										"is_installed": dsschema.BoolAttribute{
											Description: "Is Installed. Default: `true`.",
											Computed:    true,
										},
										"last_scan_time": dsschema.SingleNestedAttribute{
											Description: "The LastScanTime param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"not_available":true, "not_within":true, "within":true} forceNew:map[string]bool(nil)
												"not_available": dsschema.BoolAttribute{
													Description: "The NotAvailable param.",
													Computed:    true,
												},
												"not_within": dsschema.SingleNestedAttribute{
													Description: "The NotWithin param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"days":true, "hours":true} forceNew:map[string]bool(nil)
														"days": dsschema.Int64Attribute{
															Description: "specify time in days. Value must be between 1 and 65535.",
															Computed:    true,
														},
														"hours": dsschema.Int64Attribute{
															Description: "specify time in hours. Value must be between 1 and 65535.",
															Computed:    true,
														},
													},
												},
												"within": dsschema.SingleNestedAttribute{
													Description: "The Within param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"days":true, "hours":true} forceNew:map[string]bool(nil)
														"days": dsschema.Int64Attribute{
															Description: "specify time in days. Value must be between 1 and 65535.",
															Computed:    true,
														},
														"hours": dsschema.Int64Attribute{
															Description: "specify time in hours. Value must be between 1 and 65535.",
															Computed:    true,
														},
													},
												},
											},
										},
										"product_version": dsschema.SingleNestedAttribute{
											Description: "The ProductVersion param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "greater_equal":true, "greater_than":true, "is":true, "is_not":true, "less_equal":true, "less_than":true, "not_within":true, "within":true} forceNew:map[string]bool(nil)
												"contains": dsschema.StringAttribute{
													Description: "The Contains param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"greater_equal": dsschema.StringAttribute{
													Description: "The GreaterEqual param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"greater_than": dsschema.StringAttribute{
													Description: "The GreaterThan param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is": dsschema.StringAttribute{
													Description: "The Is param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is_not": dsschema.StringAttribute{
													Description: "The IsNot param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"less_equal": dsschema.StringAttribute{
													Description: "The LessEqual param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"less_than": dsschema.StringAttribute{
													Description: "The LessThan param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"not_within": dsschema.SingleNestedAttribute{
													Description: "The NotWithin param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"versions":true} forceNew:map[string]bool(nil)
														"versions": dsschema.Int64Attribute{
															Description: "versions range. Value must be between 1 and 65535. Default: `1`.",
															Computed:    true,
														},
													},
												},
												"within": dsschema.SingleNestedAttribute{
													Description: "The Within param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"versions":true} forceNew:map[string]bool(nil)
														"versions": dsschema.Int64Attribute{
															Description: "versions range. Value must be between 1 and 65535. Default: `1`.",
															Computed:    true,
														},
													},
												},
											},
										},
										"real_time_protection": dsschema.StringAttribute{
											Description: "real time protection. String must be one of these: `\"no\"`, `\"yes\"`, `\"not-available\"`.",
											Computed:    true,
										},
										"virdef_version": dsschema.SingleNestedAttribute{
											Description: "The VirdefVersion param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"not_within":true, "within":true} forceNew:map[string]bool(nil)
												"not_within": dsschema.SingleNestedAttribute{
													Description: "The NotWithin param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"days":true, "versions":true} forceNew:map[string]bool(nil)
														"days": dsschema.Int64Attribute{
															Description: "specify time in days. Value must be between 1 and 65535.",
															Computed:    true,
														},
														"versions": dsschema.Int64Attribute{
															Description: "specify versions range. Value must be between 1 and 65535.",
															Computed:    true,
														},
													},
												},
												"within": dsschema.SingleNestedAttribute{
													Description: "The Within param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"days":true, "versions":true} forceNew:map[string]bool(nil)
														"days": dsschema.Int64Attribute{
															Description: "specify time in days. Value must be between 1 and 65535.",
															Computed:    true,
														},
														"versions": dsschema.Int64Attribute{
															Description: "specify versions range. Value must be between 1 and 65535.",
															Computed:    true,
														},
													},
												},
											},
										},
									},
								},
								"exclude_vendor": dsschema.BoolAttribute{
									Description: "The ExcludeVendor param. Default: `false`.",
									Computed:    true,
								},
								"vendors": dsschema.ListNestedAttribute{
									Description: "Vendor name.",
									Computed:    true,
									NestedObject: dsschema.NestedAttributeObject{
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
											"name": dsschema.StringAttribute{
												Description: "The Name param. String length must not exceed 103 characters.",
												Computed:    true,
											},
											"products": dsschema.ListAttribute{
												Description: "The Products param. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
												Computed:    true,
												ElementType: types.StringType,
											},
										},
									},
								},
							},
						},
						"certificate": dsschema.SingleNestedAttribute{
							Description: "The Certificate param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true} forceNew:map[string]bool(nil)
								"criteria": dsschema.SingleNestedAttribute{
									Description: "The Criteria param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"certificate_attributes":true, "certificate_profile":true} forceNew:map[string]bool(nil)
										"certificate_attributes": dsschema.ListNestedAttribute{
											Description: "The CertificateAttributes param.",
											Computed:    true,
											NestedObject: dsschema.NestedAttributeObject{
												Attributes: map[string]dsschema.Attribute{
													// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "value":true} forceNew:map[string]bool(nil)
													"name": dsschema.StringAttribute{
														Description: "Attribute Name.",
														Computed:    true,
													},
													"value": dsschema.StringAttribute{
														Description: "Key value. String length must not exceed 1024 characters. String validation regex: `.*`.",
														Computed:    true,
													},
												},
											},
										},
										"certificate_profile": dsschema.StringAttribute{
											Description: "Profile for authenticating client certificates.",
											Computed:    true,
										},
									},
								},
							},
						},
						"custom_checks": dsschema.SingleNestedAttribute{
							Description: "The CustomChecks param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true} forceNew:map[string]bool(nil)
								"criteria": dsschema.SingleNestedAttribute{
									Description: "The Criteria param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"plist":true, "process_list":true, "registry_key":true} forceNew:map[string]bool(nil)
										"plist": dsschema.ListNestedAttribute{
											Description: "The Plist param.",
											Computed:    true,
											NestedObject: dsschema.NestedAttributeObject{
												Attributes: map[string]dsschema.Attribute{
													// inputs:map[string]bool{} outputs:map[string]bool{"key":true, "name":true, "negate":true} forceNew:map[string]bool(nil)
													"keys": dsschema.ListNestedAttribute{
														Description: "The Keys param.",
														Computed:    true,
														NestedObject: dsschema.NestedAttributeObject{
															Attributes: map[string]dsschema.Attribute{
																// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "negate":true, "value":true} forceNew:map[string]bool(nil)
																"name": dsschema.StringAttribute{
																	Description: "Key name. String length must not exceed 1023 characters.",
																	Computed:    true,
																},
																"negate": dsschema.BoolAttribute{
																	Description: "Value does not exist or match specified value data. Default: `false`.",
																	Computed:    true,
																},
																"value": dsschema.StringAttribute{
																	Description: "Key value. String length must not exceed 1024 characters. String validation regex: `.*`.",
																	Computed:    true,
																},
															},
														},
													},
													"name": dsschema.StringAttribute{
														Description: "Preference list. String length must not exceed 1023 characters.",
														Computed:    true,
													},
													"negate": dsschema.BoolAttribute{
														Description: "Plist does not exist. Default: `false`.",
														Computed:    true,
													},
												},
											},
										},
										"process_list": dsschema.ListNestedAttribute{
											Description: "The ProcessList param.",
											Computed:    true,
											NestedObject: dsschema.NestedAttributeObject{
												Attributes: map[string]dsschema.Attribute{
													// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "running":true} forceNew:map[string]bool(nil)
													"name": dsschema.StringAttribute{
														Description: "Process Name. String length must not exceed 1023 characters.",
														Computed:    true,
													},
													"running": dsschema.BoolAttribute{
														Description: "The Running param. Default: `true`.",
														Computed:    true,
													},
												},
											},
										},
										"registry_keys": dsschema.ListNestedAttribute{
											Description: "The RegistryKeys param.",
											Computed:    true,
											NestedObject: dsschema.NestedAttributeObject{
												Attributes: map[string]dsschema.Attribute{
													// inputs:map[string]bool{} outputs:map[string]bool{"default_value_data":true, "name":true, "negate":true, "registry_value":true} forceNew:map[string]bool(nil)
													"default_value_data": dsschema.StringAttribute{
														Description: "Registry key default value data. String length must not exceed 1024 characters. String validation regex: `.*`.",
														Computed:    true,
													},
													"name": dsschema.StringAttribute{
														Description: "Registry key. String length must not exceed 1023 characters.",
														Computed:    true,
													},
													"negate": dsschema.BoolAttribute{
														Description: "Key does not exist or match specified value data. Default: `false`.",
														Computed:    true,
													},
													"registry_values": dsschema.ListNestedAttribute{
														Description: "The RegistryValues param.",
														Computed:    true,
														NestedObject: dsschema.NestedAttributeObject{
															Attributes: map[string]dsschema.Attribute{
																// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "negate":true, "value_data":true} forceNew:map[string]bool(nil)
																"name": dsschema.StringAttribute{
																	Description: "Registry value name. String length must not exceed 1023 characters.",
																	Computed:    true,
																},
																"negate": dsschema.BoolAttribute{
																	Description: "Value does not exist or match specified value data. Default: `false`.",
																	Computed:    true,
																},
																"value_data": dsschema.StringAttribute{
																	Description: "Registry value data. String length must not exceed 1024 characters. String validation regex: `.*`.",
																	Computed:    true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"data_loss_prevention": dsschema.SingleNestedAttribute{
							Description: "The DataLossPrevention param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
								"criteria": dsschema.SingleNestedAttribute{
									Description: "The Criteria param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"is_enabled":true, "is_installed":true} forceNew:map[string]bool(nil)
										"is_enabled": dsschema.StringAttribute{
											Description: "is enabled. String must be one of these: `\"no\"`, `\"yes\"`, `\"not-available\"`.",
											Computed:    true,
										},
										"is_installed": dsschema.BoolAttribute{
											Description: "Is Installed. Default: `true`.",
											Computed:    true,
										},
									},
								},
								"exclude_vendor": dsschema.BoolAttribute{
									Description: "The ExcludeVendor param. Default: `false`.",
									Computed:    true,
								},
								"vendors": dsschema.ListNestedAttribute{
									Description: "Vendor name.",
									Computed:    true,
									NestedObject: dsschema.NestedAttributeObject{
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
											"name": dsschema.StringAttribute{
												Description: "The Name param. String length must not exceed 103 characters.",
												Computed:    true,
											},
											"products": dsschema.ListAttribute{
												Description: "Product name. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
												Computed:    true,
												ElementType: types.StringType,
											},
										},
									},
								},
							},
						},
						"description": dsschema.StringAttribute{
							Description: "The Description param. String length must not exceed 255 characters.",
							Computed:    true,
						},
						"disk_backup": dsschema.SingleNestedAttribute{
							Description: "The DiskBackup param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
								"criteria": dsschema.SingleNestedAttribute{
									Description: "The Criteria param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"is_installed":true, "last_backup_time":true} forceNew:map[string]bool(nil)
										"is_installed": dsschema.BoolAttribute{
											Description: "Is Installed. Default: `true`.",
											Computed:    true,
										},
										"last_backup_time": dsschema.SingleNestedAttribute{
											Description: "The LastBackupTime param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"not_available":true, "not_within":true, "within":true} forceNew:map[string]bool(nil)
												"not_available": dsschema.BoolAttribute{
													Description: "The NotAvailable param.",
													Computed:    true,
												},
												"not_within": dsschema.SingleNestedAttribute{
													Description: "The NotWithin param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"days":true, "hours":true} forceNew:map[string]bool(nil)
														"days": dsschema.Int64Attribute{
															Description: "specify time in days. Value must be between 1 and 65535.",
															Computed:    true,
														},
														"hours": dsschema.Int64Attribute{
															Description: "specify time in hours. Value must be between 1 and 65535.",
															Computed:    true,
														},
													},
												},
												"within": dsschema.SingleNestedAttribute{
													Description: "The Within param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"days":true, "hours":true} forceNew:map[string]bool(nil)
														"days": dsschema.Int64Attribute{
															Description: "specify time in days. Value must be between 1 and 65535.",
															Computed:    true,
														},
														"hours": dsschema.Int64Attribute{
															Description: "specify time in hours. Value must be between 1 and 65535.",
															Computed:    true,
														},
													},
												},
											},
										},
									},
								},
								"exclude_vendor": dsschema.BoolAttribute{
									Description: "The ExcludeVendor param. Default: `false`.",
									Computed:    true,
								},
								"vendors": dsschema.ListNestedAttribute{
									Description: "Vendor name.",
									Computed:    true,
									NestedObject: dsschema.NestedAttributeObject{
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
											"name": dsschema.StringAttribute{
												Description: "The Name param. String length must not exceed 103 characters.",
												Computed:    true,
											},
											"products": dsschema.ListAttribute{
												Description: "The Products param. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
												Computed:    true,
												ElementType: types.StringType,
											},
										},
									},
								},
							},
						},
						"disk_encryption": dsschema.SingleNestedAttribute{
							Description: "The DiskEncryption param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
								"criteria": dsschema.SingleNestedAttribute{
									Description: "Encryption locations.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"encrypted_locations":true, "is_installed":true} forceNew:map[string]bool(nil)
										"encrypted_locations": dsschema.ListNestedAttribute{
											Description: "The EncryptedLocations param.",
											Computed:    true,
											NestedObject: dsschema.NestedAttributeObject{
												Attributes: map[string]dsschema.Attribute{
													// inputs:map[string]bool{} outputs:map[string]bool{"encryption_state":true, "name":true} forceNew:map[string]bool(nil)
													"encryption_state": dsschema.SingleNestedAttribute{
														Description: "The EncryptionState param.",
														Computed:    true,
														Attributes: map[string]dsschema.Attribute{
															// inputs:map[string]bool{} outputs:map[string]bool{"is":true, "is_not":true} forceNew:map[string]bool(nil)
															"is": dsschema.StringAttribute{
																Description: "The Is param. String must be one of these: `\"encrypted\"`, `\"unencrypted\"`, `\"partial\"`, `\"unknown\"`.",
																Computed:    true,
															},
															"is_not": dsschema.StringAttribute{
																Description: "The IsNot param. String must be one of these: `\"encrypted\"`, `\"unencrypted\"`, `\"partial\"`, `\"unknown\"`.",
																Computed:    true,
															},
														},
													},
													"name": dsschema.StringAttribute{
														Description: "Encryption location. String length must not exceed 1023 characters.",
														Computed:    true,
													},
												},
											},
										},
										"is_installed": dsschema.BoolAttribute{
											Description: "Is Installed. Default: `true`.",
											Computed:    true,
										},
									},
								},
								"exclude_vendor": dsschema.BoolAttribute{
									Description: "The ExcludeVendor param. Default: `false`.",
									Computed:    true,
								},
								"vendors": dsschema.ListNestedAttribute{
									Description: "Vendor name.",
									Computed:    true,
									NestedObject: dsschema.NestedAttributeObject{
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
											"name": dsschema.StringAttribute{
												Description: "The Name param. String length must not exceed 103 characters.",
												Computed:    true,
											},
											"products": dsschema.ListAttribute{
												Description: "The Products param. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
												Computed:    true,
												ElementType: types.StringType,
											},
										},
									},
								},
							},
						},
						"firewall": dsschema.SingleNestedAttribute{
							Description: "The Firewall param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
								"criteria": dsschema.SingleNestedAttribute{
									Description: "The Criteria param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"is_enabled":true, "is_installed":true} forceNew:map[string]bool(nil)
										"is_enabled": dsschema.StringAttribute{
											Description: "is enabled. String must be one of these: `\"no\"`, `\"yes\"`, `\"not-available\"`.",
											Computed:    true,
										},
										"is_installed": dsschema.BoolAttribute{
											Description: "Is Installed. Default: `true`.",
											Computed:    true,
										},
									},
								},
								"exclude_vendor": dsschema.BoolAttribute{
									Description: "The ExcludeVendor param. Default: `false`.",
									Computed:    true,
								},
								"vendors": dsschema.ListNestedAttribute{
									Description: "Vendor name.",
									Computed:    true,
									NestedObject: dsschema.NestedAttributeObject{
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
											"name": dsschema.StringAttribute{
												Description: "The Name param. String length must not exceed 103 characters.",
												Computed:    true,
											},
											"products": dsschema.ListAttribute{
												Description: "The Products param. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
												Computed:    true,
												ElementType: types.StringType,
											},
										},
									},
								},
							},
						},
						"host_info": dsschema.SingleNestedAttribute{
							Description: "The HostInfo param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true} forceNew:map[string]bool(nil)
								"criteria": dsschema.SingleNestedAttribute{
									Description: "The Criteria param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"client_version":true, "domain":true, "host_id":true, "host_name":true, "managed":true, "os":true, "serial_number":true} forceNew:map[string]bool(nil)
										"client_version": dsschema.SingleNestedAttribute{
											Description: "The ClientVersion param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
												"contains": dsschema.StringAttribute{
													Description: "The Contains param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is": dsschema.StringAttribute{
													Description: "The Is param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is_not": dsschema.StringAttribute{
													Description: "The IsNot param. String length must not exceed 255 characters.",
													Computed:    true,
												},
											},
										},
										"domain": dsschema.SingleNestedAttribute{
											Description: "The Domain param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
												"contains": dsschema.StringAttribute{
													Description: "The Contains param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is": dsschema.StringAttribute{
													Description: "The Is param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is_not": dsschema.StringAttribute{
													Description: "The IsNot param. String length must not exceed 255 characters.",
													Computed:    true,
												},
											},
										},
										"host_id": dsschema.SingleNestedAttribute{
											Description: "The HostId param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
												"contains": dsschema.StringAttribute{
													Description: "The Contains param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is": dsschema.StringAttribute{
													Description: "The Is param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is_not": dsschema.StringAttribute{
													Description: "The IsNot param. String length must not exceed 255 characters.",
													Computed:    true,
												},
											},
										},
										"host_name": dsschema.SingleNestedAttribute{
											Description: "The HostName param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
												"contains": dsschema.StringAttribute{
													Description: "The Contains param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is": dsschema.StringAttribute{
													Description: "The Is param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is_not": dsschema.StringAttribute{
													Description: "The IsNot param. String length must not exceed 255 characters.",
													Computed:    true,
												},
											},
										},
										"managed": dsschema.BoolAttribute{
											Description: "If device is managed.",
											Computed:    true,
										},
										"os": dsschema.SingleNestedAttribute{
											Description: "The Os param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"contains":true} forceNew:map[string]bool(nil)
												"contains": dsschema.SingleNestedAttribute{
													Description: "The Contains param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"Apple":true, "Google":true, "Linux":true, "Microsoft":true, "Other":true} forceNew:map[string]bool(nil)
														"apple": dsschema.StringAttribute{
															Description: "Apple vendor. String length must not exceed 255 characters.",
															Computed:    true,
														},
														"google": dsschema.StringAttribute{
															Description: "Google vendor. String length must not exceed 255 characters.",
															Computed:    true,
														},
														"linux": dsschema.StringAttribute{
															Description: "Linux vendor. String length must not exceed 255 characters.",
															Computed:    true,
														},
														"microsoft": dsschema.StringAttribute{
															Description: "Microsoft vendor. String length must not exceed 255 characters.",
															Computed:    true,
														},
														"other": dsschema.StringAttribute{
															Description: "Other vendor. String length must not exceed 255 characters.",
															Computed:    true,
														},
													},
												},
											},
										},
										"serial_number": dsschema.SingleNestedAttribute{
											Description: "The SerialNumber param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
												"contains": dsschema.StringAttribute{
													Description: "The Contains param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is": dsschema.StringAttribute{
													Description: "The Is param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is_not": dsschema.StringAttribute{
													Description: "The IsNot param. String length must not exceed 255 characters.",
													Computed:    true,
												},
											},
										},
									},
								},
							},
						},
						"id": dsschema.StringAttribute{
							Description: "UUID of the resource.",
							Computed:    true,
						},
						"mobile_device": dsschema.SingleNestedAttribute{
							Description: "The MobileDevice param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true} forceNew:map[string]bool(nil)
								"criteria": dsschema.SingleNestedAttribute{
									Description: "The Criteria param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"applications":true, "disk_encrypted":true, "imei":true, "jailbroken":true, "last_checkin_time":true, "model":true, "passcode_set":true, "phone_number":true, "tag":true} forceNew:map[string]bool(nil)
										"applications": dsschema.SingleNestedAttribute{
											Description: "The Applications param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"has_malware":true, "has_unmanaged_app":true, "includes":true} forceNew:map[string]bool(nil)
												"has_malware": dsschema.SingleNestedAttribute{
													Description: "The HasMalware param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"no":true, "yes":true} forceNew:map[string]bool(nil)
														"no": dsschema.BoolAttribute{
															Description: "The No param.",
															Computed:    true,
														},
														"yes": dsschema.SingleNestedAttribute{
															Description: "The Yes param.",
															Computed:    true,
															Attributes: map[string]dsschema.Attribute{
																// inputs:map[string]bool{} outputs:map[string]bool{"excludes":true} forceNew:map[string]bool(nil)
																"excludes": dsschema.ListNestedAttribute{
																	Description: "The Excludes param.",
																	Computed:    true,
																	NestedObject: dsschema.NestedAttributeObject{
																		Attributes: map[string]dsschema.Attribute{
																			// inputs:map[string]bool{} outputs:map[string]bool{"hash":true, "name":true, "package":true} forceNew:map[string]bool(nil)
																			"hash": dsschema.StringAttribute{
																				Description: "application hash. String length must not exceed 1024 characters. String validation regex: `.*`.",
																				Computed:    true,
																			},
																			"name": dsschema.StringAttribute{
																				Description: "The Name param. String length must not exceed 31 characters.",
																				Computed:    true,
																			},
																			"package": dsschema.StringAttribute{
																				Description: "application package name. String length must not exceed 1024 characters. String validation regex: `.*`.",
																				Computed:    true,
																			},
																		},
																	},
																},
															},
														},
													},
												},
												"has_unmanaged_app": dsschema.BoolAttribute{
													Description: "Has apps that are not managed.",
													Computed:    true,
												},
												"includes": dsschema.ListNestedAttribute{
													Description: "The Includes param.",
													Computed:    true,
													NestedObject: dsschema.NestedAttributeObject{
														Attributes: map[string]dsschema.Attribute{
															// inputs:map[string]bool{} outputs:map[string]bool{"hash":true, "name":true, "package":true} forceNew:map[string]bool(nil)
															"hash": dsschema.StringAttribute{
																Description: "application hash. String length must not exceed 1024 characters. String validation regex: `.*`.",
																Computed:    true,
															},
															"name": dsschema.StringAttribute{
																Description: "The Name param. String length must not exceed 31 characters.",
																Computed:    true,
															},
															"package": dsschema.StringAttribute{
																Description: "application package name. String length must not exceed 1024 characters. String validation regex: `.*`.",
																Computed:    true,
															},
														},
													},
												},
											},
										},
										"disk_encrypted": dsschema.BoolAttribute{
											Description: "If device's disk is encrypted.",
											Computed:    true,
										},
										"imei": dsschema.SingleNestedAttribute{
											Description: "The Imei param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
												"contains": dsschema.StringAttribute{
													Description: "The Contains param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is": dsschema.StringAttribute{
													Description: "The Is param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is_not": dsschema.StringAttribute{
													Description: "The IsNot param. String length must not exceed 255 characters.",
													Computed:    true,
												},
											},
										},
										"jailbroken": dsschema.BoolAttribute{
											Description: "If device is by rooted/jailbroken.",
											Computed:    true,
										},
										"last_checkin_time": dsschema.SingleNestedAttribute{
											Description: "The LastCheckinTime param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"not_within":true, "within":true} forceNew:map[string]bool(nil)
												"not_within": dsschema.SingleNestedAttribute{
													Description: "The NotWithin param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"days":true} forceNew:map[string]bool(nil)
														"days": dsschema.Int64Attribute{
															Description: "specify time in days. Value must be between 1 and 365. Default: `30`.",
															Computed:    true,
														},
													},
												},
												"within": dsschema.SingleNestedAttribute{
													Description: "The Within param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"days":true} forceNew:map[string]bool(nil)
														"days": dsschema.Int64Attribute{
															Description: "specify time in days. Value must be between 1 and 365. Default: `30`.",
															Computed:    true,
														},
													},
												},
											},
										},
										"model": dsschema.SingleNestedAttribute{
											Description: "The Model param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
												"contains": dsschema.StringAttribute{
													Description: "The Contains param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is": dsschema.StringAttribute{
													Description: "The Is param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is_not": dsschema.StringAttribute{
													Description: "The IsNot param. String length must not exceed 255 characters.",
													Computed:    true,
												},
											},
										},
										"passcode_set": dsschema.BoolAttribute{
											Description: "If device's passcode is present.",
											Computed:    true,
										},
										"phone_number": dsschema.SingleNestedAttribute{
											Description: "The PhoneNumber param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
												"contains": dsschema.StringAttribute{
													Description: "The Contains param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is": dsschema.StringAttribute{
													Description: "The Is param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is_not": dsschema.StringAttribute{
													Description: "The IsNot param. String length must not exceed 255 characters.",
													Computed:    true,
												},
											},
										},
										"tag": dsschema.SingleNestedAttribute{
											Description: "The Tag param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
												"contains": dsschema.StringAttribute{
													Description: "The Contains param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is": dsschema.StringAttribute{
													Description: "The Is param. String length must not exceed 255 characters.",
													Computed:    true,
												},
												"is_not": dsschema.StringAttribute{
													Description: "The IsNot param. String length must not exceed 255 characters.",
													Computed:    true,
												},
											},
										},
									},
								},
							},
						},
						"name": dsschema.StringAttribute{
							Description: "Alphanumeric string [ 0-9a-zA-Z._-]. String length must not exceed 31 characters.",
							Computed:    true,
						},
						"network_info": dsschema.SingleNestedAttribute{
							Description: "The NetworkInfo param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true} forceNew:map[string]bool(nil)
								"criteria": dsschema.SingleNestedAttribute{
									Description: "The Criteria param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"network":true} forceNew:map[string]bool(nil)
										"network": dsschema.SingleNestedAttribute{
											Description: "The Network param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"is":true, "is_not":true} forceNew:map[string]bool(nil)
												"is": dsschema.SingleNestedAttribute{
													Description: "The Is param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"mobile":true, "unknown":true, "wifi":true} forceNew:map[string]bool(nil)
														"mobile": dsschema.SingleNestedAttribute{
															Description: "The Mobile param.",
															Computed:    true,
															Attributes: map[string]dsschema.Attribute{
																// inputs:map[string]bool{} outputs:map[string]bool{"carrier":true} forceNew:map[string]bool(nil)
																"carrier": dsschema.StringAttribute{
																	Description: "The Carrier param. String length must not exceed 1023 characters. String validation regex: `.*`.",
																	Computed:    true,
																},
															},
														},
														"unknown": dsschema.BoolAttribute{
															Description: "The Unknown param.",
															Computed:    true,
														},
														"wifi": dsschema.SingleNestedAttribute{
															Description: "The Wifi param.",
															Computed:    true,
															Attributes: map[string]dsschema.Attribute{
																// inputs:map[string]bool{} outputs:map[string]bool{"ssid":true} forceNew:map[string]bool(nil)
																"ssid": dsschema.StringAttribute{
																	Description: "SSID. String length must not exceed 1023 characters. String validation regex: `.*`.",
																	Computed:    true,
																},
															},
														},
													},
												},
												"is_not": dsschema.SingleNestedAttribute{
													Description: "The IsNot param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"ethernet":true, "mobile":true, "unknown":true, "wifi":true} forceNew:map[string]bool(nil)
														"ethernet": dsschema.BoolAttribute{
															Description: "The Ethernet param.",
															Computed:    true,
														},
														"mobile": dsschema.SingleNestedAttribute{
															Description: "The Mobile param.",
															Computed:    true,
															Attributes: map[string]dsschema.Attribute{
																// inputs:map[string]bool{} outputs:map[string]bool{"carrier":true} forceNew:map[string]bool(nil)
																"carrier": dsschema.StringAttribute{
																	Description: "The Carrier param. String length must not exceed 1023 characters. String validation regex: `.*`.",
																	Computed:    true,
																},
															},
														},
														"unknown": dsschema.BoolAttribute{
															Description: "The Unknown param.",
															Computed:    true,
														},
														"wifi": dsschema.SingleNestedAttribute{
															Description: "The Wifi param.",
															Computed:    true,
															Attributes: map[string]dsschema.Attribute{
																// inputs:map[string]bool{} outputs:map[string]bool{"ssid":true} forceNew:map[string]bool(nil)
																"ssid": dsschema.StringAttribute{
																	Description: "SSID. String length must not exceed 1023 characters. String validation regex: `.*`.",
																	Computed:    true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"patch_management": dsschema.SingleNestedAttribute{
							Description: "The PatchManagement param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
								"criteria": dsschema.SingleNestedAttribute{
									Description: "The Criteria param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"is_enabled":true, "is_installed":true, "missing_patches":true} forceNew:map[string]bool(nil)
										"is_enabled": dsschema.StringAttribute{
											Description: "is enabled. String must be one of these: `\"no\"`, `\"yes\"`, `\"not-available\"`.",
											Computed:    true,
										},
										"is_installed": dsschema.BoolAttribute{
											Description: "Is Installed. Default: `true`.",
											Computed:    true,
										},
										"missing_patches": dsschema.SingleNestedAttribute{
											Description: "The MissingPatches param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"check":true, "patches":true, "severity":true} forceNew:map[string]bool(nil)
												"check": dsschema.StringAttribute{
													Description: "The Check param. String must be one of these: `\"has-any\"`, `\"has-none\"`, `\"has-all\"`. Default: `\"has-any\"`.",
													Computed:    true,
												},
												"patches": dsschema.ListAttribute{
													Description: "The Patches param. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
													Computed:    true,
													ElementType: types.StringType,
												},
												"severity": dsschema.SingleNestedAttribute{
													Description: "The Severity param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"greater_equal":true, "greater_than":true, "is":true, "is_not":true, "less_equal":true, "less_than":true} forceNew:map[string]bool(nil)
														"greater_equal": dsschema.Int64Attribute{
															Description: "The GreaterEqual param. Value must be between 0 and 100000.",
															Computed:    true,
														},
														"greater_than": dsschema.Int64Attribute{
															Description: "The GreaterThan param. Value must be between 0 and 100000.",
															Computed:    true,
														},
														"is": dsschema.Int64Attribute{
															Description: "The Is param. Value must be between 0 and 100000.",
															Computed:    true,
														},
														"is_not": dsschema.Int64Attribute{
															Description: "The IsNot param. Value must be between 0 and 100000.",
															Computed:    true,
														},
														"less_equal": dsschema.Int64Attribute{
															Description: "The LessEqual param. Value must be between 0 and 100000.",
															Computed:    true,
														},
														"less_than": dsschema.Int64Attribute{
															Description: "The LessThan param. Value must be between 0 and 100000.",
															Computed:    true,
														},
													},
												},
											},
										},
									},
								},
								"exclude_vendor": dsschema.BoolAttribute{
									Description: "The ExcludeVendor param. Default: `false`.",
									Computed:    true,
								},
								"vendors": dsschema.ListNestedAttribute{
									Description: "Vendor name.",
									Computed:    true,
									NestedObject: dsschema.NestedAttributeObject{
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
											"name": dsschema.StringAttribute{
												Description: "The Name param. String length must not exceed 103 characters.",
												Computed:    true,
											},
											"products": dsschema.ListAttribute{
												Description: "Product name. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
												Computed:    true,
												ElementType: types.StringType,
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"device": dsschema.StringAttribute{
				Description: "The Device param.",
				Optional:    true,
			},
			"folder": dsschema.StringAttribute{
				Description: "The Folder param.",
				Optional:    true,
			},
			"limit": dsschema.Int64Attribute{
				Description: "The Limit param. A limit of -1 will return all configured items. Default: `200`.",
				Optional:    true,
				Computed:    true,
			},
			"name": dsschema.StringAttribute{
				Description: "The Name param.",
				Optional:    true,
			},
			"offset": dsschema.Int64Attribute{
				Description: "The Offset param. Default: `0`.",
				Optional:    true,
				Computed:    true,
			},
			"snippet": dsschema.StringAttribute{
				Description: "The Snippet param.",
				Optional:    true,
			},
			"tfid": dsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
			},
			"total": dsschema.Int64Attribute{
				Description: "The Total param.",
				Computed:    true,
			},
		},
	}
}

// Configure prepares the struct.
func (d *hipObjectListDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*scm.Client)
}

// Read performs Read for the struct.
func (d *hipObjectListDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state hipObjectListDsModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing data source listing", map[string]any{
		"data_source_name":            "scm_hip_object_list",
		"terraform_provider_function": "Read",
		"name":                        state.Name.ValueString(),
		"folder":                      state.Folder.ValueString(),
		"snippet":                     state.Snippet.ValueString(),
		"device":                      state.Device.ValueString(),
		"offset":                      state.Offset.ValueInt64(),
		"limit":                       state.Limit.ValueInt64(),
	})

	// Prepare to run the command.
	svc := sdhSKaQ.NewClient(d.client)

	// Prepare input for the API endpoint.
	input := sdhSKaQ.ListInput{}

	input.Name = state.Name.ValueStringPointer()

	input.Folder = state.Folder.ValueStringPointer()

	input.Snippet = state.Snippet.ValueStringPointer()

	input.Device = state.Device.ValueStringPointer()

	input.Offset = state.Offset.ValueInt64Pointer()

	input.Limit = state.Limit.ValueInt64Pointer()

	// Perform the operation.
	ans, err := svc.List(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error getting listing", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	if input.Name != nil {
		idBuilder.WriteString(*input.Name)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Folder != nil {
		idBuilder.WriteString(*input.Folder)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Snippet != nil {
		idBuilder.WriteString(*input.Snippet)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Device != nil {
		idBuilder.WriteString(*input.Device)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Offset != nil {
		idBuilder.WriteString(strconv.FormatInt(*input.Offset, 10))
	}

	idBuilder.WriteString(IdSeparator)
	if input.Limit != nil {
		idBuilder.WriteString(strconv.FormatInt(*input.Limit, 10))
	}

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	if len(ans.Data) == 0 {
		state.Data = nil
	} else {
		state.Data = make([]hipObjectListDsModel_suxdMuj_Config, 0, len(ans.Data))
		for _, var0 := range ans.Data {
			var1 := hipObjectListDsModel_suxdMuj_Config{}

			if var0.AntiMalware == nil {
				var1.AntiMalware = nil
			} else {
				var1.AntiMalware = &hipObjectListDsModel_suxdMuj_AntiMalwareObject{}

				if var0.AntiMalware.Criteria == nil {
					var1.AntiMalware.Criteria = nil
				} else {
					var1.AntiMalware.Criteria = &hipObjectListDsModel_suxdMuj_AntiMalwareCriteriaObject{}

					var1.AntiMalware.Criteria.IsInstalled = types.BoolPointerValue(var0.AntiMalware.Criteria.IsInstalled)

					if var0.AntiMalware.Criteria.LastScanTime == nil {
						var1.AntiMalware.Criteria.LastScanTime = nil
					} else {
						var1.AntiMalware.Criteria.LastScanTime = &hipObjectListDsModel_suxdMuj_LastScanTimeObject{}

						if var0.AntiMalware.Criteria.LastScanTime.NotAvailable != nil {
							var1.AntiMalware.Criteria.LastScanTime.NotAvailable = types.BoolValue(true)
						} else {
							var1.AntiMalware.Criteria.LastScanTime.NotAvailable = types.BoolPointerValue(nil)
						}
						//var1.AntiMalware.Criteria.LastScanTime.NotAvailable = types.BoolValue(var0.AntiMalware.Criteria.LastScanTime.NotAvailable != nil)

						if var0.AntiMalware.Criteria.LastScanTime.NotWithin == nil {
							var1.AntiMalware.Criteria.LastScanTime.NotWithin = nil
						} else {
							var1.AntiMalware.Criteria.LastScanTime.NotWithin = &hipObjectListDsModel_suxdMuj_LastScanTimeNotWithinObject{}

							var1.AntiMalware.Criteria.LastScanTime.NotWithin.Days = types.Int64PointerValue(var0.AntiMalware.Criteria.LastScanTime.NotWithin.Days)

							var1.AntiMalware.Criteria.LastScanTime.NotWithin.Hours = types.Int64PointerValue(var0.AntiMalware.Criteria.LastScanTime.NotWithin.Hours)
						}

						if var0.AntiMalware.Criteria.LastScanTime.Within == nil {
							var1.AntiMalware.Criteria.LastScanTime.Within = nil
						} else {
							var1.AntiMalware.Criteria.LastScanTime.Within = &hipObjectListDsModel_suxdMuj_LastScanTimeWithinObject{}

							var1.AntiMalware.Criteria.LastScanTime.Within.Days = types.Int64PointerValue(var0.AntiMalware.Criteria.LastScanTime.Within.Days)

							var1.AntiMalware.Criteria.LastScanTime.Within.Hours = types.Int64PointerValue(var0.AntiMalware.Criteria.LastScanTime.Within.Hours)
						}
					}

					if var0.AntiMalware.Criteria.ProductVersion == nil {
						var1.AntiMalware.Criteria.ProductVersion = nil
					} else {
						var1.AntiMalware.Criteria.ProductVersion = &hipObjectListDsModel_suxdMuj_ProductVersionObject{}

						var1.AntiMalware.Criteria.ProductVersion.Contains = types.StringPointerValue(var0.AntiMalware.Criteria.ProductVersion.Contains)

						var1.AntiMalware.Criteria.ProductVersion.GreaterEqual = types.StringPointerValue(var0.AntiMalware.Criteria.ProductVersion.GreaterEqual)

						var1.AntiMalware.Criteria.ProductVersion.GreaterThan = types.StringPointerValue(var0.AntiMalware.Criteria.ProductVersion.GreaterThan)

						var1.AntiMalware.Criteria.ProductVersion.Is = types.StringPointerValue(var0.AntiMalware.Criteria.ProductVersion.Is)

						var1.AntiMalware.Criteria.ProductVersion.IsNot = types.StringPointerValue(var0.AntiMalware.Criteria.ProductVersion.IsNot)

						var1.AntiMalware.Criteria.ProductVersion.LessEqual = types.StringPointerValue(var0.AntiMalware.Criteria.ProductVersion.LessEqual)

						var1.AntiMalware.Criteria.ProductVersion.LessThan = types.StringPointerValue(var0.AntiMalware.Criteria.ProductVersion.LessThan)

						if var0.AntiMalware.Criteria.ProductVersion.NotWithin == nil {
							var1.AntiMalware.Criteria.ProductVersion.NotWithin = nil
						} else {
							var1.AntiMalware.Criteria.ProductVersion.NotWithin = &hipObjectListDsModel_suxdMuj_ProductVersionNotWithinObject{}

							var1.AntiMalware.Criteria.ProductVersion.NotWithin.Versions = types.Int64Value(var0.AntiMalware.Criteria.ProductVersion.NotWithin.Versions)
						}

						if var0.AntiMalware.Criteria.ProductVersion.Within == nil {
							var1.AntiMalware.Criteria.ProductVersion.Within = nil
						} else {
							var1.AntiMalware.Criteria.ProductVersion.Within = &hipObjectListDsModel_suxdMuj_ProductVersionWithinObject{}

							var1.AntiMalware.Criteria.ProductVersion.Within.Versions = types.Int64Value(var0.AntiMalware.Criteria.ProductVersion.Within.Versions)
						}
					}

					var1.AntiMalware.Criteria.RealTimeProtection = types.StringPointerValue(var0.AntiMalware.Criteria.RealTimeProtection)

					if var0.AntiMalware.Criteria.VirdefVersion == nil {
						var1.AntiMalware.Criteria.VirdefVersion = nil
					} else {
						var1.AntiMalware.Criteria.VirdefVersion = &hipObjectListDsModel_suxdMuj_VirdefVersionObject{}

						if var0.AntiMalware.Criteria.VirdefVersion.NotWithin == nil {
							var1.AntiMalware.Criteria.VirdefVersion.NotWithin = nil
						} else {
							var1.AntiMalware.Criteria.VirdefVersion.NotWithin = &hipObjectListDsModel_suxdMuj_VirdefVersionNotWithinObject{}

							var1.AntiMalware.Criteria.VirdefVersion.NotWithin.Days = types.Int64PointerValue(var0.AntiMalware.Criteria.VirdefVersion.NotWithin.Days)

							var1.AntiMalware.Criteria.VirdefVersion.NotWithin.Versions = types.Int64PointerValue(var0.AntiMalware.Criteria.VirdefVersion.NotWithin.Versions)
						}

						if var0.AntiMalware.Criteria.VirdefVersion.Within == nil {
							var1.AntiMalware.Criteria.VirdefVersion.Within = nil
						} else {
							var1.AntiMalware.Criteria.VirdefVersion.Within = &hipObjectListDsModel_suxdMuj_VirdefVersionWithinObject{}

							var1.AntiMalware.Criteria.VirdefVersion.Within.Days = types.Int64PointerValue(var0.AntiMalware.Criteria.VirdefVersion.Within.Days)

							var1.AntiMalware.Criteria.VirdefVersion.Within.Versions = types.Int64PointerValue(var0.AntiMalware.Criteria.VirdefVersion.Within.Versions)
						}
					}
				}

				var1.AntiMalware.ExcludeVendor = types.BoolPointerValue(var0.AntiMalware.ExcludeVendor)

				if len(var0.AntiMalware.Vendors) == 0 {
					var1.AntiMalware.Vendors = nil
				} else {
					var1.AntiMalware.Vendors = make([]hipObjectListDsModel_suxdMuj_AntiMalwareVendorObject, 0, len(var0.AntiMalware.Vendors))
					for _, var2 := range var0.AntiMalware.Vendors {
						var3 := hipObjectListDsModel_suxdMuj_AntiMalwareVendorObject{}

						var3.Name = types.StringValue(var2.Name)

						var4, var5 := types.ListValueFrom(ctx, types.StringType, var2.Products)
						var3.Products = var4
						resp.Diagnostics.Append(var5.Errors()...)
						var1.AntiMalware.Vendors = append(var1.AntiMalware.Vendors, var3)
					}
				}
			}

			if var0.Certificate == nil {
				var1.Certificate = nil
			} else {
				var1.Certificate = &hipObjectListDsModel_suxdMuj_CertificateObject{}

				if var0.Certificate.Criteria == nil {
					var1.Certificate.Criteria = nil
				} else {
					var1.Certificate.Criteria = &hipObjectListDsModel_suxdMuj_CertificateCriteriaObject{}

					if len(var0.Certificate.Criteria.CertificateAttributes) == 0 {
						var1.Certificate.Criteria.CertificateAttributes = nil
					} else {
						var1.Certificate.Criteria.CertificateAttributes = make([]hipObjectListDsModel_suxdMuj_CertificateAttributeObject, 0, len(var0.Certificate.Criteria.CertificateAttributes))
						for _, var6 := range var0.Certificate.Criteria.CertificateAttributes {
							var7 := hipObjectListDsModel_suxdMuj_CertificateAttributeObject{}

							var7.Name = types.StringValue(var6.Name)

							var7.Value = types.StringPointerValue(var6.Value)
							var1.Certificate.Criteria.CertificateAttributes = append(var1.Certificate.Criteria.CertificateAttributes, var7)
						}
					}

					var1.Certificate.Criteria.CertificateProfile = types.StringPointerValue(var0.Certificate.Criteria.CertificateProfile)
				}
			}

			if var0.CustomChecks == nil {
				var1.CustomChecks = nil
			} else {
				var1.CustomChecks = &hipObjectListDsModel_suxdMuj_CustomChecksObject{}

				var1.CustomChecks.Criteria = hipObjectListDsModel_suxdMuj_CustomChecksCriteriaObject{}

				if len(var0.CustomChecks.Criteria.Plist) == 0 {
					var1.CustomChecks.Criteria.Plist = nil
				} else {
					var1.CustomChecks.Criteria.Plist = make([]hipObjectListDsModel_suxdMuj_PlistObject, 0, len(var0.CustomChecks.Criteria.Plist))
					for _, var8 := range var0.CustomChecks.Criteria.Plist {
						var9 := hipObjectListDsModel_suxdMuj_PlistObject{}

						if len(var8.Keys) == 0 {
							var9.Keys = nil
						} else {
							var9.Keys = make([]hipObjectListDsModel_suxdMuj_KeyObject, 0, len(var8.Keys))
							for _, var10 := range var8.Keys {
								var11 := hipObjectListDsModel_suxdMuj_KeyObject{}

								var11.Name = types.StringValue(var10.Name)

								var11.Negate = types.BoolPointerValue(var10.Negate)

								var11.Value = types.StringPointerValue(var10.Value)
								var9.Keys = append(var9.Keys, var11)
							}
						}

						var9.Name = types.StringValue(var8.Name)

						var9.Negate = types.BoolPointerValue(var8.Negate)
						var1.CustomChecks.Criteria.Plist = append(var1.CustomChecks.Criteria.Plist, var9)
					}
				}

				if len(var0.CustomChecks.Criteria.ProcessList) == 0 {
					var1.CustomChecks.Criteria.ProcessList = nil
				} else {
					var1.CustomChecks.Criteria.ProcessList = make([]hipObjectListDsModel_suxdMuj_ProcessListObject, 0, len(var0.CustomChecks.Criteria.ProcessList))
					for _, var12 := range var0.CustomChecks.Criteria.ProcessList {
						var13 := hipObjectListDsModel_suxdMuj_ProcessListObject{}

						var13.Name = types.StringValue(var12.Name)

						var13.Running = types.BoolPointerValue(var12.Running)
						var1.CustomChecks.Criteria.ProcessList = append(var1.CustomChecks.Criteria.ProcessList, var13)
					}
				}

				if len(var0.CustomChecks.Criteria.RegistryKeys) == 0 {
					var1.CustomChecks.Criteria.RegistryKeys = nil
				} else {
					var1.CustomChecks.Criteria.RegistryKeys = make([]hipObjectListDsModel_suxdMuj_RegistryKeyObject, 0, len(var0.CustomChecks.Criteria.RegistryKeys))
					for _, var14 := range var0.CustomChecks.Criteria.RegistryKeys {
						var15 := hipObjectListDsModel_suxdMuj_RegistryKeyObject{}

						var15.DefaultValueData = types.StringPointerValue(var14.DefaultValueData)

						var15.Name = types.StringValue(var14.Name)

						var15.Negate = types.BoolPointerValue(var14.Negate)

						if len(var14.RegistryValues) == 0 {
							var15.RegistryValues = nil
						} else {
							var15.RegistryValues = make([]hipObjectListDsModel_suxdMuj_RegistryValueObject, 0, len(var14.RegistryValues))
							for _, var16 := range var14.RegistryValues {
								var17 := hipObjectListDsModel_suxdMuj_RegistryValueObject{}

								var17.Name = types.StringValue(var16.Name)

								var17.Negate = types.BoolPointerValue(var16.Negate)

								var17.ValueData = types.StringPointerValue(var16.ValueData)
								var15.RegistryValues = append(var15.RegistryValues, var17)
							}
						}
						var1.CustomChecks.Criteria.RegistryKeys = append(var1.CustomChecks.Criteria.RegistryKeys, var15)
					}
				}
			}

			if var0.DataLossPrevention == nil {
				var1.DataLossPrevention = nil
			} else {
				var1.DataLossPrevention = &hipObjectListDsModel_suxdMuj_DataLossPreventionObject{}

				if var0.DataLossPrevention.Criteria == nil {
					var1.DataLossPrevention.Criteria = nil
				} else {
					var1.DataLossPrevention.Criteria = &hipObjectListDsModel_suxdMuj_DataLossPreventionCriteriaObject{}

					var1.DataLossPrevention.Criteria.IsEnabled = types.StringPointerValue(var0.DataLossPrevention.Criteria.IsEnabled)

					var1.DataLossPrevention.Criteria.IsInstalled = types.BoolPointerValue(var0.DataLossPrevention.Criteria.IsInstalled)
				}

				var1.DataLossPrevention.ExcludeVendor = types.BoolPointerValue(var0.DataLossPrevention.ExcludeVendor)

				if len(var0.DataLossPrevention.Vendors) == 0 {
					var1.DataLossPrevention.Vendors = nil
				} else {
					var1.DataLossPrevention.Vendors = make([]hipObjectListDsModel_suxdMuj_DataLossPreventionVendorObject, 0, len(var0.DataLossPrevention.Vendors))
					for _, var18 := range var0.DataLossPrevention.Vendors {
						var19 := hipObjectListDsModel_suxdMuj_DataLossPreventionVendorObject{}

						var19.Name = types.StringValue(var18.Name)

						var20, var21 := types.ListValueFrom(ctx, types.StringType, var18.Products)
						var19.Products = var20
						resp.Diagnostics.Append(var21.Errors()...)
						var1.DataLossPrevention.Vendors = append(var1.DataLossPrevention.Vendors, var19)
					}
				}
			}

			var1.Description = types.StringPointerValue(var0.Description)

			if var0.DiskBackup == nil {
				var1.DiskBackup = nil
			} else {
				var1.DiskBackup = &hipObjectListDsModel_suxdMuj_DiskBackupObject{}

				if var0.DiskBackup.Criteria == nil {
					var1.DiskBackup.Criteria = nil
				} else {
					var1.DiskBackup.Criteria = &hipObjectListDsModel_suxdMuj_DiskBackupCriteriaObject{}

					var1.DiskBackup.Criteria.IsInstalled = types.BoolPointerValue(var0.DiskBackup.Criteria.IsInstalled)

					if var0.DiskBackup.Criteria.LastBackupTime == nil {
						var1.DiskBackup.Criteria.LastBackupTime = nil
					} else {
						var1.DiskBackup.Criteria.LastBackupTime = &hipObjectListDsModel_suxdMuj_LastBackupTimeObject{}

						if var0.DiskBackup.Criteria.LastBackupTime.NotAvailable != nil {
							var1.DiskBackup.Criteria.LastBackupTime.NotAvailable = types.BoolValue(true)
						} else {
							var1.DiskBackup.Criteria.LastBackupTime.NotAvailable = types.BoolPointerValue(nil)
						}
						//var1.DiskBackup.Criteria.LastBackupTime.NotAvailable = types.BoolValue(var0.DiskBackup.Criteria.LastBackupTime.NotAvailable != nil)

						if var0.DiskBackup.Criteria.LastBackupTime.NotWithin == nil {
							var1.DiskBackup.Criteria.LastBackupTime.NotWithin = nil
						} else {
							var1.DiskBackup.Criteria.LastBackupTime.NotWithin = &hipObjectListDsModel_suxdMuj_LastBackupTimeNotWithinObject{}

							var1.DiskBackup.Criteria.LastBackupTime.NotWithin.Days = types.Int64PointerValue(var0.DiskBackup.Criteria.LastBackupTime.NotWithin.Days)

							var1.DiskBackup.Criteria.LastBackupTime.NotWithin.Hours = types.Int64PointerValue(var0.DiskBackup.Criteria.LastBackupTime.NotWithin.Hours)
						}

						if var0.DiskBackup.Criteria.LastBackupTime.Within == nil {
							var1.DiskBackup.Criteria.LastBackupTime.Within = nil
						} else {
							var1.DiskBackup.Criteria.LastBackupTime.Within = &hipObjectListDsModel_suxdMuj_LastBackupTimeWithinObject{}

							var1.DiskBackup.Criteria.LastBackupTime.Within.Days = types.Int64PointerValue(var0.DiskBackup.Criteria.LastBackupTime.Within.Days)

							var1.DiskBackup.Criteria.LastBackupTime.Within.Hours = types.Int64PointerValue(var0.DiskBackup.Criteria.LastBackupTime.Within.Hours)
						}
					}
				}

				var1.DiskBackup.ExcludeVendor = types.BoolPointerValue(var0.DiskBackup.ExcludeVendor)

				if len(var0.DiskBackup.Vendors) == 0 {
					var1.DiskBackup.Vendors = nil
				} else {
					var1.DiskBackup.Vendors = make([]hipObjectListDsModel_suxdMuj_DiskBackupVendorObject, 0, len(var0.DiskBackup.Vendors))
					for _, var22 := range var0.DiskBackup.Vendors {
						var23 := hipObjectListDsModel_suxdMuj_DiskBackupVendorObject{}

						var23.Name = types.StringValue(var22.Name)

						var24, var25 := types.ListValueFrom(ctx, types.StringType, var22.Products)
						var23.Products = var24
						resp.Diagnostics.Append(var25.Errors()...)
						var1.DiskBackup.Vendors = append(var1.DiskBackup.Vendors, var23)
					}
				}
			}

			if var0.DiskEncryption == nil {
				var1.DiskEncryption = nil
			} else {
				var1.DiskEncryption = &hipObjectListDsModel_suxdMuj_DiskEncryptionObject{}

				if var0.DiskEncryption.Criteria == nil {
					var1.DiskEncryption.Criteria = nil
				} else {
					var1.DiskEncryption.Criteria = &hipObjectListDsModel_suxdMuj_DiskEncryptionCriteriaObject{}

					if len(var0.DiskEncryption.Criteria.EncryptedLocations) == 0 {
						var1.DiskEncryption.Criteria.EncryptedLocations = nil
					} else {
						var1.DiskEncryption.Criteria.EncryptedLocations = make([]hipObjectListDsModel_suxdMuj_EncryptedLocationObject, 0, len(var0.DiskEncryption.Criteria.EncryptedLocations))
						for _, var26 := range var0.DiskEncryption.Criteria.EncryptedLocations {
							var27 := hipObjectListDsModel_suxdMuj_EncryptedLocationObject{}

							if var26.EncryptionState == nil {
								var27.EncryptionState = nil
							} else {
								var27.EncryptionState = &hipObjectListDsModel_suxdMuj_EncryptionStateObject{}

								var27.EncryptionState.Is = types.StringPointerValue(var26.EncryptionState.Is)

								var27.EncryptionState.IsNot = types.StringPointerValue(var26.EncryptionState.IsNot)
							}

							var27.Name = types.StringValue(var26.Name)
							var1.DiskEncryption.Criteria.EncryptedLocations = append(var1.DiskEncryption.Criteria.EncryptedLocations, var27)
						}
					}

					var1.DiskEncryption.Criteria.IsInstalled = types.BoolPointerValue(var0.DiskEncryption.Criteria.IsInstalled)
				}

				var1.DiskEncryption.ExcludeVendor = types.BoolPointerValue(var0.DiskEncryption.ExcludeVendor)

				if len(var0.DiskEncryption.Vendors) == 0 {
					var1.DiskEncryption.Vendors = nil
				} else {
					var1.DiskEncryption.Vendors = make([]hipObjectListDsModel_suxdMuj_DiskEncryptionVendorObject, 0, len(var0.DiskEncryption.Vendors))
					for _, var28 := range var0.DiskEncryption.Vendors {
						var29 := hipObjectListDsModel_suxdMuj_DiskEncryptionVendorObject{}

						var29.Name = types.StringValue(var28.Name)

						var30, var31 := types.ListValueFrom(ctx, types.StringType, var28.Products)
						var29.Products = var30
						resp.Diagnostics.Append(var31.Errors()...)
						var1.DiskEncryption.Vendors = append(var1.DiskEncryption.Vendors, var29)
					}
				}
			}

			if var0.Firewall == nil {
				var1.Firewall = nil
			} else {
				var1.Firewall = &hipObjectListDsModel_suxdMuj_FirewallObject{}

				if var0.Firewall.Criteria == nil {
					var1.Firewall.Criteria = nil
				} else {
					var1.Firewall.Criteria = &hipObjectListDsModel_suxdMuj_FirewallCriteriaObject{}

					var1.Firewall.Criteria.IsEnabled = types.StringPointerValue(var0.Firewall.Criteria.IsEnabled)

					var1.Firewall.Criteria.IsInstalled = types.BoolPointerValue(var0.Firewall.Criteria.IsInstalled)
				}

				var1.Firewall.ExcludeVendor = types.BoolPointerValue(var0.Firewall.ExcludeVendor)

				if len(var0.Firewall.Vendors) == 0 {
					var1.Firewall.Vendors = nil
				} else {
					var1.Firewall.Vendors = make([]hipObjectListDsModel_suxdMuj_FirewallVendorObject, 0, len(var0.Firewall.Vendors))
					for _, var32 := range var0.Firewall.Vendors {
						var33 := hipObjectListDsModel_suxdMuj_FirewallVendorObject{}

						var33.Name = types.StringValue(var32.Name)

						var34, var35 := types.ListValueFrom(ctx, types.StringType, var32.Products)
						var33.Products = var34
						resp.Diagnostics.Append(var35.Errors()...)
						var1.Firewall.Vendors = append(var1.Firewall.Vendors, var33)
					}
				}
			}

			if var0.HostInfo == nil {
				var1.HostInfo = nil
			} else {
				var1.HostInfo = &hipObjectListDsModel_suxdMuj_HostInfoObject{}

				var1.HostInfo.Criteria = hipObjectListDsModel_suxdMuj_HostInfoCriteriaObject{}

				if var0.HostInfo.Criteria.ClientVersion == nil {
					var1.HostInfo.Criteria.ClientVersion = nil
				} else {
					var1.HostInfo.Criteria.ClientVersion = &hipObjectListDsModel_suxdMuj_ClientVersionObject{}

					var1.HostInfo.Criteria.ClientVersion.Contains = types.StringPointerValue(var0.HostInfo.Criteria.ClientVersion.Contains)

					var1.HostInfo.Criteria.ClientVersion.Is = types.StringPointerValue(var0.HostInfo.Criteria.ClientVersion.Is)

					var1.HostInfo.Criteria.ClientVersion.IsNot = types.StringPointerValue(var0.HostInfo.Criteria.ClientVersion.IsNot)
				}

				if var0.HostInfo.Criteria.Domain == nil {
					var1.HostInfo.Criteria.Domain = nil
				} else {
					var1.HostInfo.Criteria.Domain = &hipObjectListDsModel_suxdMuj_DomainObject{}

					var1.HostInfo.Criteria.Domain.Contains = types.StringPointerValue(var0.HostInfo.Criteria.Domain.Contains)

					var1.HostInfo.Criteria.Domain.Is = types.StringPointerValue(var0.HostInfo.Criteria.Domain.Is)

					var1.HostInfo.Criteria.Domain.IsNot = types.StringPointerValue(var0.HostInfo.Criteria.Domain.IsNot)
				}

				if var0.HostInfo.Criteria.HostId == nil {
					var1.HostInfo.Criteria.HostId = nil
				} else {
					var1.HostInfo.Criteria.HostId = &hipObjectListDsModel_suxdMuj_HostIdObject{}

					var1.HostInfo.Criteria.HostId.Contains = types.StringPointerValue(var0.HostInfo.Criteria.HostId.Contains)

					var1.HostInfo.Criteria.HostId.Is = types.StringPointerValue(var0.HostInfo.Criteria.HostId.Is)

					var1.HostInfo.Criteria.HostId.IsNot = types.StringPointerValue(var0.HostInfo.Criteria.HostId.IsNot)
				}

				if var0.HostInfo.Criteria.HostName == nil {
					var1.HostInfo.Criteria.HostName = nil
				} else {
					var1.HostInfo.Criteria.HostName = &hipObjectListDsModel_suxdMuj_HostNameObject{}

					var1.HostInfo.Criteria.HostName.Contains = types.StringPointerValue(var0.HostInfo.Criteria.HostName.Contains)

					var1.HostInfo.Criteria.HostName.Is = types.StringPointerValue(var0.HostInfo.Criteria.HostName.Is)

					var1.HostInfo.Criteria.HostName.IsNot = types.StringPointerValue(var0.HostInfo.Criteria.HostName.IsNot)
				}

				var1.HostInfo.Criteria.Managed = types.BoolPointerValue(var0.HostInfo.Criteria.Managed)

				if var0.HostInfo.Criteria.Os == nil {
					var1.HostInfo.Criteria.Os = nil
				} else {
					var1.HostInfo.Criteria.Os = &hipObjectListDsModel_suxdMuj_OsObject{}

					if var0.HostInfo.Criteria.Os.Contains == nil {
						var1.HostInfo.Criteria.Os.Contains = nil
					} else {
						var1.HostInfo.Criteria.Os.Contains = &hipObjectListDsModel_suxdMuj_ContainsObject{}

						var1.HostInfo.Criteria.Os.Contains.Apple = types.StringPointerValue(var0.HostInfo.Criteria.Os.Contains.Apple)

						var1.HostInfo.Criteria.Os.Contains.Google = types.StringPointerValue(var0.HostInfo.Criteria.Os.Contains.Google)

						var1.HostInfo.Criteria.Os.Contains.Linux = types.StringPointerValue(var0.HostInfo.Criteria.Os.Contains.Linux)

						var1.HostInfo.Criteria.Os.Contains.Microsoft = types.StringPointerValue(var0.HostInfo.Criteria.Os.Contains.Microsoft)

						var1.HostInfo.Criteria.Os.Contains.Other = types.StringPointerValue(var0.HostInfo.Criteria.Os.Contains.Other)
					}
				}

				if var0.HostInfo.Criteria.SerialNumber == nil {
					var1.HostInfo.Criteria.SerialNumber = nil
				} else {
					var1.HostInfo.Criteria.SerialNumber = &hipObjectListDsModel_suxdMuj_SerialNumberObject{}

					var1.HostInfo.Criteria.SerialNumber.Contains = types.StringPointerValue(var0.HostInfo.Criteria.SerialNumber.Contains)

					var1.HostInfo.Criteria.SerialNumber.Is = types.StringPointerValue(var0.HostInfo.Criteria.SerialNumber.Is)

					var1.HostInfo.Criteria.SerialNumber.IsNot = types.StringPointerValue(var0.HostInfo.Criteria.SerialNumber.IsNot)
				}
			}

			var1.Id = types.StringPointerValue(var0.Id)

			if var0.MobileDevice == nil {
				var1.MobileDevice = nil
			} else {
				var1.MobileDevice = &hipObjectListDsModel_suxdMuj_MobileDeviceObject{}

				if var0.MobileDevice.Criteria == nil {
					var1.MobileDevice.Criteria = nil
				} else {
					var1.MobileDevice.Criteria = &hipObjectListDsModel_suxdMuj_MobileDeviceCriteriaObject{}

					if var0.MobileDevice.Criteria.Applications == nil {
						var1.MobileDevice.Criteria.Applications = nil
					} else {
						var1.MobileDevice.Criteria.Applications = &hipObjectListDsModel_suxdMuj_ApplicationsObject{}

						if var0.MobileDevice.Criteria.Applications.HasMalware == nil {
							var1.MobileDevice.Criteria.Applications.HasMalware = nil
						} else {
							var1.MobileDevice.Criteria.Applications.HasMalware = &hipObjectListDsModel_suxdMuj_HasMalwareObject{}

							if var0.MobileDevice.Criteria.Applications.HasMalware.No != nil {
								var1.MobileDevice.Criteria.Applications.HasMalware.No = types.BoolValue(true)
							} else {
								var1.MobileDevice.Criteria.Applications.HasMalware.No = types.BoolPointerValue(nil)
							}
							//var1.MobileDevice.Criteria.Applications.HasMalware.No = types.BoolValue(var0.MobileDevice.Criteria.Applications.HasMalware.No != nil)

							if var0.MobileDevice.Criteria.Applications.HasMalware.Yes == nil {
								var1.MobileDevice.Criteria.Applications.HasMalware.Yes = nil
							} else {
								var1.MobileDevice.Criteria.Applications.HasMalware.Yes = &hipObjectListDsModel_suxdMuj_YesObject{}

								if len(var0.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes) == 0 {
									var1.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = nil
								} else {
									var1.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = make([]hipObjectListDsModel_suxdMuj_ExcludeObject, 0, len(var0.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes))
									for _, var36 := range var0.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes {
										var37 := hipObjectListDsModel_suxdMuj_ExcludeObject{}

										var37.Hash = types.StringPointerValue(var36.Hash)

										var37.Name = types.StringValue(var36.Name)

										var37.Package = types.StringPointerValue(var36.Package)
										var1.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = append(var1.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes, var37)
									}
								}
							}
						}

						var1.MobileDevice.Criteria.Applications.HasUnmanagedApp = types.BoolPointerValue(var0.MobileDevice.Criteria.Applications.HasUnmanagedApp)

						if len(var0.MobileDevice.Criteria.Applications.Includes) == 0 {
							var1.MobileDevice.Criteria.Applications.Includes = nil
						} else {
							var1.MobileDevice.Criteria.Applications.Includes = make([]hipObjectListDsModel_suxdMuj_IncludeObject, 0, len(var0.MobileDevice.Criteria.Applications.Includes))
							for _, var38 := range var0.MobileDevice.Criteria.Applications.Includes {
								var39 := hipObjectListDsModel_suxdMuj_IncludeObject{}

								var39.Hash = types.StringPointerValue(var38.Hash)

								var39.Name = types.StringValue(var38.Name)

								var39.Package = types.StringPointerValue(var38.Package)
								var1.MobileDevice.Criteria.Applications.Includes = append(var1.MobileDevice.Criteria.Applications.Includes, var39)
							}
						}
					}

					var1.MobileDevice.Criteria.DiskEncrypted = types.BoolPointerValue(var0.MobileDevice.Criteria.DiskEncrypted)

					if var0.MobileDevice.Criteria.Imei == nil {
						var1.MobileDevice.Criteria.Imei = nil
					} else {
						var1.MobileDevice.Criteria.Imei = &hipObjectListDsModel_suxdMuj_ImeiObject{}

						var1.MobileDevice.Criteria.Imei.Contains = types.StringPointerValue(var0.MobileDevice.Criteria.Imei.Contains)

						var1.MobileDevice.Criteria.Imei.Is = types.StringPointerValue(var0.MobileDevice.Criteria.Imei.Is)

						var1.MobileDevice.Criteria.Imei.IsNot = types.StringPointerValue(var0.MobileDevice.Criteria.Imei.IsNot)
					}

					var1.MobileDevice.Criteria.Jailbroken = types.BoolPointerValue(var0.MobileDevice.Criteria.Jailbroken)

					if var0.MobileDevice.Criteria.LastCheckinTime == nil {
						var1.MobileDevice.Criteria.LastCheckinTime = nil
					} else {
						var1.MobileDevice.Criteria.LastCheckinTime = &hipObjectListDsModel_suxdMuj_LastCheckinTimeObject{}

						if var0.MobileDevice.Criteria.LastCheckinTime.NotWithin == nil {
							var1.MobileDevice.Criteria.LastCheckinTime.NotWithin = nil
						} else {
							var1.MobileDevice.Criteria.LastCheckinTime.NotWithin = &hipObjectListDsModel_suxdMuj_LastCheckinTimeNotWithinObject{}

							var1.MobileDevice.Criteria.LastCheckinTime.NotWithin.Days = types.Int64Value(var0.MobileDevice.Criteria.LastCheckinTime.NotWithin.Days)
						}

						if var0.MobileDevice.Criteria.LastCheckinTime.Within == nil {
							var1.MobileDevice.Criteria.LastCheckinTime.Within = nil
						} else {
							var1.MobileDevice.Criteria.LastCheckinTime.Within = &hipObjectListDsModel_suxdMuj_LastCheckinTimeWithinObject{}

							var1.MobileDevice.Criteria.LastCheckinTime.Within.Days = types.Int64Value(var0.MobileDevice.Criteria.LastCheckinTime.Within.Days)
						}
					}

					if var0.MobileDevice.Criteria.Model == nil {
						var1.MobileDevice.Criteria.Model = nil
					} else {
						var1.MobileDevice.Criteria.Model = &hipObjectListDsModel_suxdMuj_ModelObject{}

						var1.MobileDevice.Criteria.Model.Contains = types.StringPointerValue(var0.MobileDevice.Criteria.Model.Contains)

						var1.MobileDevice.Criteria.Model.Is = types.StringPointerValue(var0.MobileDevice.Criteria.Model.Is)

						var1.MobileDevice.Criteria.Model.IsNot = types.StringPointerValue(var0.MobileDevice.Criteria.Model.IsNot)
					}

					var1.MobileDevice.Criteria.PasscodeSet = types.BoolPointerValue(var0.MobileDevice.Criteria.PasscodeSet)

					if var0.MobileDevice.Criteria.PhoneNumber == nil {
						var1.MobileDevice.Criteria.PhoneNumber = nil
					} else {
						var1.MobileDevice.Criteria.PhoneNumber = &hipObjectListDsModel_suxdMuj_PhoneNumberObject{}

						var1.MobileDevice.Criteria.PhoneNumber.Contains = types.StringPointerValue(var0.MobileDevice.Criteria.PhoneNumber.Contains)

						var1.MobileDevice.Criteria.PhoneNumber.Is = types.StringPointerValue(var0.MobileDevice.Criteria.PhoneNumber.Is)

						var1.MobileDevice.Criteria.PhoneNumber.IsNot = types.StringPointerValue(var0.MobileDevice.Criteria.PhoneNumber.IsNot)
					}

					if var0.MobileDevice.Criteria.Tag == nil {
						var1.MobileDevice.Criteria.Tag = nil
					} else {
						var1.MobileDevice.Criteria.Tag = &hipObjectListDsModel_suxdMuj_TagObject{}

						var1.MobileDevice.Criteria.Tag.Contains = types.StringPointerValue(var0.MobileDevice.Criteria.Tag.Contains)

						var1.MobileDevice.Criteria.Tag.Is = types.StringPointerValue(var0.MobileDevice.Criteria.Tag.Is)

						var1.MobileDevice.Criteria.Tag.IsNot = types.StringPointerValue(var0.MobileDevice.Criteria.Tag.IsNot)
					}
				}
			}

			var1.Name = types.StringValue(var0.Name)

			if var0.NetworkInfo == nil {
				var1.NetworkInfo = nil
			} else {
				var1.NetworkInfo = &hipObjectListDsModel_suxdMuj_NetworkInfoObject{}

				if var0.NetworkInfo.Criteria == nil {
					var1.NetworkInfo.Criteria = nil
				} else {
					var1.NetworkInfo.Criteria = &hipObjectListDsModel_suxdMuj_NetworkInfoCriteriaObject{}

					if var0.NetworkInfo.Criteria.Network == nil {
						var1.NetworkInfo.Criteria.Network = nil
					} else {
						var1.NetworkInfo.Criteria.Network = &hipObjectListDsModel_suxdMuj_NetworkObject{}

						if var0.NetworkInfo.Criteria.Network.Is == nil {
							var1.NetworkInfo.Criteria.Network.Is = nil
						} else {
							var1.NetworkInfo.Criteria.Network.Is = &hipObjectListDsModel_suxdMuj_IsObject{}

							if var0.NetworkInfo.Criteria.Network.Is.Mobile == nil {
								var1.NetworkInfo.Criteria.Network.Is.Mobile = nil
							} else {
								var1.NetworkInfo.Criteria.Network.Is.Mobile = &hipObjectListDsModel_suxdMuj_IsMobileObject{}

								var1.NetworkInfo.Criteria.Network.Is.Mobile.Carrier = types.StringPointerValue(var0.NetworkInfo.Criteria.Network.Is.Mobile.Carrier)
							}

							if var0.NetworkInfo.Criteria.Network.Is.Unknown != nil {
								var1.NetworkInfo.Criteria.Network.Is.Unknown = types.BoolValue(true)
							} else {
								var1.NetworkInfo.Criteria.Network.Is.Unknown = types.BoolPointerValue(nil)
							}
							//var1.NetworkInfo.Criteria.Network.Is.Unknown = types.BoolValue(var0.NetworkInfo.Criteria.Network.Is.Unknown != nil)

							if var0.NetworkInfo.Criteria.Network.Is.Wifi == nil {
								var1.NetworkInfo.Criteria.Network.Is.Wifi = nil
							} else {
								var1.NetworkInfo.Criteria.Network.Is.Wifi = &hipObjectListDsModel_suxdMuj_IsWifiObject{}

								var1.NetworkInfo.Criteria.Network.Is.Wifi.Ssid = types.StringPointerValue(var0.NetworkInfo.Criteria.Network.Is.Wifi.Ssid)
							}
						}

						if var0.NetworkInfo.Criteria.Network.IsNot == nil {
							var1.NetworkInfo.Criteria.Network.IsNot = nil
						} else {
							var1.NetworkInfo.Criteria.Network.IsNot = &hipObjectListDsModel_suxdMuj_IsNotObject{}

							if var0.NetworkInfo.Criteria.Network.IsNot.Ethernet != nil {
								var1.NetworkInfo.Criteria.Network.IsNot.Ethernet = types.BoolValue(true)
							} else {
								var1.NetworkInfo.Criteria.Network.IsNot.Ethernet = types.BoolPointerValue(nil)
							}
							//var1.NetworkInfo.Criteria.Network.IsNot.Ethernet = types.BoolValue(var0.NetworkInfo.Criteria.Network.IsNot.Ethernet != nil)

							if var0.NetworkInfo.Criteria.Network.IsNot.Mobile == nil {
								var1.NetworkInfo.Criteria.Network.IsNot.Mobile = nil
							} else {
								var1.NetworkInfo.Criteria.Network.IsNot.Mobile = &hipObjectListDsModel_suxdMuj_IsNotMobileObject{}

								var1.NetworkInfo.Criteria.Network.IsNot.Mobile.Carrier = types.StringPointerValue(var0.NetworkInfo.Criteria.Network.IsNot.Mobile.Carrier)
							}

							if var0.NetworkInfo.Criteria.Network.IsNot.Unknown != nil {
								var1.NetworkInfo.Criteria.Network.IsNot.Unknown = types.BoolValue(true)
							} else {
								var1.NetworkInfo.Criteria.Network.IsNot.Unknown = types.BoolPointerValue(nil)
							}
							//var1.NetworkInfo.Criteria.Network.IsNot.Unknown = types.BoolValue(var0.NetworkInfo.Criteria.Network.IsNot.Unknown != nil)

							if var0.NetworkInfo.Criteria.Network.IsNot.Wifi == nil {
								var1.NetworkInfo.Criteria.Network.IsNot.Wifi = nil
							} else {
								var1.NetworkInfo.Criteria.Network.IsNot.Wifi = &hipObjectListDsModel_suxdMuj_IsNotWifiObject{}

								var1.NetworkInfo.Criteria.Network.IsNot.Wifi.Ssid = types.StringPointerValue(var0.NetworkInfo.Criteria.Network.IsNot.Wifi.Ssid)
							}
						}
					}
				}
			}

			if var0.PatchManagement == nil {
				var1.PatchManagement = nil
			} else {
				var1.PatchManagement = &hipObjectListDsModel_suxdMuj_PatchManagementObject{}

				if var0.PatchManagement.Criteria == nil {
					var1.PatchManagement.Criteria = nil
				} else {
					var1.PatchManagement.Criteria = &hipObjectListDsModel_suxdMuj_CriteriaObject{}

					var1.PatchManagement.Criteria.IsEnabled = types.StringPointerValue(var0.PatchManagement.Criteria.IsEnabled)

					var1.PatchManagement.Criteria.IsInstalled = types.BoolPointerValue(var0.PatchManagement.Criteria.IsInstalled)

					if var0.PatchManagement.Criteria.MissingPatches == nil {
						var1.PatchManagement.Criteria.MissingPatches = nil
					} else {
						var1.PatchManagement.Criteria.MissingPatches = &hipObjectListDsModel_suxdMuj_MissingPatchesObject{}

						var1.PatchManagement.Criteria.MissingPatches.Check = types.StringValue(var0.PatchManagement.Criteria.MissingPatches.Check)

						var40, var41 := types.ListValueFrom(ctx, types.StringType, var0.PatchManagement.Criteria.MissingPatches.Patches)
						var1.PatchManagement.Criteria.MissingPatches.Patches = var40
						resp.Diagnostics.Append(var41.Errors()...)

						if var0.PatchManagement.Criteria.MissingPatches.Severity == nil {
							var1.PatchManagement.Criteria.MissingPatches.Severity = nil
						} else {
							var1.PatchManagement.Criteria.MissingPatches.Severity = &hipObjectListDsModel_suxdMuj_SeverityObject{}

							var1.PatchManagement.Criteria.MissingPatches.Severity.GreaterEqual = types.Int64PointerValue(var0.PatchManagement.Criteria.MissingPatches.Severity.GreaterEqual)

							var1.PatchManagement.Criteria.MissingPatches.Severity.GreaterThan = types.Int64PointerValue(var0.PatchManagement.Criteria.MissingPatches.Severity.GreaterThan)

							var1.PatchManagement.Criteria.MissingPatches.Severity.Is = types.Int64PointerValue(var0.PatchManagement.Criteria.MissingPatches.Severity.Is)

							var1.PatchManagement.Criteria.MissingPatches.Severity.IsNot = types.Int64PointerValue(var0.PatchManagement.Criteria.MissingPatches.Severity.IsNot)

							var1.PatchManagement.Criteria.MissingPatches.Severity.LessEqual = types.Int64PointerValue(var0.PatchManagement.Criteria.MissingPatches.Severity.LessEqual)

							var1.PatchManagement.Criteria.MissingPatches.Severity.LessThan = types.Int64PointerValue(var0.PatchManagement.Criteria.MissingPatches.Severity.LessThan)
						}
					}
				}

				var1.PatchManagement.ExcludeVendor = types.BoolPointerValue(var0.PatchManagement.ExcludeVendor)

				if len(var0.PatchManagement.Vendors) == 0 {
					var1.PatchManagement.Vendors = nil
				} else {
					var1.PatchManagement.Vendors = make([]hipObjectListDsModel_suxdMuj_PatchManagementVendorObject, 0, len(var0.PatchManagement.Vendors))
					for _, var42 := range var0.PatchManagement.Vendors {
						var43 := hipObjectListDsModel_suxdMuj_PatchManagementVendorObject{}

						var43.Name = types.StringValue(var42.Name)

						var44, var45 := types.ListValueFrom(ctx, types.StringType, var42.Products)
						var43.Products = var44
						resp.Diagnostics.Append(var45.Errors()...)
						var1.PatchManagement.Vendors = append(var1.PatchManagement.Vendors, var43)
					}
				}
			}
			state.Data = append(state.Data, var1)
		}
	}

	state.Limit = types.Int64PointerValue(ans.Limit)

	state.Offset = types.Int64PointerValue(ans.Offset)

	state.Total = types.Int64PointerValue(ans.Total)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Data source.
var (
	_ datasource.DataSource              = &hipObjectDataSource{}
	_ datasource.DataSourceWithConfigure = &hipObjectDataSource{}
)

func NewHipObjectDataSource() datasource.DataSource {
	return &hipObjectDataSource{}
}

type hipObjectDataSource struct {
	client *scm.Client
}

// hipObjectDsModel is the model.
type hipObjectDsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	Id types.String `tfsdk:"id"`

	// Output.
	AntiMalware        *hipObjectDsModel_suxdMuj_AntiMalwareObject        `tfsdk:"anti_malware"`
	Certificate        *hipObjectDsModel_suxdMuj_CertificateObject        `tfsdk:"certificate"`
	CustomChecks       *hipObjectDsModel_suxdMuj_CustomChecksObject       `tfsdk:"custom_checks"`
	DataLossPrevention *hipObjectDsModel_suxdMuj_DataLossPreventionObject `tfsdk:"data_loss_prevention"`
	Description        types.String                                       `tfsdk:"description"`
	DiskBackup         *hipObjectDsModel_suxdMuj_DiskBackupObject         `tfsdk:"disk_backup"`
	DiskEncryption     *hipObjectDsModel_suxdMuj_DiskEncryptionObject     `tfsdk:"disk_encryption"`
	Firewall           *hipObjectDsModel_suxdMuj_FirewallObject           `tfsdk:"firewall"`
	HostInfo           *hipObjectDsModel_suxdMuj_HostInfoObject           `tfsdk:"host_info"`
	// omit input: id
	MobileDevice    *hipObjectDsModel_suxdMuj_MobileDeviceObject    `tfsdk:"mobile_device"`
	Name            types.String                                    `tfsdk:"name"`
	NetworkInfo     *hipObjectDsModel_suxdMuj_NetworkInfoObject     `tfsdk:"network_info"`
	PatchManagement *hipObjectDsModel_suxdMuj_PatchManagementObject `tfsdk:"patch_management"`
}

type hipObjectDsModel_suxdMuj_AntiMalwareObject struct {
	Criteria      *hipObjectDsModel_suxdMuj_AntiMalwareCriteriaObject `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                          `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectDsModel_suxdMuj_AntiMalwareVendorObject  `tfsdk:"vendors"`
}

type hipObjectDsModel_suxdMuj_AntiMalwareCriteriaObject struct {
	IsInstalled        types.Bool                                     `tfsdk:"is_installed"`
	LastScanTime       *hipObjectDsModel_suxdMuj_LastScanTimeObject   `tfsdk:"last_scan_time"`
	ProductVersion     *hipObjectDsModel_suxdMuj_ProductVersionObject `tfsdk:"product_version"`
	RealTimeProtection types.String                                   `tfsdk:"real_time_protection"`
	VirdefVersion      *hipObjectDsModel_suxdMuj_VirdefVersionObject  `tfsdk:"virdef_version"`
}

type hipObjectDsModel_suxdMuj_LastScanTimeObject struct {
	NotAvailable types.Bool                                            `tfsdk:"not_available"`
	NotWithin    *hipObjectDsModel_suxdMuj_LastScanTimeNotWithinObject `tfsdk:"not_within"`
	Within       *hipObjectDsModel_suxdMuj_LastScanTimeWithinObject    `tfsdk:"within"`
}

type hipObjectDsModel_suxdMuj_LastScanTimeNotWithinObject struct {
	Days  types.Int64 `tfsdk:"days"`
	Hours types.Int64 `tfsdk:"hours"`
}

type hipObjectDsModel_suxdMuj_LastScanTimeWithinObject struct {
	Days  types.Int64 `tfsdk:"days"`
	Hours types.Int64 `tfsdk:"hours"`
}

type hipObjectDsModel_suxdMuj_ProductVersionObject struct {
	Contains     types.String                                            `tfsdk:"contains"`
	GreaterEqual types.String                                            `tfsdk:"greater_equal"`
	GreaterThan  types.String                                            `tfsdk:"greater_than"`
	Is           types.String                                            `tfsdk:"is"`
	IsNot        types.String                                            `tfsdk:"is_not"`
	LessEqual    types.String                                            `tfsdk:"less_equal"`
	LessThan     types.String                                            `tfsdk:"less_than"`
	NotWithin    *hipObjectDsModel_suxdMuj_ProductVersionNotWithinObject `tfsdk:"not_within"`
	Within       *hipObjectDsModel_suxdMuj_ProductVersionWithinObject    `tfsdk:"within"`
}

type hipObjectDsModel_suxdMuj_ProductVersionNotWithinObject struct {
	Versions types.Int64 `tfsdk:"versions"`
}

type hipObjectDsModel_suxdMuj_ProductVersionWithinObject struct {
	Versions types.Int64 `tfsdk:"versions"`
}

type hipObjectDsModel_suxdMuj_VirdefVersionObject struct {
	NotWithin *hipObjectDsModel_suxdMuj_VirdefVersionNotWithinObject `tfsdk:"not_within"`
	Within    *hipObjectDsModel_suxdMuj_VirdefVersionWithinObject    `tfsdk:"within"`
}

type hipObjectDsModel_suxdMuj_VirdefVersionNotWithinObject struct {
	Days     types.Int64 `tfsdk:"days"`
	Versions types.Int64 `tfsdk:"versions"`
}

type hipObjectDsModel_suxdMuj_VirdefVersionWithinObject struct {
	Days     types.Int64 `tfsdk:"days"`
	Versions types.Int64 `tfsdk:"versions"`
}

type hipObjectDsModel_suxdMuj_AntiMalwareVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

type hipObjectDsModel_suxdMuj_CertificateObject struct {
	Criteria *hipObjectDsModel_suxdMuj_CertificateCriteriaObject `tfsdk:"criteria"`
}

type hipObjectDsModel_suxdMuj_CertificateCriteriaObject struct {
	CertificateAttributes []hipObjectDsModel_suxdMuj_CertificateAttributeObject `tfsdk:"certificate_attributes"`
	CertificateProfile    types.String                                          `tfsdk:"certificate_profile"`
}

type hipObjectDsModel_suxdMuj_CertificateAttributeObject struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}

type hipObjectDsModel_suxdMuj_CustomChecksObject struct {
	Criteria hipObjectDsModel_suxdMuj_CustomChecksCriteriaObject `tfsdk:"criteria"`
}

type hipObjectDsModel_suxdMuj_CustomChecksCriteriaObject struct {
	Plist        []hipObjectDsModel_suxdMuj_PlistObject       `tfsdk:"plist"`
	ProcessList  []hipObjectDsModel_suxdMuj_ProcessListObject `tfsdk:"process_list"`
	RegistryKeys []hipObjectDsModel_suxdMuj_RegistryKeyObject `tfsdk:"registry_keys"`
}

type hipObjectDsModel_suxdMuj_PlistObject struct {
	Keys   []hipObjectDsModel_suxdMuj_KeyObject `tfsdk:"keys"`
	Name   types.String                         `tfsdk:"name"`
	Negate types.Bool                           `tfsdk:"negate"`
}

type hipObjectDsModel_suxdMuj_KeyObject struct {
	Name   types.String `tfsdk:"name"`
	Negate types.Bool   `tfsdk:"negate"`
	Value  types.String `tfsdk:"value"`
}

type hipObjectDsModel_suxdMuj_ProcessListObject struct {
	Name    types.String `tfsdk:"name"`
	Running types.Bool   `tfsdk:"running"`
}

type hipObjectDsModel_suxdMuj_RegistryKeyObject struct {
	DefaultValueData types.String                                   `tfsdk:"default_value_data"`
	Name             types.String                                   `tfsdk:"name"`
	Negate           types.Bool                                     `tfsdk:"negate"`
	RegistryValues   []hipObjectDsModel_suxdMuj_RegistryValueObject `tfsdk:"registry_values"`
}

type hipObjectDsModel_suxdMuj_RegistryValueObject struct {
	Name      types.String `tfsdk:"name"`
	Negate    types.Bool   `tfsdk:"negate"`
	ValueData types.String `tfsdk:"value_data"`
}

type hipObjectDsModel_suxdMuj_DataLossPreventionObject struct {
	Criteria      *hipObjectDsModel_suxdMuj_DataLossPreventionCriteriaObject `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                                 `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectDsModel_suxdMuj_DataLossPreventionVendorObject  `tfsdk:"vendors"`
}

type hipObjectDsModel_suxdMuj_DataLossPreventionCriteriaObject struct {
	IsEnabled   types.String `tfsdk:"is_enabled"`
	IsInstalled types.Bool   `tfsdk:"is_installed"`
}

type hipObjectDsModel_suxdMuj_DataLossPreventionVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

type hipObjectDsModel_suxdMuj_DiskBackupObject struct {
	Criteria      *hipObjectDsModel_suxdMuj_DiskBackupCriteriaObject `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                         `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectDsModel_suxdMuj_DiskBackupVendorObject  `tfsdk:"vendors"`
}

type hipObjectDsModel_suxdMuj_DiskBackupCriteriaObject struct {
	IsInstalled    types.Bool                                     `tfsdk:"is_installed"`
	LastBackupTime *hipObjectDsModel_suxdMuj_LastBackupTimeObject `tfsdk:"last_backup_time"`
}

type hipObjectDsModel_suxdMuj_LastBackupTimeObject struct {
	NotAvailable types.Bool                                              `tfsdk:"not_available"`
	NotWithin    *hipObjectDsModel_suxdMuj_LastBackupTimeNotWithinObject `tfsdk:"not_within"`
	Within       *hipObjectDsModel_suxdMuj_LastBackupTimeWithinObject    `tfsdk:"within"`
}

type hipObjectDsModel_suxdMuj_LastBackupTimeNotWithinObject struct {
	Days  types.Int64 `tfsdk:"days"`
	Hours types.Int64 `tfsdk:"hours"`
}

type hipObjectDsModel_suxdMuj_LastBackupTimeWithinObject struct {
	Days  types.Int64 `tfsdk:"days"`
	Hours types.Int64 `tfsdk:"hours"`
}

type hipObjectDsModel_suxdMuj_DiskBackupVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

type hipObjectDsModel_suxdMuj_DiskEncryptionObject struct {
	Criteria      *hipObjectDsModel_suxdMuj_DiskEncryptionCriteriaObject `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                             `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectDsModel_suxdMuj_DiskEncryptionVendorObject  `tfsdk:"vendors"`
}

type hipObjectDsModel_suxdMuj_DiskEncryptionCriteriaObject struct {
	EncryptedLocations []hipObjectDsModel_suxdMuj_EncryptedLocationObject `tfsdk:"encrypted_locations"`
	IsInstalled        types.Bool                                         `tfsdk:"is_installed"`
}

type hipObjectDsModel_suxdMuj_EncryptedLocationObject struct {
	EncryptionState *hipObjectDsModel_suxdMuj_EncryptionStateObject `tfsdk:"encryption_state"`
	Name            types.String                                    `tfsdk:"name"`
}

type hipObjectDsModel_suxdMuj_EncryptionStateObject struct {
	Is    types.String `tfsdk:"is"`
	IsNot types.String `tfsdk:"is_not"`
}

type hipObjectDsModel_suxdMuj_DiskEncryptionVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

type hipObjectDsModel_suxdMuj_FirewallObject struct {
	Criteria      *hipObjectDsModel_suxdMuj_FirewallCriteriaObject `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                       `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectDsModel_suxdMuj_FirewallVendorObject  `tfsdk:"vendors"`
}

type hipObjectDsModel_suxdMuj_FirewallCriteriaObject struct {
	IsEnabled   types.String `tfsdk:"is_enabled"`
	IsInstalled types.Bool   `tfsdk:"is_installed"`
}

type hipObjectDsModel_suxdMuj_FirewallVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

type hipObjectDsModel_suxdMuj_HostInfoObject struct {
	Criteria hipObjectDsModel_suxdMuj_HostInfoCriteriaObject `tfsdk:"criteria"`
}

type hipObjectDsModel_suxdMuj_HostInfoCriteriaObject struct {
	ClientVersion *hipObjectDsModel_suxdMuj_ClientVersionObject `tfsdk:"client_version"`
	Domain        *hipObjectDsModel_suxdMuj_DomainObject        `tfsdk:"domain"`
	HostId        *hipObjectDsModel_suxdMuj_HostIdObject        `tfsdk:"host_id"`
	HostName      *hipObjectDsModel_suxdMuj_HostNameObject      `tfsdk:"host_name"`
	Managed       types.Bool                                    `tfsdk:"managed"`
	Os            *hipObjectDsModel_suxdMuj_OsObject            `tfsdk:"os"`
	SerialNumber  *hipObjectDsModel_suxdMuj_SerialNumberObject  `tfsdk:"serial_number"`
}

type hipObjectDsModel_suxdMuj_ClientVersionObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectDsModel_suxdMuj_DomainObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectDsModel_suxdMuj_HostIdObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectDsModel_suxdMuj_HostNameObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectDsModel_suxdMuj_OsObject struct {
	Contains *hipObjectDsModel_suxdMuj_ContainsObject `tfsdk:"contains"`
}

type hipObjectDsModel_suxdMuj_ContainsObject struct {
	Apple     types.String `tfsdk:"apple"`
	Google    types.String `tfsdk:"google"`
	Linux     types.String `tfsdk:"linux"`
	Microsoft types.String `tfsdk:"microsoft"`
	Other     types.String `tfsdk:"other"`
}

type hipObjectDsModel_suxdMuj_SerialNumberObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectDsModel_suxdMuj_MobileDeviceObject struct {
	Criteria *hipObjectDsModel_suxdMuj_MobileDeviceCriteriaObject `tfsdk:"criteria"`
}

type hipObjectDsModel_suxdMuj_MobileDeviceCriteriaObject struct {
	Applications    *hipObjectDsModel_suxdMuj_ApplicationsObject    `tfsdk:"applications"`
	DiskEncrypted   types.Bool                                      `tfsdk:"disk_encrypted"`
	Imei            *hipObjectDsModel_suxdMuj_ImeiObject            `tfsdk:"imei"`
	Jailbroken      types.Bool                                      `tfsdk:"jailbroken"`
	LastCheckinTime *hipObjectDsModel_suxdMuj_LastCheckinTimeObject `tfsdk:"last_checkin_time"`
	Model           *hipObjectDsModel_suxdMuj_ModelObject           `tfsdk:"model"`
	PasscodeSet     types.Bool                                      `tfsdk:"passcode_set"`
	PhoneNumber     *hipObjectDsModel_suxdMuj_PhoneNumberObject     `tfsdk:"phone_number"`
	Tag             *hipObjectDsModel_suxdMuj_TagObject             `tfsdk:"tag"`
}

type hipObjectDsModel_suxdMuj_ApplicationsObject struct {
	HasMalware      *hipObjectDsModel_suxdMuj_HasMalwareObject `tfsdk:"has_malware"`
	HasUnmanagedApp types.Bool                                 `tfsdk:"has_unmanaged_app"`
	Includes        []hipObjectDsModel_suxdMuj_IncludeObject   `tfsdk:"includes"`
}

type hipObjectDsModel_suxdMuj_HasMalwareObject struct {
	No  types.Bool                          `tfsdk:"no"`
	Yes *hipObjectDsModel_suxdMuj_YesObject `tfsdk:"yes"`
}

type hipObjectDsModel_suxdMuj_YesObject struct {
	Excludes []hipObjectDsModel_suxdMuj_ExcludeObject `tfsdk:"excludes"`
}

type hipObjectDsModel_suxdMuj_ExcludeObject struct {
	Hash    types.String `tfsdk:"hash"`
	Name    types.String `tfsdk:"name"`
	Package types.String `tfsdk:"package"`
}

type hipObjectDsModel_suxdMuj_IncludeObject struct {
	Hash    types.String `tfsdk:"hash"`
	Name    types.String `tfsdk:"name"`
	Package types.String `tfsdk:"package"`
}

type hipObjectDsModel_suxdMuj_ImeiObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectDsModel_suxdMuj_LastCheckinTimeObject struct {
	NotWithin *hipObjectDsModel_suxdMuj_LastCheckinTimeNotWithinObject `tfsdk:"not_within"`
	Within    *hipObjectDsModel_suxdMuj_LastCheckinTimeWithinObject    `tfsdk:"within"`
}

type hipObjectDsModel_suxdMuj_LastCheckinTimeNotWithinObject struct {
	Days types.Int64 `tfsdk:"days"`
}

type hipObjectDsModel_suxdMuj_LastCheckinTimeWithinObject struct {
	Days types.Int64 `tfsdk:"days"`
}

type hipObjectDsModel_suxdMuj_ModelObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectDsModel_suxdMuj_PhoneNumberObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectDsModel_suxdMuj_TagObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectDsModel_suxdMuj_NetworkInfoObject struct {
	Criteria *hipObjectDsModel_suxdMuj_NetworkInfoCriteriaObject `tfsdk:"criteria"`
}

type hipObjectDsModel_suxdMuj_NetworkInfoCriteriaObject struct {
	Network *hipObjectDsModel_suxdMuj_NetworkObject `tfsdk:"network"`
}

type hipObjectDsModel_suxdMuj_NetworkObject struct {
	Is    *hipObjectDsModel_suxdMuj_IsObject    `tfsdk:"is"`
	IsNot *hipObjectDsModel_suxdMuj_IsNotObject `tfsdk:"is_not"`
}

type hipObjectDsModel_suxdMuj_IsObject struct {
	Mobile  *hipObjectDsModel_suxdMuj_IsMobileObject `tfsdk:"mobile"`
	Unknown types.Bool                               `tfsdk:"unknown"`
	Wifi    *hipObjectDsModel_suxdMuj_IsWifiObject   `tfsdk:"wifi"`
}

type hipObjectDsModel_suxdMuj_IsMobileObject struct {
	Carrier types.String `tfsdk:"carrier"`
}

type hipObjectDsModel_suxdMuj_IsWifiObject struct {
	Ssid types.String `tfsdk:"ssid"`
}

type hipObjectDsModel_suxdMuj_IsNotObject struct {
	Ethernet types.Bool                                  `tfsdk:"ethernet"`
	Mobile   *hipObjectDsModel_suxdMuj_IsNotMobileObject `tfsdk:"mobile"`
	Unknown  types.Bool                                  `tfsdk:"unknown"`
	Wifi     *hipObjectDsModel_suxdMuj_IsNotWifiObject   `tfsdk:"wifi"`
}

type hipObjectDsModel_suxdMuj_IsNotMobileObject struct {
	Carrier types.String `tfsdk:"carrier"`
}

type hipObjectDsModel_suxdMuj_IsNotWifiObject struct {
	Ssid types.String `tfsdk:"ssid"`
}

type hipObjectDsModel_suxdMuj_PatchManagementObject struct {
	Criteria      *hipObjectDsModel_suxdMuj_CriteriaObject               `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                             `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectDsModel_suxdMuj_PatchManagementVendorObject `tfsdk:"vendors"`
}

type hipObjectDsModel_suxdMuj_CriteriaObject struct {
	IsEnabled      types.String                                   `tfsdk:"is_enabled"`
	IsInstalled    types.Bool                                     `tfsdk:"is_installed"`
	MissingPatches *hipObjectDsModel_suxdMuj_MissingPatchesObject `tfsdk:"missing_patches"`
}

type hipObjectDsModel_suxdMuj_MissingPatchesObject struct {
	Check    types.String                             `tfsdk:"check"`
	Patches  types.List                               `tfsdk:"patches"`
	Severity *hipObjectDsModel_suxdMuj_SeverityObject `tfsdk:"severity"`
}

type hipObjectDsModel_suxdMuj_SeverityObject struct {
	GreaterEqual types.Int64 `tfsdk:"greater_equal"`
	GreaterThan  types.Int64 `tfsdk:"greater_than"`
	Is           types.Int64 `tfsdk:"is"`
	IsNot        types.Int64 `tfsdk:"is_not"`
	LessEqual    types.Int64 `tfsdk:"less_equal"`
	LessThan     types.Int64 `tfsdk:"less_than"`
}

type hipObjectDsModel_suxdMuj_PatchManagementVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

// Metadata returns the data source type name.
func (d *hipObjectDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_hip_object"
}

// Schema defines the schema for this data source.
func (d *hipObjectDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = dsschema.Schema{
		Description: "Retrieves a config item.",

		Attributes: map[string]dsschema.Attribute{
			// inputs:map[string]bool{"id":true} outputs:map[string]bool{"anti_malware":true, "certificate":true, "custom_checks":true, "data_loss_prevention":true, "description":true, "disk_backup":true, "disk_encryption":true, "firewall":true, "host_info":true, "id":true, "mobile_device":true, "name":true, "network_info":true, "patch_management":true, "tfid":true} forceNew:map[string]bool{"id":true}
			"anti_malware": dsschema.SingleNestedAttribute{
				Description: "The AntiMalware param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
					"criteria": dsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"is_installed":true, "last_scan_time":true, "product_version":true, "real_time_protection":true, "virdef_version":true} forceNew:map[string]bool(nil)
							"is_installed": dsschema.BoolAttribute{
								Description: "Is Installed. Default: `true`.",
								Computed:    true,
							},
							"last_scan_time": dsschema.SingleNestedAttribute{
								Description: "The LastScanTime param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"not_available":true, "not_within":true, "within":true} forceNew:map[string]bool(nil)
									"not_available": dsschema.BoolAttribute{
										Description: "The NotAvailable param.",
										Computed:    true,
									},
									"not_within": dsschema.SingleNestedAttribute{
										Description: "The NotWithin param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"days":true, "hours":true} forceNew:map[string]bool(nil)
											"days": dsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 65535.",
												Computed:    true,
											},
											"hours": dsschema.Int64Attribute{
												Description: "specify time in hours. Value must be between 1 and 65535.",
												Computed:    true,
											},
										},
									},
									"within": dsschema.SingleNestedAttribute{
										Description: "The Within param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"days":true, "hours":true} forceNew:map[string]bool(nil)
											"days": dsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 65535.",
												Computed:    true,
											},
											"hours": dsschema.Int64Attribute{
												Description: "specify time in hours. Value must be between 1 and 65535.",
												Computed:    true,
											},
										},
									},
								},
							},
							"product_version": dsschema.SingleNestedAttribute{
								Description: "The ProductVersion param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "greater_equal":true, "greater_than":true, "is":true, "is_not":true, "less_equal":true, "less_than":true, "not_within":true, "within":true} forceNew:map[string]bool(nil)
									"contains": dsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"greater_equal": dsschema.StringAttribute{
										Description: "The GreaterEqual param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"greater_than": dsschema.StringAttribute{
										Description: "The GreaterThan param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is": dsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is_not": dsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"less_equal": dsschema.StringAttribute{
										Description: "The LessEqual param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"less_than": dsschema.StringAttribute{
										Description: "The LessThan param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"not_within": dsschema.SingleNestedAttribute{
										Description: "The NotWithin param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"versions":true} forceNew:map[string]bool(nil)
											"versions": dsschema.Int64Attribute{
												Description: "versions range. Value must be between 1 and 65535. Default: `1`.",
												Computed:    true,
											},
										},
									},
									"within": dsschema.SingleNestedAttribute{
										Description: "The Within param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"versions":true} forceNew:map[string]bool(nil)
											"versions": dsschema.Int64Attribute{
												Description: "versions range. Value must be between 1 and 65535. Default: `1`.",
												Computed:    true,
											},
										},
									},
								},
							},
							"real_time_protection": dsschema.StringAttribute{
								Description: "real time protection. String must be one of these: `\"no\"`, `\"yes\"`, `\"not-available\"`.",
								Computed:    true,
							},
							"virdef_version": dsschema.SingleNestedAttribute{
								Description: "The VirdefVersion param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"not_within":true, "within":true} forceNew:map[string]bool(nil)
									"not_within": dsschema.SingleNestedAttribute{
										Description: "The NotWithin param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"days":true, "versions":true} forceNew:map[string]bool(nil)
											"days": dsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 65535.",
												Computed:    true,
											},
											"versions": dsschema.Int64Attribute{
												Description: "specify versions range. Value must be between 1 and 65535.",
												Computed:    true,
											},
										},
									},
									"within": dsschema.SingleNestedAttribute{
										Description: "The Within param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"days":true, "versions":true} forceNew:map[string]bool(nil)
											"days": dsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 65535.",
												Computed:    true,
											},
											"versions": dsschema.Int64Attribute{
												Description: "specify versions range. Value must be between 1 and 65535.",
												Computed:    true,
											},
										},
									},
								},
							},
						},
					},
					"exclude_vendor": dsschema.BoolAttribute{
						Description: "The ExcludeVendor param. Default: `false`.",
						Computed:    true,
					},
					"vendors": dsschema.ListNestedAttribute{
						Description: "Vendor name.",
						Computed:    true,
						NestedObject: dsschema.NestedAttributeObject{
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
								"name": dsschema.StringAttribute{
									Description: "The Name param. String length must not exceed 103 characters.",
									Computed:    true,
								},
								"products": dsschema.ListAttribute{
									Description: "The Products param. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
									Computed:    true,
									ElementType: types.StringType,
								},
							},
						},
					},
				},
			},
			"certificate": dsschema.SingleNestedAttribute{
				Description: "The Certificate param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true} forceNew:map[string]bool(nil)
					"criteria": dsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"certificate_attributes":true, "certificate_profile":true} forceNew:map[string]bool(nil)
							"certificate_attributes": dsschema.ListNestedAttribute{
								Description: "The CertificateAttributes param.",
								Computed:    true,
								NestedObject: dsschema.NestedAttributeObject{
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "value":true} forceNew:map[string]bool(nil)
										"name": dsschema.StringAttribute{
											Description: "Attribute Name.",
											Computed:    true,
										},
										"value": dsschema.StringAttribute{
											Description: "Key value. String length must not exceed 1024 characters. String validation regex: `.*`.",
											Computed:    true,
										},
									},
								},
							},
							"certificate_profile": dsschema.StringAttribute{
								Description: "Profile for authenticating client certificates.",
								Computed:    true,
							},
						},
					},
				},
			},
			"custom_checks": dsschema.SingleNestedAttribute{
				Description: "The CustomChecks param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true} forceNew:map[string]bool(nil)
					"criteria": dsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"plist":true, "process_list":true, "registry_key":true} forceNew:map[string]bool(nil)
							"plist": dsschema.ListNestedAttribute{
								Description: "The Plist param.",
								Computed:    true,
								NestedObject: dsschema.NestedAttributeObject{
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"key":true, "name":true, "negate":true} forceNew:map[string]bool(nil)
										"keys": dsschema.ListNestedAttribute{
											Description: "The Keys param.",
											Computed:    true,
											NestedObject: dsschema.NestedAttributeObject{
												Attributes: map[string]dsschema.Attribute{
													// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "negate":true, "value":true} forceNew:map[string]bool(nil)
													"name": dsschema.StringAttribute{
														Description: "Key name. String length must not exceed 1023 characters.",
														Computed:    true,
													},
													"negate": dsschema.BoolAttribute{
														Description: "Value does not exist or match specified value data. Default: `false`.",
														Computed:    true,
													},
													"value": dsschema.StringAttribute{
														Description: "Key value. String length must not exceed 1024 characters. String validation regex: `.*`.",
														Computed:    true,
													},
												},
											},
										},
										"name": dsschema.StringAttribute{
											Description: "Preference list. String length must not exceed 1023 characters.",
											Computed:    true,
										},
										"negate": dsschema.BoolAttribute{
											Description: "Plist does not exist. Default: `false`.",
											Computed:    true,
										},
									},
								},
							},
							"process_list": dsschema.ListNestedAttribute{
								Description: "The ProcessList param.",
								Computed:    true,
								NestedObject: dsschema.NestedAttributeObject{
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "running":true} forceNew:map[string]bool(nil)
										"name": dsschema.StringAttribute{
											Description: "Process Name. String length must not exceed 1023 characters.",
											Computed:    true,
										},
										"running": dsschema.BoolAttribute{
											Description: "The Running param. Default: `true`.",
											Computed:    true,
										},
									},
								},
							},
							"registry_keys": dsschema.ListNestedAttribute{
								Description: "The RegistryKeys param.",
								Computed:    true,
								NestedObject: dsschema.NestedAttributeObject{
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"default_value_data":true, "name":true, "negate":true, "registry_value":true} forceNew:map[string]bool(nil)
										"default_value_data": dsschema.StringAttribute{
											Description: "Registry key default value data. String length must not exceed 1024 characters. String validation regex: `.*`.",
											Computed:    true,
										},
										"name": dsschema.StringAttribute{
											Description: "Registry key. String length must not exceed 1023 characters.",
											Computed:    true,
										},
										"negate": dsschema.BoolAttribute{
											Description: "Key does not exist or match specified value data. Default: `false`.",
											Computed:    true,
										},
										"registry_values": dsschema.ListNestedAttribute{
											Description: "The RegistryValues param.",
											Computed:    true,
											NestedObject: dsschema.NestedAttributeObject{
												Attributes: map[string]dsschema.Attribute{
													// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "negate":true, "value_data":true} forceNew:map[string]bool(nil)
													"name": dsschema.StringAttribute{
														Description: "Registry value name. String length must not exceed 1023 characters.",
														Computed:    true,
													},
													"negate": dsschema.BoolAttribute{
														Description: "Value does not exist or match specified value data. Default: `false`.",
														Computed:    true,
													},
													"value_data": dsschema.StringAttribute{
														Description: "Registry value data. String length must not exceed 1024 characters. String validation regex: `.*`.",
														Computed:    true,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"data_loss_prevention": dsschema.SingleNestedAttribute{
				Description: "The DataLossPrevention param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
					"criteria": dsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"is_enabled":true, "is_installed":true} forceNew:map[string]bool(nil)
							"is_enabled": dsschema.StringAttribute{
								Description: "is enabled. String must be one of these: `\"no\"`, `\"yes\"`, `\"not-available\"`.",
								Computed:    true,
							},
							"is_installed": dsschema.BoolAttribute{
								Description: "Is Installed. Default: `true`.",
								Computed:    true,
							},
						},
					},
					"exclude_vendor": dsschema.BoolAttribute{
						Description: "The ExcludeVendor param. Default: `false`.",
						Computed:    true,
					},
					"vendors": dsschema.ListNestedAttribute{
						Description: "Vendor name.",
						Computed:    true,
						NestedObject: dsschema.NestedAttributeObject{
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
								"name": dsschema.StringAttribute{
									Description: "The Name param. String length must not exceed 103 characters.",
									Computed:    true,
								},
								"products": dsschema.ListAttribute{
									Description: "Product name. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
									Computed:    true,
									ElementType: types.StringType,
								},
							},
						},
					},
				},
			},
			"description": dsschema.StringAttribute{
				Description: "The Description param. String length must not exceed 255 characters.",
				Computed:    true,
			},
			"disk_backup": dsschema.SingleNestedAttribute{
				Description: "The DiskBackup param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
					"criteria": dsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"is_installed":true, "last_backup_time":true} forceNew:map[string]bool(nil)
							"is_installed": dsschema.BoolAttribute{
								Description: "Is Installed. Default: `true`.",
								Computed:    true,
							},
							"last_backup_time": dsschema.SingleNestedAttribute{
								Description: "The LastBackupTime param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"not_available":true, "not_within":true, "within":true} forceNew:map[string]bool(nil)
									"not_available": dsschema.BoolAttribute{
										Description: "The NotAvailable param.",
										Computed:    true,
									},
									"not_within": dsschema.SingleNestedAttribute{
										Description: "The NotWithin param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"days":true, "hours":true} forceNew:map[string]bool(nil)
											"days": dsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 65535.",
												Computed:    true,
											},
											"hours": dsschema.Int64Attribute{
												Description: "specify time in hours. Value must be between 1 and 65535.",
												Computed:    true,
											},
										},
									},
									"within": dsschema.SingleNestedAttribute{
										Description: "The Within param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"days":true, "hours":true} forceNew:map[string]bool(nil)
											"days": dsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 65535.",
												Computed:    true,
											},
											"hours": dsschema.Int64Attribute{
												Description: "specify time in hours. Value must be between 1 and 65535.",
												Computed:    true,
											},
										},
									},
								},
							},
						},
					},
					"exclude_vendor": dsschema.BoolAttribute{
						Description: "The ExcludeVendor param. Default: `false`.",
						Computed:    true,
					},
					"vendors": dsschema.ListNestedAttribute{
						Description: "Vendor name.",
						Computed:    true,
						NestedObject: dsschema.NestedAttributeObject{
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
								"name": dsschema.StringAttribute{
									Description: "The Name param. String length must not exceed 103 characters.",
									Computed:    true,
								},
								"products": dsschema.ListAttribute{
									Description: "The Products param. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
									Computed:    true,
									ElementType: types.StringType,
								},
							},
						},
					},
				},
			},
			"disk_encryption": dsschema.SingleNestedAttribute{
				Description: "The DiskEncryption param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
					"criteria": dsschema.SingleNestedAttribute{
						Description: "Encryption locations.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"encrypted_locations":true, "is_installed":true} forceNew:map[string]bool(nil)
							"encrypted_locations": dsschema.ListNestedAttribute{
								Description: "The EncryptedLocations param.",
								Computed:    true,
								NestedObject: dsschema.NestedAttributeObject{
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"encryption_state":true, "name":true} forceNew:map[string]bool(nil)
										"encryption_state": dsschema.SingleNestedAttribute{
											Description: "The EncryptionState param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"is":true, "is_not":true} forceNew:map[string]bool(nil)
												"is": dsschema.StringAttribute{
													Description: "The Is param. String must be one of these: `\"encrypted\"`, `\"unencrypted\"`, `\"partial\"`, `\"unknown\"`.",
													Computed:    true,
												},
												"is_not": dsschema.StringAttribute{
													Description: "The IsNot param. String must be one of these: `\"encrypted\"`, `\"unencrypted\"`, `\"partial\"`, `\"unknown\"`.",
													Computed:    true,
												},
											},
										},
										"name": dsschema.StringAttribute{
											Description: "Encryption location. String length must not exceed 1023 characters.",
											Computed:    true,
										},
									},
								},
							},
							"is_installed": dsschema.BoolAttribute{
								Description: "Is Installed. Default: `true`.",
								Computed:    true,
							},
						},
					},
					"exclude_vendor": dsschema.BoolAttribute{
						Description: "The ExcludeVendor param. Default: `false`.",
						Computed:    true,
					},
					"vendors": dsschema.ListNestedAttribute{
						Description: "Vendor name.",
						Computed:    true,
						NestedObject: dsschema.NestedAttributeObject{
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
								"name": dsschema.StringAttribute{
									Description: "The Name param. String length must not exceed 103 characters.",
									Computed:    true,
								},
								"products": dsschema.ListAttribute{
									Description: "The Products param. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
									Computed:    true,
									ElementType: types.StringType,
								},
							},
						},
					},
				},
			},
			"firewall": dsschema.SingleNestedAttribute{
				Description: "The Firewall param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
					"criteria": dsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"is_enabled":true, "is_installed":true} forceNew:map[string]bool(nil)
							"is_enabled": dsschema.StringAttribute{
								Description: "is enabled. String must be one of these: `\"no\"`, `\"yes\"`, `\"not-available\"`.",
								Computed:    true,
							},
							"is_installed": dsschema.BoolAttribute{
								Description: "Is Installed. Default: `true`.",
								Computed:    true,
							},
						},
					},
					"exclude_vendor": dsschema.BoolAttribute{
						Description: "The ExcludeVendor param. Default: `false`.",
						Computed:    true,
					},
					"vendors": dsschema.ListNestedAttribute{
						Description: "Vendor name.",
						Computed:    true,
						NestedObject: dsschema.NestedAttributeObject{
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
								"name": dsschema.StringAttribute{
									Description: "The Name param. String length must not exceed 103 characters.",
									Computed:    true,
								},
								"products": dsschema.ListAttribute{
									Description: "The Products param. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
									Computed:    true,
									ElementType: types.StringType,
								},
							},
						},
					},
				},
			},
			"host_info": dsschema.SingleNestedAttribute{
				Description: "The HostInfo param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true} forceNew:map[string]bool(nil)
					"criteria": dsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"client_version":true, "domain":true, "host_id":true, "host_name":true, "managed":true, "os":true, "serial_number":true} forceNew:map[string]bool(nil)
							"client_version": dsschema.SingleNestedAttribute{
								Description: "The ClientVersion param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": dsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is": dsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is_not": dsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters.",
										Computed:    true,
									},
								},
							},
							"domain": dsschema.SingleNestedAttribute{
								Description: "The Domain param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": dsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is": dsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is_not": dsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters.",
										Computed:    true,
									},
								},
							},
							"host_id": dsschema.SingleNestedAttribute{
								Description: "The HostId param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": dsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is": dsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is_not": dsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters.",
										Computed:    true,
									},
								},
							},
							"host_name": dsschema.SingleNestedAttribute{
								Description: "The HostName param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": dsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is": dsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is_not": dsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters.",
										Computed:    true,
									},
								},
							},
							"managed": dsschema.BoolAttribute{
								Description: "If device is managed.",
								Computed:    true,
							},
							"os": dsschema.SingleNestedAttribute{
								Description: "The Os param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"contains":true} forceNew:map[string]bool(nil)
									"contains": dsschema.SingleNestedAttribute{
										Description: "The Contains param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"Apple":true, "Google":true, "Linux":true, "Microsoft":true, "Other":true} forceNew:map[string]bool(nil)
											"apple": dsschema.StringAttribute{
												Description: "Apple vendor. String length must not exceed 255 characters.",
												Computed:    true,
											},
											"google": dsschema.StringAttribute{
												Description: "Google vendor. String length must not exceed 255 characters.",
												Computed:    true,
											},
											"linux": dsschema.StringAttribute{
												Description: "Linux vendor. String length must not exceed 255 characters.",
												Computed:    true,
											},
											"microsoft": dsschema.StringAttribute{
												Description: "Microsoft vendor. String length must not exceed 255 characters.",
												Computed:    true,
											},
											"other": dsschema.StringAttribute{
												Description: "Other vendor. String length must not exceed 255 characters.",
												Computed:    true,
											},
										},
									},
								},
							},
							"serial_number": dsschema.SingleNestedAttribute{
								Description: "The SerialNumber param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": dsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is": dsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is_not": dsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters.",
										Computed:    true,
									},
								},
							},
						},
					},
				},
			},
			"id": dsschema.StringAttribute{
				Description: "The Id param.",
				Required:    true,
			},
			"mobile_device": dsschema.SingleNestedAttribute{
				Description: "The MobileDevice param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true} forceNew:map[string]bool(nil)
					"criteria": dsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"applications":true, "disk_encrypted":true, "imei":true, "jailbroken":true, "last_checkin_time":true, "model":true, "passcode_set":true, "phone_number":true, "tag":true} forceNew:map[string]bool(nil)
							"applications": dsschema.SingleNestedAttribute{
								Description: "The Applications param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"has_malware":true, "has_unmanaged_app":true, "includes":true} forceNew:map[string]bool(nil)
									"has_malware": dsschema.SingleNestedAttribute{
										Description: "The HasMalware param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"no":true, "yes":true} forceNew:map[string]bool(nil)
											"no": dsschema.BoolAttribute{
												Description: "The No param.",
												Computed:    true,
											},
											"yes": dsschema.SingleNestedAttribute{
												Description: "The Yes param.",
												Computed:    true,
												Attributes: map[string]dsschema.Attribute{
													// inputs:map[string]bool{} outputs:map[string]bool{"excludes":true} forceNew:map[string]bool(nil)
													"excludes": dsschema.ListNestedAttribute{
														Description: "The Excludes param.",
														Computed:    true,
														NestedObject: dsschema.NestedAttributeObject{
															Attributes: map[string]dsschema.Attribute{
																// inputs:map[string]bool{} outputs:map[string]bool{"hash":true, "name":true, "package":true} forceNew:map[string]bool(nil)
																"hash": dsschema.StringAttribute{
																	Description: "application hash. String length must not exceed 1024 characters. String validation regex: `.*`.",
																	Computed:    true,
																},
																"name": dsschema.StringAttribute{
																	Description: "The Name param. String length must not exceed 31 characters.",
																	Computed:    true,
																},
																"package": dsschema.StringAttribute{
																	Description: "application package name. String length must not exceed 1024 characters. String validation regex: `.*`.",
																	Computed:    true,
																},
															},
														},
													},
												},
											},
										},
									},
									"has_unmanaged_app": dsschema.BoolAttribute{
										Description: "Has apps that are not managed.",
										Computed:    true,
									},
									"includes": dsschema.ListNestedAttribute{
										Description: "The Includes param.",
										Computed:    true,
										NestedObject: dsschema.NestedAttributeObject{
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"hash":true, "name":true, "package":true} forceNew:map[string]bool(nil)
												"hash": dsschema.StringAttribute{
													Description: "application hash. String length must not exceed 1024 characters. String validation regex: `.*`.",
													Computed:    true,
												},
												"name": dsschema.StringAttribute{
													Description: "The Name param. String length must not exceed 31 characters.",
													Computed:    true,
												},
												"package": dsschema.StringAttribute{
													Description: "application package name. String length must not exceed 1024 characters. String validation regex: `.*`.",
													Computed:    true,
												},
											},
										},
									},
								},
							},
							"disk_encrypted": dsschema.BoolAttribute{
								Description: "If device's disk is encrypted.",
								Computed:    true,
							},
							"imei": dsschema.SingleNestedAttribute{
								Description: "The Imei param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": dsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is": dsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is_not": dsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters.",
										Computed:    true,
									},
								},
							},
							"jailbroken": dsschema.BoolAttribute{
								Description: "If device is by rooted/jailbroken.",
								Computed:    true,
							},
							"last_checkin_time": dsschema.SingleNestedAttribute{
								Description: "The LastCheckinTime param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"not_within":true, "within":true} forceNew:map[string]bool(nil)
									"not_within": dsschema.SingleNestedAttribute{
										Description: "The NotWithin param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"days":true} forceNew:map[string]bool(nil)
											"days": dsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 365. Default: `30`.",
												Computed:    true,
											},
										},
									},
									"within": dsschema.SingleNestedAttribute{
										Description: "The Within param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"days":true} forceNew:map[string]bool(nil)
											"days": dsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 365. Default: `30`.",
												Computed:    true,
											},
										},
									},
								},
							},
							"model": dsschema.SingleNestedAttribute{
								Description: "The Model param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": dsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is": dsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is_not": dsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters.",
										Computed:    true,
									},
								},
							},
							"passcode_set": dsschema.BoolAttribute{
								Description: "If device's passcode is present.",
								Computed:    true,
							},
							"phone_number": dsschema.SingleNestedAttribute{
								Description: "The PhoneNumber param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": dsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is": dsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is_not": dsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters.",
										Computed:    true,
									},
								},
							},
							"tag": dsschema.SingleNestedAttribute{
								Description: "The Tag param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": dsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is": dsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters.",
										Computed:    true,
									},
									"is_not": dsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters.",
										Computed:    true,
									},
								},
							},
						},
					},
				},
			},
			"name": dsschema.StringAttribute{
				Description: "Alphanumeric string [ 0-9a-zA-Z._-]. String length must not exceed 31 characters.",
				Computed:    true,
			},
			"network_info": dsschema.SingleNestedAttribute{
				Description: "The NetworkInfo param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true} forceNew:map[string]bool(nil)
					"criteria": dsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"network":true} forceNew:map[string]bool(nil)
							"network": dsschema.SingleNestedAttribute{
								Description: "The Network param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"is":true, "is_not":true} forceNew:map[string]bool(nil)
									"is": dsschema.SingleNestedAttribute{
										Description: "The Is param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"mobile":true, "unknown":true, "wifi":true} forceNew:map[string]bool(nil)
											"mobile": dsschema.SingleNestedAttribute{
												Description: "The Mobile param.",
												Computed:    true,
												Attributes: map[string]dsschema.Attribute{
													// inputs:map[string]bool{} outputs:map[string]bool{"carrier":true} forceNew:map[string]bool(nil)
													"carrier": dsschema.StringAttribute{
														Description: "The Carrier param. String length must not exceed 1023 characters. String validation regex: `.*`.",
														Computed:    true,
													},
												},
											},
											"unknown": dsschema.BoolAttribute{
												Description: "The Unknown param.",
												Computed:    true,
											},
											"wifi": dsschema.SingleNestedAttribute{
												Description: "The Wifi param.",
												Computed:    true,
												Attributes: map[string]dsschema.Attribute{
													// inputs:map[string]bool{} outputs:map[string]bool{"ssid":true} forceNew:map[string]bool(nil)
													"ssid": dsschema.StringAttribute{
														Description: "SSID. String length must not exceed 1023 characters. String validation regex: `.*`.",
														Computed:    true,
													},
												},
											},
										},
									},
									"is_not": dsschema.SingleNestedAttribute{
										Description: "The IsNot param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"ethernet":true, "mobile":true, "unknown":true, "wifi":true} forceNew:map[string]bool(nil)
											"ethernet": dsschema.BoolAttribute{
												Description: "The Ethernet param.",
												Computed:    true,
											},
											"mobile": dsschema.SingleNestedAttribute{
												Description: "The Mobile param.",
												Computed:    true,
												Attributes: map[string]dsschema.Attribute{
													// inputs:map[string]bool{} outputs:map[string]bool{"carrier":true} forceNew:map[string]bool(nil)
													"carrier": dsschema.StringAttribute{
														Description: "The Carrier param. String length must not exceed 1023 characters. String validation regex: `.*`.",
														Computed:    true,
													},
												},
											},
											"unknown": dsschema.BoolAttribute{
												Description: "The Unknown param.",
												Computed:    true,
											},
											"wifi": dsschema.SingleNestedAttribute{
												Description: "The Wifi param.",
												Computed:    true,
												Attributes: map[string]dsschema.Attribute{
													// inputs:map[string]bool{} outputs:map[string]bool{"ssid":true} forceNew:map[string]bool(nil)
													"ssid": dsschema.StringAttribute{
														Description: "SSID. String length must not exceed 1023 characters. String validation regex: `.*`.",
														Computed:    true,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"patch_management": dsschema.SingleNestedAttribute{
				Description: "The PatchManagement param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
					"criteria": dsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"is_enabled":true, "is_installed":true, "missing_patches":true} forceNew:map[string]bool(nil)
							"is_enabled": dsschema.StringAttribute{
								Description: "is enabled. String must be one of these: `\"no\"`, `\"yes\"`, `\"not-available\"`.",
								Computed:    true,
							},
							"is_installed": dsschema.BoolAttribute{
								Description: "Is Installed. Default: `true`.",
								Computed:    true,
							},
							"missing_patches": dsschema.SingleNestedAttribute{
								Description: "The MissingPatches param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"check":true, "patches":true, "severity":true} forceNew:map[string]bool(nil)
									"check": dsschema.StringAttribute{
										Description: "The Check param. String must be one of these: `\"has-any\"`, `\"has-none\"`, `\"has-all\"`. Default: `\"has-any\"`.",
										Computed:    true,
									},
									"patches": dsschema.ListAttribute{
										Description: "The Patches param. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
										Computed:    true,
										ElementType: types.StringType,
									},
									"severity": dsschema.SingleNestedAttribute{
										Description: "The Severity param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"greater_equal":true, "greater_than":true, "is":true, "is_not":true, "less_equal":true, "less_than":true} forceNew:map[string]bool(nil)
											"greater_equal": dsschema.Int64Attribute{
												Description: "The GreaterEqual param. Value must be between 0 and 100000.",
												Computed:    true,
											},
											"greater_than": dsschema.Int64Attribute{
												Description: "The GreaterThan param. Value must be between 0 and 100000.",
												Computed:    true,
											},
											"is": dsschema.Int64Attribute{
												Description: "The Is param. Value must be between 0 and 100000.",
												Computed:    true,
											},
											"is_not": dsschema.Int64Attribute{
												Description: "The IsNot param. Value must be between 0 and 100000.",
												Computed:    true,
											},
											"less_equal": dsschema.Int64Attribute{
												Description: "The LessEqual param. Value must be between 0 and 100000.",
												Computed:    true,
											},
											"less_than": dsschema.Int64Attribute{
												Description: "The LessThan param. Value must be between 0 and 100000.",
												Computed:    true,
											},
										},
									},
								},
							},
						},
					},
					"exclude_vendor": dsschema.BoolAttribute{
						Description: "The ExcludeVendor param. Default: `false`.",
						Computed:    true,
					},
					"vendors": dsschema.ListNestedAttribute{
						Description: "Vendor name.",
						Computed:    true,
						NestedObject: dsschema.NestedAttributeObject{
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
								"name": dsschema.StringAttribute{
									Description: "The Name param. String length must not exceed 103 characters.",
									Computed:    true,
								},
								"products": dsschema.ListAttribute{
									Description: "Product name. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
									Computed:    true,
									ElementType: types.StringType,
								},
							},
						},
					},
				},
			},
			"tfid": dsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
			},
		},
	}
}

// Configure prepares the struct.
func (d *hipObjectDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*scm.Client)
}

// Read performs Read for the struct.
func (d *hipObjectDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state hipObjectDsModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing data source read", map[string]any{
		"data_source_name":            "scm_hip_object",
		"terraform_provider_function": "Read",
		"id":                          state.Id.ValueString(),
	})

	// Prepare to run the command.
	svc := sdhSKaQ.NewClient(d.client)

	// Prepare input for the API endpoint.
	input := sdhSKaQ.ReadInput{}

	input.Id = state.Id.ValueString()

	// Perform the operation.
	ans, err := svc.Read(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error reading config", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	idBuilder.WriteString(input.Id)

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	if ans.AntiMalware == nil {
		state.AntiMalware = nil
	} else {
		state.AntiMalware = &hipObjectDsModel_suxdMuj_AntiMalwareObject{}

		if ans.AntiMalware.Criteria == nil {
			state.AntiMalware.Criteria = nil
		} else {
			state.AntiMalware.Criteria = &hipObjectDsModel_suxdMuj_AntiMalwareCriteriaObject{}

			state.AntiMalware.Criteria.IsInstalled = types.BoolPointerValue(ans.AntiMalware.Criteria.IsInstalled)

			if ans.AntiMalware.Criteria.LastScanTime == nil {
				state.AntiMalware.Criteria.LastScanTime = nil
			} else {
				state.AntiMalware.Criteria.LastScanTime = &hipObjectDsModel_suxdMuj_LastScanTimeObject{}

				if ans.AntiMalware.Criteria.LastScanTime.NotAvailable != nil {
					state.AntiMalware.Criteria.LastScanTime.NotAvailable = types.BoolValue(true)
				} else {
					state.AntiMalware.Criteria.LastScanTime.NotAvailable = types.BoolPointerValue(nil)
				}
				//state.AntiMalware.Criteria.LastScanTime.NotAvailable = types.BoolValue(ans.AntiMalware.Criteria.LastScanTime.NotAvailable != nil)

				if ans.AntiMalware.Criteria.LastScanTime.NotWithin == nil {
					state.AntiMalware.Criteria.LastScanTime.NotWithin = nil
				} else {
					state.AntiMalware.Criteria.LastScanTime.NotWithin = &hipObjectDsModel_suxdMuj_LastScanTimeNotWithinObject{}

					state.AntiMalware.Criteria.LastScanTime.NotWithin.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.NotWithin.Days)

					state.AntiMalware.Criteria.LastScanTime.NotWithin.Hours = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.NotWithin.Hours)
				}

				if ans.AntiMalware.Criteria.LastScanTime.Within == nil {
					state.AntiMalware.Criteria.LastScanTime.Within = nil
				} else {
					state.AntiMalware.Criteria.LastScanTime.Within = &hipObjectDsModel_suxdMuj_LastScanTimeWithinObject{}

					state.AntiMalware.Criteria.LastScanTime.Within.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.Within.Days)

					state.AntiMalware.Criteria.LastScanTime.Within.Hours = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.Within.Hours)
				}
			}

			if ans.AntiMalware.Criteria.ProductVersion == nil {
				state.AntiMalware.Criteria.ProductVersion = nil
			} else {
				state.AntiMalware.Criteria.ProductVersion = &hipObjectDsModel_suxdMuj_ProductVersionObject{}

				state.AntiMalware.Criteria.ProductVersion.Contains = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.Contains)

				state.AntiMalware.Criteria.ProductVersion.GreaterEqual = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.GreaterEqual)

				state.AntiMalware.Criteria.ProductVersion.GreaterThan = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.GreaterThan)

				state.AntiMalware.Criteria.ProductVersion.Is = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.Is)

				state.AntiMalware.Criteria.ProductVersion.IsNot = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.IsNot)

				state.AntiMalware.Criteria.ProductVersion.LessEqual = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.LessEqual)

				state.AntiMalware.Criteria.ProductVersion.LessThan = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.LessThan)

				if ans.AntiMalware.Criteria.ProductVersion.NotWithin == nil {
					state.AntiMalware.Criteria.ProductVersion.NotWithin = nil
				} else {
					state.AntiMalware.Criteria.ProductVersion.NotWithin = &hipObjectDsModel_suxdMuj_ProductVersionNotWithinObject{}

					state.AntiMalware.Criteria.ProductVersion.NotWithin.Versions = types.Int64Value(ans.AntiMalware.Criteria.ProductVersion.NotWithin.Versions)
				}

				if ans.AntiMalware.Criteria.ProductVersion.Within == nil {
					state.AntiMalware.Criteria.ProductVersion.Within = nil
				} else {
					state.AntiMalware.Criteria.ProductVersion.Within = &hipObjectDsModel_suxdMuj_ProductVersionWithinObject{}

					state.AntiMalware.Criteria.ProductVersion.Within.Versions = types.Int64Value(ans.AntiMalware.Criteria.ProductVersion.Within.Versions)
				}
			}

			state.AntiMalware.Criteria.RealTimeProtection = types.StringPointerValue(ans.AntiMalware.Criteria.RealTimeProtection)

			if ans.AntiMalware.Criteria.VirdefVersion == nil {
				state.AntiMalware.Criteria.VirdefVersion = nil
			} else {
				state.AntiMalware.Criteria.VirdefVersion = &hipObjectDsModel_suxdMuj_VirdefVersionObject{}

				if ans.AntiMalware.Criteria.VirdefVersion.NotWithin == nil {
					state.AntiMalware.Criteria.VirdefVersion.NotWithin = nil
				} else {
					state.AntiMalware.Criteria.VirdefVersion.NotWithin = &hipObjectDsModel_suxdMuj_VirdefVersionNotWithinObject{}

					state.AntiMalware.Criteria.VirdefVersion.NotWithin.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.NotWithin.Days)

					state.AntiMalware.Criteria.VirdefVersion.NotWithin.Versions = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.NotWithin.Versions)
				}

				if ans.AntiMalware.Criteria.VirdefVersion.Within == nil {
					state.AntiMalware.Criteria.VirdefVersion.Within = nil
				} else {
					state.AntiMalware.Criteria.VirdefVersion.Within = &hipObjectDsModel_suxdMuj_VirdefVersionWithinObject{}

					state.AntiMalware.Criteria.VirdefVersion.Within.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.Within.Days)

					state.AntiMalware.Criteria.VirdefVersion.Within.Versions = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.Within.Versions)
				}
			}
		}

		state.AntiMalware.ExcludeVendor = types.BoolPointerValue(ans.AntiMalware.ExcludeVendor)

		if len(ans.AntiMalware.Vendors) == 0 {
			state.AntiMalware.Vendors = nil
		} else {
			state.AntiMalware.Vendors = make([]hipObjectDsModel_suxdMuj_AntiMalwareVendorObject, 0, len(ans.AntiMalware.Vendors))
			for _, var0 := range ans.AntiMalware.Vendors {
				var1 := hipObjectDsModel_suxdMuj_AntiMalwareVendorObject{}

				var1.Name = types.StringValue(var0.Name)

				var2, var3 := types.ListValueFrom(ctx, types.StringType, var0.Products)
				var1.Products = var2
				resp.Diagnostics.Append(var3.Errors()...)
				state.AntiMalware.Vendors = append(state.AntiMalware.Vendors, var1)
			}
		}
	}

	if ans.Certificate == nil {
		state.Certificate = nil
	} else {
		state.Certificate = &hipObjectDsModel_suxdMuj_CertificateObject{}

		if ans.Certificate.Criteria == nil {
			state.Certificate.Criteria = nil
		} else {
			state.Certificate.Criteria = &hipObjectDsModel_suxdMuj_CertificateCriteriaObject{}

			if len(ans.Certificate.Criteria.CertificateAttributes) == 0 {
				state.Certificate.Criteria.CertificateAttributes = nil
			} else {
				state.Certificate.Criteria.CertificateAttributes = make([]hipObjectDsModel_suxdMuj_CertificateAttributeObject, 0, len(ans.Certificate.Criteria.CertificateAttributes))
				for _, var4 := range ans.Certificate.Criteria.CertificateAttributes {
					var5 := hipObjectDsModel_suxdMuj_CertificateAttributeObject{}

					var5.Name = types.StringValue(var4.Name)

					var5.Value = types.StringPointerValue(var4.Value)
					state.Certificate.Criteria.CertificateAttributes = append(state.Certificate.Criteria.CertificateAttributes, var5)
				}
			}

			state.Certificate.Criteria.CertificateProfile = types.StringPointerValue(ans.Certificate.Criteria.CertificateProfile)
		}
	}

	if ans.CustomChecks == nil {
		state.CustomChecks = nil
	} else {
		state.CustomChecks = &hipObjectDsModel_suxdMuj_CustomChecksObject{}

		state.CustomChecks.Criteria = hipObjectDsModel_suxdMuj_CustomChecksCriteriaObject{}

		if len(ans.CustomChecks.Criteria.Plist) == 0 {
			state.CustomChecks.Criteria.Plist = nil
		} else {
			state.CustomChecks.Criteria.Plist = make([]hipObjectDsModel_suxdMuj_PlistObject, 0, len(ans.CustomChecks.Criteria.Plist))
			for _, var6 := range ans.CustomChecks.Criteria.Plist {
				var7 := hipObjectDsModel_suxdMuj_PlistObject{}

				if len(var6.Keys) == 0 {
					var7.Keys = nil
				} else {
					var7.Keys = make([]hipObjectDsModel_suxdMuj_KeyObject, 0, len(var6.Keys))
					for _, var8 := range var6.Keys {
						var9 := hipObjectDsModel_suxdMuj_KeyObject{}

						var9.Name = types.StringValue(var8.Name)

						var9.Negate = types.BoolPointerValue(var8.Negate)

						var9.Value = types.StringPointerValue(var8.Value)
						var7.Keys = append(var7.Keys, var9)
					}
				}

				var7.Name = types.StringValue(var6.Name)

				var7.Negate = types.BoolPointerValue(var6.Negate)
				state.CustomChecks.Criteria.Plist = append(state.CustomChecks.Criteria.Plist, var7)
			}
		}

		if len(ans.CustomChecks.Criteria.ProcessList) == 0 {
			state.CustomChecks.Criteria.ProcessList = nil
		} else {
			state.CustomChecks.Criteria.ProcessList = make([]hipObjectDsModel_suxdMuj_ProcessListObject, 0, len(ans.CustomChecks.Criteria.ProcessList))
			for _, var10 := range ans.CustomChecks.Criteria.ProcessList {
				var11 := hipObjectDsModel_suxdMuj_ProcessListObject{}

				var11.Name = types.StringValue(var10.Name)

				var11.Running = types.BoolPointerValue(var10.Running)
				state.CustomChecks.Criteria.ProcessList = append(state.CustomChecks.Criteria.ProcessList, var11)
			}
		}

		if len(ans.CustomChecks.Criteria.RegistryKeys) == 0 {
			state.CustomChecks.Criteria.RegistryKeys = nil
		} else {
			state.CustomChecks.Criteria.RegistryKeys = make([]hipObjectDsModel_suxdMuj_RegistryKeyObject, 0, len(ans.CustomChecks.Criteria.RegistryKeys))
			for _, var12 := range ans.CustomChecks.Criteria.RegistryKeys {
				var13 := hipObjectDsModel_suxdMuj_RegistryKeyObject{}

				var13.DefaultValueData = types.StringPointerValue(var12.DefaultValueData)

				var13.Name = types.StringValue(var12.Name)

				var13.Negate = types.BoolPointerValue(var12.Negate)

				if len(var12.RegistryValues) == 0 {
					var13.RegistryValues = nil
				} else {
					var13.RegistryValues = make([]hipObjectDsModel_suxdMuj_RegistryValueObject, 0, len(var12.RegistryValues))
					for _, var14 := range var12.RegistryValues {
						var15 := hipObjectDsModel_suxdMuj_RegistryValueObject{}

						var15.Name = types.StringValue(var14.Name)

						var15.Negate = types.BoolPointerValue(var14.Negate)

						var15.ValueData = types.StringPointerValue(var14.ValueData)
						var13.RegistryValues = append(var13.RegistryValues, var15)
					}
				}
				state.CustomChecks.Criteria.RegistryKeys = append(state.CustomChecks.Criteria.RegistryKeys, var13)
			}
		}
	}

	if ans.DataLossPrevention == nil {
		state.DataLossPrevention = nil
	} else {
		state.DataLossPrevention = &hipObjectDsModel_suxdMuj_DataLossPreventionObject{}

		if ans.DataLossPrevention.Criteria == nil {
			state.DataLossPrevention.Criteria = nil
		} else {
			state.DataLossPrevention.Criteria = &hipObjectDsModel_suxdMuj_DataLossPreventionCriteriaObject{}

			state.DataLossPrevention.Criteria.IsEnabled = types.StringPointerValue(ans.DataLossPrevention.Criteria.IsEnabled)

			state.DataLossPrevention.Criteria.IsInstalled = types.BoolPointerValue(ans.DataLossPrevention.Criteria.IsInstalled)
		}

		state.DataLossPrevention.ExcludeVendor = types.BoolPointerValue(ans.DataLossPrevention.ExcludeVendor)

		if len(ans.DataLossPrevention.Vendors) == 0 {
			state.DataLossPrevention.Vendors = nil
		} else {
			state.DataLossPrevention.Vendors = make([]hipObjectDsModel_suxdMuj_DataLossPreventionVendorObject, 0, len(ans.DataLossPrevention.Vendors))
			for _, var16 := range ans.DataLossPrevention.Vendors {
				var17 := hipObjectDsModel_suxdMuj_DataLossPreventionVendorObject{}

				var17.Name = types.StringValue(var16.Name)

				var18, var19 := types.ListValueFrom(ctx, types.StringType, var16.Products)
				var17.Products = var18
				resp.Diagnostics.Append(var19.Errors()...)
				state.DataLossPrevention.Vendors = append(state.DataLossPrevention.Vendors, var17)
			}
		}
	}

	state.Description = types.StringPointerValue(ans.Description)

	if ans.DiskBackup == nil {
		state.DiskBackup = nil
	} else {
		state.DiskBackup = &hipObjectDsModel_suxdMuj_DiskBackupObject{}

		if ans.DiskBackup.Criteria == nil {
			state.DiskBackup.Criteria = nil
		} else {
			state.DiskBackup.Criteria = &hipObjectDsModel_suxdMuj_DiskBackupCriteriaObject{}

			state.DiskBackup.Criteria.IsInstalled = types.BoolPointerValue(ans.DiskBackup.Criteria.IsInstalled)

			if ans.DiskBackup.Criteria.LastBackupTime == nil {
				state.DiskBackup.Criteria.LastBackupTime = nil
			} else {
				state.DiskBackup.Criteria.LastBackupTime = &hipObjectDsModel_suxdMuj_LastBackupTimeObject{}

				if ans.DiskBackup.Criteria.LastBackupTime.NotAvailable != nil {
					state.DiskBackup.Criteria.LastBackupTime.NotAvailable = types.BoolValue(true)
				} else {
					state.DiskBackup.Criteria.LastBackupTime.NotAvailable = types.BoolPointerValue(nil)
				}
				//state.DiskBackup.Criteria.LastBackupTime.NotAvailable = types.BoolValue(ans.DiskBackup.Criteria.LastBackupTime.NotAvailable != nil)

				if ans.DiskBackup.Criteria.LastBackupTime.NotWithin == nil {
					state.DiskBackup.Criteria.LastBackupTime.NotWithin = nil
				} else {
					state.DiskBackup.Criteria.LastBackupTime.NotWithin = &hipObjectDsModel_suxdMuj_LastBackupTimeNotWithinObject{}

					state.DiskBackup.Criteria.LastBackupTime.NotWithin.Days = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.NotWithin.Days)

					state.DiskBackup.Criteria.LastBackupTime.NotWithin.Hours = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.NotWithin.Hours)
				}

				if ans.DiskBackup.Criteria.LastBackupTime.Within == nil {
					state.DiskBackup.Criteria.LastBackupTime.Within = nil
				} else {
					state.DiskBackup.Criteria.LastBackupTime.Within = &hipObjectDsModel_suxdMuj_LastBackupTimeWithinObject{}

					state.DiskBackup.Criteria.LastBackupTime.Within.Days = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.Within.Days)

					state.DiskBackup.Criteria.LastBackupTime.Within.Hours = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.Within.Hours)
				}
			}
		}

		state.DiskBackup.ExcludeVendor = types.BoolPointerValue(ans.DiskBackup.ExcludeVendor)

		if len(ans.DiskBackup.Vendors) == 0 {
			state.DiskBackup.Vendors = nil
		} else {
			state.DiskBackup.Vendors = make([]hipObjectDsModel_suxdMuj_DiskBackupVendorObject, 0, len(ans.DiskBackup.Vendors))
			for _, var20 := range ans.DiskBackup.Vendors {
				var21 := hipObjectDsModel_suxdMuj_DiskBackupVendorObject{}

				var21.Name = types.StringValue(var20.Name)

				var22, var23 := types.ListValueFrom(ctx, types.StringType, var20.Products)
				var21.Products = var22
				resp.Diagnostics.Append(var23.Errors()...)
				state.DiskBackup.Vendors = append(state.DiskBackup.Vendors, var21)
			}
		}
	}

	if ans.DiskEncryption == nil {
		state.DiskEncryption = nil
	} else {
		state.DiskEncryption = &hipObjectDsModel_suxdMuj_DiskEncryptionObject{}

		if ans.DiskEncryption.Criteria == nil {
			state.DiskEncryption.Criteria = nil
		} else {
			state.DiskEncryption.Criteria = &hipObjectDsModel_suxdMuj_DiskEncryptionCriteriaObject{}

			if len(ans.DiskEncryption.Criteria.EncryptedLocations) == 0 {
				state.DiskEncryption.Criteria.EncryptedLocations = nil
			} else {
				state.DiskEncryption.Criteria.EncryptedLocations = make([]hipObjectDsModel_suxdMuj_EncryptedLocationObject, 0, len(ans.DiskEncryption.Criteria.EncryptedLocations))
				for _, var24 := range ans.DiskEncryption.Criteria.EncryptedLocations {
					var25 := hipObjectDsModel_suxdMuj_EncryptedLocationObject{}

					if var24.EncryptionState == nil {
						var25.EncryptionState = nil
					} else {
						var25.EncryptionState = &hipObjectDsModel_suxdMuj_EncryptionStateObject{}

						var25.EncryptionState.Is = types.StringPointerValue(var24.EncryptionState.Is)

						var25.EncryptionState.IsNot = types.StringPointerValue(var24.EncryptionState.IsNot)
					}

					var25.Name = types.StringValue(var24.Name)
					state.DiskEncryption.Criteria.EncryptedLocations = append(state.DiskEncryption.Criteria.EncryptedLocations, var25)
				}
			}

			state.DiskEncryption.Criteria.IsInstalled = types.BoolPointerValue(ans.DiskEncryption.Criteria.IsInstalled)
		}

		state.DiskEncryption.ExcludeVendor = types.BoolPointerValue(ans.DiskEncryption.ExcludeVendor)

		if len(ans.DiskEncryption.Vendors) == 0 {
			state.DiskEncryption.Vendors = nil
		} else {
			state.DiskEncryption.Vendors = make([]hipObjectDsModel_suxdMuj_DiskEncryptionVendorObject, 0, len(ans.DiskEncryption.Vendors))
			for _, var26 := range ans.DiskEncryption.Vendors {
				var27 := hipObjectDsModel_suxdMuj_DiskEncryptionVendorObject{}

				var27.Name = types.StringValue(var26.Name)

				var28, var29 := types.ListValueFrom(ctx, types.StringType, var26.Products)
				var27.Products = var28
				resp.Diagnostics.Append(var29.Errors()...)
				state.DiskEncryption.Vendors = append(state.DiskEncryption.Vendors, var27)
			}
		}
	}

	if ans.Firewall == nil {
		state.Firewall = nil
	} else {
		state.Firewall = &hipObjectDsModel_suxdMuj_FirewallObject{}

		if ans.Firewall.Criteria == nil {
			state.Firewall.Criteria = nil
		} else {
			state.Firewall.Criteria = &hipObjectDsModel_suxdMuj_FirewallCriteriaObject{}

			state.Firewall.Criteria.IsEnabled = types.StringPointerValue(ans.Firewall.Criteria.IsEnabled)

			state.Firewall.Criteria.IsInstalled = types.BoolPointerValue(ans.Firewall.Criteria.IsInstalled)
		}

		state.Firewall.ExcludeVendor = types.BoolPointerValue(ans.Firewall.ExcludeVendor)

		if len(ans.Firewall.Vendors) == 0 {
			state.Firewall.Vendors = nil
		} else {
			state.Firewall.Vendors = make([]hipObjectDsModel_suxdMuj_FirewallVendorObject, 0, len(ans.Firewall.Vendors))
			for _, var30 := range ans.Firewall.Vendors {
				var31 := hipObjectDsModel_suxdMuj_FirewallVendorObject{}

				var31.Name = types.StringValue(var30.Name)

				var32, var33 := types.ListValueFrom(ctx, types.StringType, var30.Products)
				var31.Products = var32
				resp.Diagnostics.Append(var33.Errors()...)
				state.Firewall.Vendors = append(state.Firewall.Vendors, var31)
			}
		}
	}

	if ans.HostInfo == nil {
		state.HostInfo = nil
	} else {
		state.HostInfo = &hipObjectDsModel_suxdMuj_HostInfoObject{}

		state.HostInfo.Criteria = hipObjectDsModel_suxdMuj_HostInfoCriteriaObject{}

		if ans.HostInfo.Criteria.ClientVersion == nil {
			state.HostInfo.Criteria.ClientVersion = nil
		} else {
			state.HostInfo.Criteria.ClientVersion = &hipObjectDsModel_suxdMuj_ClientVersionObject{}

			state.HostInfo.Criteria.ClientVersion.Contains = types.StringPointerValue(ans.HostInfo.Criteria.ClientVersion.Contains)

			state.HostInfo.Criteria.ClientVersion.Is = types.StringPointerValue(ans.HostInfo.Criteria.ClientVersion.Is)

			state.HostInfo.Criteria.ClientVersion.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.ClientVersion.IsNot)
		}

		if ans.HostInfo.Criteria.Domain == nil {
			state.HostInfo.Criteria.Domain = nil
		} else {
			state.HostInfo.Criteria.Domain = &hipObjectDsModel_suxdMuj_DomainObject{}

			state.HostInfo.Criteria.Domain.Contains = types.StringPointerValue(ans.HostInfo.Criteria.Domain.Contains)

			state.HostInfo.Criteria.Domain.Is = types.StringPointerValue(ans.HostInfo.Criteria.Domain.Is)

			state.HostInfo.Criteria.Domain.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.Domain.IsNot)
		}

		if ans.HostInfo.Criteria.HostId == nil {
			state.HostInfo.Criteria.HostId = nil
		} else {
			state.HostInfo.Criteria.HostId = &hipObjectDsModel_suxdMuj_HostIdObject{}

			state.HostInfo.Criteria.HostId.Contains = types.StringPointerValue(ans.HostInfo.Criteria.HostId.Contains)

			state.HostInfo.Criteria.HostId.Is = types.StringPointerValue(ans.HostInfo.Criteria.HostId.Is)

			state.HostInfo.Criteria.HostId.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.HostId.IsNot)
		}

		if ans.HostInfo.Criteria.HostName == nil {
			state.HostInfo.Criteria.HostName = nil
		} else {
			state.HostInfo.Criteria.HostName = &hipObjectDsModel_suxdMuj_HostNameObject{}

			state.HostInfo.Criteria.HostName.Contains = types.StringPointerValue(ans.HostInfo.Criteria.HostName.Contains)

			state.HostInfo.Criteria.HostName.Is = types.StringPointerValue(ans.HostInfo.Criteria.HostName.Is)

			state.HostInfo.Criteria.HostName.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.HostName.IsNot)
		}

		state.HostInfo.Criteria.Managed = types.BoolPointerValue(ans.HostInfo.Criteria.Managed)

		if ans.HostInfo.Criteria.Os == nil {
			state.HostInfo.Criteria.Os = nil
		} else {
			state.HostInfo.Criteria.Os = &hipObjectDsModel_suxdMuj_OsObject{}

			if ans.HostInfo.Criteria.Os.Contains == nil {
				state.HostInfo.Criteria.Os.Contains = nil
			} else {
				state.HostInfo.Criteria.Os.Contains = &hipObjectDsModel_suxdMuj_ContainsObject{}

				state.HostInfo.Criteria.Os.Contains.Apple = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Apple)

				state.HostInfo.Criteria.Os.Contains.Google = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Google)

				state.HostInfo.Criteria.Os.Contains.Linux = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Linux)

				state.HostInfo.Criteria.Os.Contains.Microsoft = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Microsoft)

				state.HostInfo.Criteria.Os.Contains.Other = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Other)
			}
		}

		if ans.HostInfo.Criteria.SerialNumber == nil {
			state.HostInfo.Criteria.SerialNumber = nil
		} else {
			state.HostInfo.Criteria.SerialNumber = &hipObjectDsModel_suxdMuj_SerialNumberObject{}

			state.HostInfo.Criteria.SerialNumber.Contains = types.StringPointerValue(ans.HostInfo.Criteria.SerialNumber.Contains)

			state.HostInfo.Criteria.SerialNumber.Is = types.StringPointerValue(ans.HostInfo.Criteria.SerialNumber.Is)

			state.HostInfo.Criteria.SerialNumber.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.SerialNumber.IsNot)
		}
	}

	state.Id = types.StringPointerValue(ans.Id)

	if ans.MobileDevice == nil {
		state.MobileDevice = nil
	} else {
		state.MobileDevice = &hipObjectDsModel_suxdMuj_MobileDeviceObject{}

		if ans.MobileDevice.Criteria == nil {
			state.MobileDevice.Criteria = nil
		} else {
			state.MobileDevice.Criteria = &hipObjectDsModel_suxdMuj_MobileDeviceCriteriaObject{}

			if ans.MobileDevice.Criteria.Applications == nil {
				state.MobileDevice.Criteria.Applications = nil
			} else {
				state.MobileDevice.Criteria.Applications = &hipObjectDsModel_suxdMuj_ApplicationsObject{}

				if ans.MobileDevice.Criteria.Applications.HasMalware == nil {
					state.MobileDevice.Criteria.Applications.HasMalware = nil
				} else {
					state.MobileDevice.Criteria.Applications.HasMalware = &hipObjectDsModel_suxdMuj_HasMalwareObject{}

					if ans.MobileDevice.Criteria.Applications.HasMalware.No != nil {
						state.MobileDevice.Criteria.Applications.HasMalware.No = types.BoolValue(true)
					} else {
						state.MobileDevice.Criteria.Applications.HasMalware.No = types.BoolPointerValue(nil)
					}
					//state.MobileDevice.Criteria.Applications.HasMalware.No = types.BoolValue(ans.MobileDevice.Criteria.Applications.HasMalware.No != nil)

					if ans.MobileDevice.Criteria.Applications.HasMalware.Yes == nil {
						state.MobileDevice.Criteria.Applications.HasMalware.Yes = nil
					} else {
						state.MobileDevice.Criteria.Applications.HasMalware.Yes = &hipObjectDsModel_suxdMuj_YesObject{}

						if len(ans.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes) == 0 {
							state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = nil
						} else {
							state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = make([]hipObjectDsModel_suxdMuj_ExcludeObject, 0, len(ans.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes))
							for _, var34 := range ans.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes {
								var35 := hipObjectDsModel_suxdMuj_ExcludeObject{}

								var35.Hash = types.StringPointerValue(var34.Hash)

								var35.Name = types.StringValue(var34.Name)

								var35.Package = types.StringPointerValue(var34.Package)
								state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = append(state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes, var35)
							}
						}
					}
				}

				state.MobileDevice.Criteria.Applications.HasUnmanagedApp = types.BoolPointerValue(ans.MobileDevice.Criteria.Applications.HasUnmanagedApp)

				if len(ans.MobileDevice.Criteria.Applications.Includes) == 0 {
					state.MobileDevice.Criteria.Applications.Includes = nil
				} else {
					state.MobileDevice.Criteria.Applications.Includes = make([]hipObjectDsModel_suxdMuj_IncludeObject, 0, len(ans.MobileDevice.Criteria.Applications.Includes))
					for _, var36 := range ans.MobileDevice.Criteria.Applications.Includes {
						var37 := hipObjectDsModel_suxdMuj_IncludeObject{}

						var37.Hash = types.StringPointerValue(var36.Hash)

						var37.Name = types.StringValue(var36.Name)

						var37.Package = types.StringPointerValue(var36.Package)
						state.MobileDevice.Criteria.Applications.Includes = append(state.MobileDevice.Criteria.Applications.Includes, var37)
					}
				}
			}

			state.MobileDevice.Criteria.DiskEncrypted = types.BoolPointerValue(ans.MobileDevice.Criteria.DiskEncrypted)

			if ans.MobileDevice.Criteria.Imei == nil {
				state.MobileDevice.Criteria.Imei = nil
			} else {
				state.MobileDevice.Criteria.Imei = &hipObjectDsModel_suxdMuj_ImeiObject{}

				state.MobileDevice.Criteria.Imei.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.Imei.Contains)

				state.MobileDevice.Criteria.Imei.Is = types.StringPointerValue(ans.MobileDevice.Criteria.Imei.Is)

				state.MobileDevice.Criteria.Imei.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.Imei.IsNot)
			}

			state.MobileDevice.Criteria.Jailbroken = types.BoolPointerValue(ans.MobileDevice.Criteria.Jailbroken)

			if ans.MobileDevice.Criteria.LastCheckinTime == nil {
				state.MobileDevice.Criteria.LastCheckinTime = nil
			} else {
				state.MobileDevice.Criteria.LastCheckinTime = &hipObjectDsModel_suxdMuj_LastCheckinTimeObject{}

				if ans.MobileDevice.Criteria.LastCheckinTime.NotWithin == nil {
					state.MobileDevice.Criteria.LastCheckinTime.NotWithin = nil
				} else {
					state.MobileDevice.Criteria.LastCheckinTime.NotWithin = &hipObjectDsModel_suxdMuj_LastCheckinTimeNotWithinObject{}

					state.MobileDevice.Criteria.LastCheckinTime.NotWithin.Days = types.Int64Value(ans.MobileDevice.Criteria.LastCheckinTime.NotWithin.Days)
				}

				if ans.MobileDevice.Criteria.LastCheckinTime.Within == nil {
					state.MobileDevice.Criteria.LastCheckinTime.Within = nil
				} else {
					state.MobileDevice.Criteria.LastCheckinTime.Within = &hipObjectDsModel_suxdMuj_LastCheckinTimeWithinObject{}

					state.MobileDevice.Criteria.LastCheckinTime.Within.Days = types.Int64Value(ans.MobileDevice.Criteria.LastCheckinTime.Within.Days)
				}
			}

			if ans.MobileDevice.Criteria.Model == nil {
				state.MobileDevice.Criteria.Model = nil
			} else {
				state.MobileDevice.Criteria.Model = &hipObjectDsModel_suxdMuj_ModelObject{}

				state.MobileDevice.Criteria.Model.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.Model.Contains)

				state.MobileDevice.Criteria.Model.Is = types.StringPointerValue(ans.MobileDevice.Criteria.Model.Is)

				state.MobileDevice.Criteria.Model.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.Model.IsNot)
			}

			state.MobileDevice.Criteria.PasscodeSet = types.BoolPointerValue(ans.MobileDevice.Criteria.PasscodeSet)

			if ans.MobileDevice.Criteria.PhoneNumber == nil {
				state.MobileDevice.Criteria.PhoneNumber = nil
			} else {
				state.MobileDevice.Criteria.PhoneNumber = &hipObjectDsModel_suxdMuj_PhoneNumberObject{}

				state.MobileDevice.Criteria.PhoneNumber.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.PhoneNumber.Contains)

				state.MobileDevice.Criteria.PhoneNumber.Is = types.StringPointerValue(ans.MobileDevice.Criteria.PhoneNumber.Is)

				state.MobileDevice.Criteria.PhoneNumber.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.PhoneNumber.IsNot)
			}

			if ans.MobileDevice.Criteria.Tag == nil {
				state.MobileDevice.Criteria.Tag = nil
			} else {
				state.MobileDevice.Criteria.Tag = &hipObjectDsModel_suxdMuj_TagObject{}

				state.MobileDevice.Criteria.Tag.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.Tag.Contains)

				state.MobileDevice.Criteria.Tag.Is = types.StringPointerValue(ans.MobileDevice.Criteria.Tag.Is)

				state.MobileDevice.Criteria.Tag.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.Tag.IsNot)
			}
		}
	}

	state.Name = types.StringValue(ans.Name)

	if ans.NetworkInfo == nil {
		state.NetworkInfo = nil
	} else {
		state.NetworkInfo = &hipObjectDsModel_suxdMuj_NetworkInfoObject{}

		if ans.NetworkInfo.Criteria == nil {
			state.NetworkInfo.Criteria = nil
		} else {
			state.NetworkInfo.Criteria = &hipObjectDsModel_suxdMuj_NetworkInfoCriteriaObject{}

			if ans.NetworkInfo.Criteria.Network == nil {
				state.NetworkInfo.Criteria.Network = nil
			} else {
				state.NetworkInfo.Criteria.Network = &hipObjectDsModel_suxdMuj_NetworkObject{}

				if ans.NetworkInfo.Criteria.Network.Is == nil {
					state.NetworkInfo.Criteria.Network.Is = nil
				} else {
					state.NetworkInfo.Criteria.Network.Is = &hipObjectDsModel_suxdMuj_IsObject{}

					if ans.NetworkInfo.Criteria.Network.Is.Mobile == nil {
						state.NetworkInfo.Criteria.Network.Is.Mobile = nil
					} else {
						state.NetworkInfo.Criteria.Network.Is.Mobile = &hipObjectDsModel_suxdMuj_IsMobileObject{}

						state.NetworkInfo.Criteria.Network.Is.Mobile.Carrier = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.Is.Mobile.Carrier)
					}

					if ans.NetworkInfo.Criteria.Network.Is.Unknown != nil {
						state.NetworkInfo.Criteria.Network.Is.Unknown = types.BoolValue(true)
					} else {
						state.NetworkInfo.Criteria.Network.Is.Unknown = types.BoolPointerValue(nil)
					}
					//state.NetworkInfo.Criteria.Network.Is.Unknown = types.BoolValue(ans.NetworkInfo.Criteria.Network.Is.Unknown != nil)

					if ans.NetworkInfo.Criteria.Network.Is.Wifi == nil {
						state.NetworkInfo.Criteria.Network.Is.Wifi = nil
					} else {
						state.NetworkInfo.Criteria.Network.Is.Wifi = &hipObjectDsModel_suxdMuj_IsWifiObject{}

						state.NetworkInfo.Criteria.Network.Is.Wifi.Ssid = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.Is.Wifi.Ssid)
					}
				}

				if ans.NetworkInfo.Criteria.Network.IsNot == nil {
					state.NetworkInfo.Criteria.Network.IsNot = nil
				} else {
					state.NetworkInfo.Criteria.Network.IsNot = &hipObjectDsModel_suxdMuj_IsNotObject{}

					if ans.NetworkInfo.Criteria.Network.IsNot.Ethernet != nil {
						state.NetworkInfo.Criteria.Network.IsNot.Ethernet = types.BoolValue(true)
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Ethernet = types.BoolPointerValue(nil)
					}
					//state.NetworkInfo.Criteria.Network.IsNot.Ethernet = types.BoolValue(ans.NetworkInfo.Criteria.Network.IsNot.Ethernet != nil)

					if ans.NetworkInfo.Criteria.Network.IsNot.Mobile == nil {
						state.NetworkInfo.Criteria.Network.IsNot.Mobile = nil
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Mobile = &hipObjectDsModel_suxdMuj_IsNotMobileObject{}

						state.NetworkInfo.Criteria.Network.IsNot.Mobile.Carrier = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.IsNot.Mobile.Carrier)
					}

					if ans.NetworkInfo.Criteria.Network.IsNot.Unknown != nil {
						state.NetworkInfo.Criteria.Network.IsNot.Unknown = types.BoolValue(true)
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Unknown = types.BoolPointerValue(nil)
					}
					//state.NetworkInfo.Criteria.Network.IsNot.Unknown = types.BoolValue(ans.NetworkInfo.Criteria.Network.IsNot.Unknown != nil)

					if ans.NetworkInfo.Criteria.Network.IsNot.Wifi == nil {
						state.NetworkInfo.Criteria.Network.IsNot.Wifi = nil
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Wifi = &hipObjectDsModel_suxdMuj_IsNotWifiObject{}

						state.NetworkInfo.Criteria.Network.IsNot.Wifi.Ssid = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.IsNot.Wifi.Ssid)
					}
				}
			}
		}
	}

	if ans.PatchManagement == nil {
		state.PatchManagement = nil
	} else {
		state.PatchManagement = &hipObjectDsModel_suxdMuj_PatchManagementObject{}

		if ans.PatchManagement.Criteria == nil {
			state.PatchManagement.Criteria = nil
		} else {
			state.PatchManagement.Criteria = &hipObjectDsModel_suxdMuj_CriteriaObject{}

			state.PatchManagement.Criteria.IsEnabled = types.StringPointerValue(ans.PatchManagement.Criteria.IsEnabled)

			state.PatchManagement.Criteria.IsInstalled = types.BoolPointerValue(ans.PatchManagement.Criteria.IsInstalled)

			if ans.PatchManagement.Criteria.MissingPatches == nil {
				state.PatchManagement.Criteria.MissingPatches = nil
			} else {
				state.PatchManagement.Criteria.MissingPatches = &hipObjectDsModel_suxdMuj_MissingPatchesObject{}

				state.PatchManagement.Criteria.MissingPatches.Check = types.StringValue(ans.PatchManagement.Criteria.MissingPatches.Check)

				var38, var39 := types.ListValueFrom(ctx, types.StringType, ans.PatchManagement.Criteria.MissingPatches.Patches)
				state.PatchManagement.Criteria.MissingPatches.Patches = var38
				resp.Diagnostics.Append(var39.Errors()...)

				if ans.PatchManagement.Criteria.MissingPatches.Severity == nil {
					state.PatchManagement.Criteria.MissingPatches.Severity = nil
				} else {
					state.PatchManagement.Criteria.MissingPatches.Severity = &hipObjectDsModel_suxdMuj_SeverityObject{}

					state.PatchManagement.Criteria.MissingPatches.Severity.GreaterEqual = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.GreaterEqual)

					state.PatchManagement.Criteria.MissingPatches.Severity.GreaterThan = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.GreaterThan)

					state.PatchManagement.Criteria.MissingPatches.Severity.Is = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.Is)

					state.PatchManagement.Criteria.MissingPatches.Severity.IsNot = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.IsNot)

					state.PatchManagement.Criteria.MissingPatches.Severity.LessEqual = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.LessEqual)

					state.PatchManagement.Criteria.MissingPatches.Severity.LessThan = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.LessThan)
				}
			}
		}

		state.PatchManagement.ExcludeVendor = types.BoolPointerValue(ans.PatchManagement.ExcludeVendor)

		if len(ans.PatchManagement.Vendors) == 0 {
			state.PatchManagement.Vendors = nil
		} else {
			state.PatchManagement.Vendors = make([]hipObjectDsModel_suxdMuj_PatchManagementVendorObject, 0, len(ans.PatchManagement.Vendors))
			for _, var40 := range ans.PatchManagement.Vendors {
				var41 := hipObjectDsModel_suxdMuj_PatchManagementVendorObject{}

				var41.Name = types.StringValue(var40.Name)

				var42, var43 := types.ListValueFrom(ctx, types.StringType, var40.Products)
				var41.Products = var42
				resp.Diagnostics.Append(var43.Errors()...)
				state.PatchManagement.Vendors = append(state.PatchManagement.Vendors, var41)
			}
		}
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Resource.
var (
	_ resource.Resource                = &hipObjectResource{}
	_ resource.ResourceWithConfigure   = &hipObjectResource{}
	_ resource.ResourceWithImportState = &hipObjectResource{}
)

func NewHipObjectResource() resource.Resource {
	return &hipObjectResource{}
}

type hipObjectResource struct {
	client *scm.Client
}

// hipObjectRsModel is the model.
type hipObjectRsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	AntiMalware        *hipObjectRsModel_suxdMuj_AntiMalwareObject        `tfsdk:"anti_malware"`
	Certificate        *hipObjectRsModel_suxdMuj_CertificateObject        `tfsdk:"certificate"`
	CustomChecks       *hipObjectRsModel_suxdMuj_CustomChecksObject       `tfsdk:"custom_checks"`
	DataLossPrevention *hipObjectRsModel_suxdMuj_DataLossPreventionObject `tfsdk:"data_loss_prevention"`
	Description        types.String                                       `tfsdk:"description"`
	Device             types.String                                       `tfsdk:"device"`
	DiskBackup         *hipObjectRsModel_suxdMuj_DiskBackupObject         `tfsdk:"disk_backup"`
	DiskEncryption     *hipObjectRsModel_suxdMuj_DiskEncryptionObject     `tfsdk:"disk_encryption"`
	Firewall           *hipObjectRsModel_suxdMuj_FirewallObject           `tfsdk:"firewall"`
	Folder             types.String                                       `tfsdk:"folder"`
	HostInfo           *hipObjectRsModel_suxdMuj_HostInfoObject           `tfsdk:"host_info"`
	Id                 types.String                                       `tfsdk:"id"`
	MobileDevice       *hipObjectRsModel_suxdMuj_MobileDeviceObject       `tfsdk:"mobile_device"`
	Name               types.String                                       `tfsdk:"name"`
	NetworkInfo        *hipObjectRsModel_suxdMuj_NetworkInfoObject        `tfsdk:"network_info"`
	PatchManagement    *hipObjectRsModel_suxdMuj_PatchManagementObject    `tfsdk:"patch_management"`
	Snippet            types.String                                       `tfsdk:"snippet"`

	// Output.
	// omit input: anti_malware
	// omit input: certificate
	// omit input: custom_checks
	// omit input: data_loss_prevention
	// omit input: description
	// omit input: disk_backup
	// omit input: disk_encryption
	// omit input: firewall
	// omit input: host_info
	// omit input: id
	// omit input: mobile_device
	// omit input: name
	// omit input: network_info
	// omit input: patch_management
}

type hipObjectRsModel_suxdMuj_AntiMalwareObject struct {
	Criteria      *hipObjectRsModel_suxdMuj_AntiMalwareCriteriaObject `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                          `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectRsModel_suxdMuj_AntiMalwareVendorObject  `tfsdk:"vendors"`
}

type hipObjectRsModel_suxdMuj_AntiMalwareCriteriaObject struct {
	IsInstalled        types.Bool                                     `tfsdk:"is_installed"`
	LastScanTime       *hipObjectRsModel_suxdMuj_LastScanTimeObject   `tfsdk:"last_scan_time"`
	ProductVersion     *hipObjectRsModel_suxdMuj_ProductVersionObject `tfsdk:"product_version"`
	RealTimeProtection types.String                                   `tfsdk:"real_time_protection"`
	VirdefVersion      *hipObjectRsModel_suxdMuj_VirdefVersionObject  `tfsdk:"virdef_version"`
}

type hipObjectRsModel_suxdMuj_LastScanTimeObject struct {
	NotAvailable types.Bool                                            `tfsdk:"not_available"`
	NotWithin    *hipObjectRsModel_suxdMuj_LastScanTimeNotWithinObject `tfsdk:"not_within"`
	Within       *hipObjectRsModel_suxdMuj_LastScanTimeWithinObject    `tfsdk:"within"`
}

type hipObjectRsModel_suxdMuj_LastScanTimeNotWithinObject struct {
	Days  types.Int64 `tfsdk:"days"`
	Hours types.Int64 `tfsdk:"hours"`
}

type hipObjectRsModel_suxdMuj_LastScanTimeWithinObject struct {
	Days  types.Int64 `tfsdk:"days"`
	Hours types.Int64 `tfsdk:"hours"`
}

type hipObjectRsModel_suxdMuj_ProductVersionObject struct {
	Contains     types.String                                            `tfsdk:"contains"`
	GreaterEqual types.String                                            `tfsdk:"greater_equal"`
	GreaterThan  types.String                                            `tfsdk:"greater_than"`
	Is           types.String                                            `tfsdk:"is"`
	IsNot        types.String                                            `tfsdk:"is_not"`
	LessEqual    types.String                                            `tfsdk:"less_equal"`
	LessThan     types.String                                            `tfsdk:"less_than"`
	NotWithin    *hipObjectRsModel_suxdMuj_ProductVersionNotWithinObject `tfsdk:"not_within"`
	Within       *hipObjectRsModel_suxdMuj_ProductVersionWithinObject    `tfsdk:"within"`
}

type hipObjectRsModel_suxdMuj_ProductVersionNotWithinObject struct {
	Versions types.Int64 `tfsdk:"versions"`
}

type hipObjectRsModel_suxdMuj_ProductVersionWithinObject struct {
	Versions types.Int64 `tfsdk:"versions"`
}

type hipObjectRsModel_suxdMuj_VirdefVersionObject struct {
	NotWithin *hipObjectRsModel_suxdMuj_VirdefVersionNotWithinObject `tfsdk:"not_within"`
	Within    *hipObjectRsModel_suxdMuj_VirdefVersionWithinObject    `tfsdk:"within"`
}

type hipObjectRsModel_suxdMuj_VirdefVersionNotWithinObject struct {
	Days     types.Int64 `tfsdk:"days"`
	Versions types.Int64 `tfsdk:"versions"`
}

type hipObjectRsModel_suxdMuj_VirdefVersionWithinObject struct {
	Days     types.Int64 `tfsdk:"days"`
	Versions types.Int64 `tfsdk:"versions"`
}

type hipObjectRsModel_suxdMuj_AntiMalwareVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

type hipObjectRsModel_suxdMuj_CertificateObject struct {
	Criteria *hipObjectRsModel_suxdMuj_CertificateCriteriaObject `tfsdk:"criteria"`
}

type hipObjectRsModel_suxdMuj_CertificateCriteriaObject struct {
	CertificateAttributes []hipObjectRsModel_suxdMuj_CertificateAttributeObject `tfsdk:"certificate_attributes"`
	CertificateProfile    types.String                                          `tfsdk:"certificate_profile"`
}

type hipObjectRsModel_suxdMuj_CertificateAttributeObject struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}

type hipObjectRsModel_suxdMuj_CustomChecksObject struct {
	Criteria hipObjectRsModel_suxdMuj_CustomChecksCriteriaObject `tfsdk:"criteria"`
}

type hipObjectRsModel_suxdMuj_CustomChecksCriteriaObject struct {
	Plist        []hipObjectRsModel_suxdMuj_PlistObject       `tfsdk:"plist"`
	ProcessList  []hipObjectRsModel_suxdMuj_ProcessListObject `tfsdk:"process_list"`
	RegistryKeys []hipObjectRsModel_suxdMuj_RegistryKeyObject `tfsdk:"registry_keys"`
}

type hipObjectRsModel_suxdMuj_PlistObject struct {
	Keys   []hipObjectRsModel_suxdMuj_KeyObject `tfsdk:"keys"`
	Name   types.String                         `tfsdk:"name"`
	Negate types.Bool                           `tfsdk:"negate"`
}

type hipObjectRsModel_suxdMuj_KeyObject struct {
	Name   types.String `tfsdk:"name"`
	Negate types.Bool   `tfsdk:"negate"`
	Value  types.String `tfsdk:"value"`
}

type hipObjectRsModel_suxdMuj_ProcessListObject struct {
	Name    types.String `tfsdk:"name"`
	Running types.Bool   `tfsdk:"running"`
}

type hipObjectRsModel_suxdMuj_RegistryKeyObject struct {
	DefaultValueData types.String                                   `tfsdk:"default_value_data"`
	Name             types.String                                   `tfsdk:"name"`
	Negate           types.Bool                                     `tfsdk:"negate"`
	RegistryValues   []hipObjectRsModel_suxdMuj_RegistryValueObject `tfsdk:"registry_values"`
}

type hipObjectRsModel_suxdMuj_RegistryValueObject struct {
	Name      types.String `tfsdk:"name"`
	Negate    types.Bool   `tfsdk:"negate"`
	ValueData types.String `tfsdk:"value_data"`
}

type hipObjectRsModel_suxdMuj_DataLossPreventionObject struct {
	Criteria      *hipObjectRsModel_suxdMuj_DataLossPreventionCriteriaObject `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                                 `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectRsModel_suxdMuj_DataLossPreventionVendorObject  `tfsdk:"vendors"`
}

type hipObjectRsModel_suxdMuj_DataLossPreventionCriteriaObject struct {
	IsEnabled   types.String `tfsdk:"is_enabled"`
	IsInstalled types.Bool   `tfsdk:"is_installed"`
}

type hipObjectRsModel_suxdMuj_DataLossPreventionVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

type hipObjectRsModel_suxdMuj_DiskBackupObject struct {
	Criteria      *hipObjectRsModel_suxdMuj_DiskBackupCriteriaObject `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                         `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectRsModel_suxdMuj_DiskBackupVendorObject  `tfsdk:"vendors"`
}

type hipObjectRsModel_suxdMuj_DiskBackupCriteriaObject struct {
	IsInstalled    types.Bool                                     `tfsdk:"is_installed"`
	LastBackupTime *hipObjectRsModel_suxdMuj_LastBackupTimeObject `tfsdk:"last_backup_time"`
}

type hipObjectRsModel_suxdMuj_LastBackupTimeObject struct {
	NotAvailable types.Bool                                              `tfsdk:"not_available"`
	NotWithin    *hipObjectRsModel_suxdMuj_LastBackupTimeNotWithinObject `tfsdk:"not_within"`
	Within       *hipObjectRsModel_suxdMuj_LastBackupTimeWithinObject    `tfsdk:"within"`
}

type hipObjectRsModel_suxdMuj_LastBackupTimeNotWithinObject struct {
	Days  types.Int64 `tfsdk:"days"`
	Hours types.Int64 `tfsdk:"hours"`
}

type hipObjectRsModel_suxdMuj_LastBackupTimeWithinObject struct {
	Days  types.Int64 `tfsdk:"days"`
	Hours types.Int64 `tfsdk:"hours"`
}

type hipObjectRsModel_suxdMuj_DiskBackupVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

type hipObjectRsModel_suxdMuj_DiskEncryptionObject struct {
	Criteria      *hipObjectRsModel_suxdMuj_DiskEncryptionCriteriaObject `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                             `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectRsModel_suxdMuj_DiskEncryptionVendorObject  `tfsdk:"vendors"`
}

type hipObjectRsModel_suxdMuj_DiskEncryptionCriteriaObject struct {
	EncryptedLocations []hipObjectRsModel_suxdMuj_EncryptedLocationObject `tfsdk:"encrypted_locations"`
	IsInstalled        types.Bool                                         `tfsdk:"is_installed"`
}

type hipObjectRsModel_suxdMuj_EncryptedLocationObject struct {
	EncryptionState *hipObjectRsModel_suxdMuj_EncryptionStateObject `tfsdk:"encryption_state"`
	Name            types.String                                    `tfsdk:"name"`
}

type hipObjectRsModel_suxdMuj_EncryptionStateObject struct {
	Is    types.String `tfsdk:"is"`
	IsNot types.String `tfsdk:"is_not"`
}

type hipObjectRsModel_suxdMuj_DiskEncryptionVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

type hipObjectRsModel_suxdMuj_FirewallObject struct {
	Criteria      *hipObjectRsModel_suxdMuj_FirewallCriteriaObject `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                       `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectRsModel_suxdMuj_FirewallVendorObject  `tfsdk:"vendors"`
}

type hipObjectRsModel_suxdMuj_FirewallCriteriaObject struct {
	IsEnabled   types.String `tfsdk:"is_enabled"`
	IsInstalled types.Bool   `tfsdk:"is_installed"`
}

type hipObjectRsModel_suxdMuj_FirewallVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

type hipObjectRsModel_suxdMuj_HostInfoObject struct {
	Criteria hipObjectRsModel_suxdMuj_HostInfoCriteriaObject `tfsdk:"criteria"`
}

type hipObjectRsModel_suxdMuj_HostInfoCriteriaObject struct {
	ClientVersion *hipObjectRsModel_suxdMuj_ClientVersionObject `tfsdk:"client_version"`
	Domain        *hipObjectRsModel_suxdMuj_DomainObject        `tfsdk:"domain"`
	HostId        *hipObjectRsModel_suxdMuj_HostIdObject        `tfsdk:"host_id"`
	HostName      *hipObjectRsModel_suxdMuj_HostNameObject      `tfsdk:"host_name"`
	Managed       types.Bool                                    `tfsdk:"managed"`
	Os            *hipObjectRsModel_suxdMuj_OsObject            `tfsdk:"os"`
	SerialNumber  *hipObjectRsModel_suxdMuj_SerialNumberObject  `tfsdk:"serial_number"`
}

type hipObjectRsModel_suxdMuj_ClientVersionObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectRsModel_suxdMuj_DomainObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectRsModel_suxdMuj_HostIdObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectRsModel_suxdMuj_HostNameObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectRsModel_suxdMuj_OsObject struct {
	Contains *hipObjectRsModel_suxdMuj_ContainsObject `tfsdk:"contains"`
}

type hipObjectRsModel_suxdMuj_ContainsObject struct {
	Apple     types.String `tfsdk:"apple"`
	Google    types.String `tfsdk:"google"`
	Linux     types.String `tfsdk:"linux"`
	Microsoft types.String `tfsdk:"microsoft"`
	Other     types.String `tfsdk:"other"`
}

type hipObjectRsModel_suxdMuj_SerialNumberObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectRsModel_suxdMuj_MobileDeviceObject struct {
	Criteria *hipObjectRsModel_suxdMuj_MobileDeviceCriteriaObject `tfsdk:"criteria"`
}

type hipObjectRsModel_suxdMuj_MobileDeviceCriteriaObject struct {
	Applications    *hipObjectRsModel_suxdMuj_ApplicationsObject    `tfsdk:"applications"`
	DiskEncrypted   types.Bool                                      `tfsdk:"disk_encrypted"`
	Imei            *hipObjectRsModel_suxdMuj_ImeiObject            `tfsdk:"imei"`
	Jailbroken      types.Bool                                      `tfsdk:"jailbroken"`
	LastCheckinTime *hipObjectRsModel_suxdMuj_LastCheckinTimeObject `tfsdk:"last_checkin_time"`
	Model           *hipObjectRsModel_suxdMuj_ModelObject           `tfsdk:"model"`
	PasscodeSet     types.Bool                                      `tfsdk:"passcode_set"`
	PhoneNumber     *hipObjectRsModel_suxdMuj_PhoneNumberObject     `tfsdk:"phone_number"`
	Tag             *hipObjectRsModel_suxdMuj_TagObject             `tfsdk:"tag"`
}

type hipObjectRsModel_suxdMuj_ApplicationsObject struct {
	HasMalware      *hipObjectRsModel_suxdMuj_HasMalwareObject `tfsdk:"has_malware"`
	HasUnmanagedApp types.Bool                                 `tfsdk:"has_unmanaged_app"`
	Includes        []hipObjectRsModel_suxdMuj_IncludeObject   `tfsdk:"includes"`
}

type hipObjectRsModel_suxdMuj_HasMalwareObject struct {
	No  types.Bool                          `tfsdk:"no"`
	Yes *hipObjectRsModel_suxdMuj_YesObject `tfsdk:"yes"`
}

type hipObjectRsModel_suxdMuj_YesObject struct {
	Excludes []hipObjectRsModel_suxdMuj_ExcludeObject `tfsdk:"excludes"`
}

type hipObjectRsModel_suxdMuj_ExcludeObject struct {
	Hash    types.String `tfsdk:"hash"`
	Name    types.String `tfsdk:"name"`
	Package types.String `tfsdk:"package"`
}

type hipObjectRsModel_suxdMuj_IncludeObject struct {
	Hash    types.String `tfsdk:"hash"`
	Name    types.String `tfsdk:"name"`
	Package types.String `tfsdk:"package"`
}

type hipObjectRsModel_suxdMuj_ImeiObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectRsModel_suxdMuj_LastCheckinTimeObject struct {
	NotWithin *hipObjectRsModel_suxdMuj_LastCheckinTimeNotWithinObject `tfsdk:"not_within"`
	Within    *hipObjectRsModel_suxdMuj_LastCheckinTimeWithinObject    `tfsdk:"within"`
}

type hipObjectRsModel_suxdMuj_LastCheckinTimeNotWithinObject struct {
	Days types.Int64 `tfsdk:"days"`
}

type hipObjectRsModel_suxdMuj_LastCheckinTimeWithinObject struct {
	Days types.Int64 `tfsdk:"days"`
}

type hipObjectRsModel_suxdMuj_ModelObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectRsModel_suxdMuj_PhoneNumberObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectRsModel_suxdMuj_TagObject struct {
	Contains types.String `tfsdk:"contains"`
	Is       types.String `tfsdk:"is"`
	IsNot    types.String `tfsdk:"is_not"`
}

type hipObjectRsModel_suxdMuj_NetworkInfoObject struct {
	Criteria *hipObjectRsModel_suxdMuj_NetworkInfoCriteriaObject `tfsdk:"criteria"`
}

type hipObjectRsModel_suxdMuj_NetworkInfoCriteriaObject struct {
	Network *hipObjectRsModel_suxdMuj_NetworkObject `tfsdk:"network"`
}

type hipObjectRsModel_suxdMuj_NetworkObject struct {
	Is    *hipObjectRsModel_suxdMuj_IsObject    `tfsdk:"is"`
	IsNot *hipObjectRsModel_suxdMuj_IsNotObject `tfsdk:"is_not"`
}

type hipObjectRsModel_suxdMuj_IsObject struct {
	Mobile  *hipObjectRsModel_suxdMuj_IsMobileObject `tfsdk:"mobile"`
	Unknown types.Bool                               `tfsdk:"unknown"`
	Wifi    *hipObjectRsModel_suxdMuj_IsWifiObject   `tfsdk:"wifi"`
}

type hipObjectRsModel_suxdMuj_IsMobileObject struct {
	Carrier types.String `tfsdk:"carrier"`
}

type hipObjectRsModel_suxdMuj_IsWifiObject struct {
	Ssid types.String `tfsdk:"ssid"`
}

type hipObjectRsModel_suxdMuj_IsNotObject struct {
	Ethernet types.Bool                                  `tfsdk:"ethernet"`
	Mobile   *hipObjectRsModel_suxdMuj_IsNotMobileObject `tfsdk:"mobile"`
	Unknown  types.Bool                                  `tfsdk:"unknown"`
	Wifi     *hipObjectRsModel_suxdMuj_IsNotWifiObject   `tfsdk:"wifi"`
}

type hipObjectRsModel_suxdMuj_IsNotMobileObject struct {
	Carrier types.String `tfsdk:"carrier"`
}

type hipObjectRsModel_suxdMuj_IsNotWifiObject struct {
	Ssid types.String `tfsdk:"ssid"`
}

type hipObjectRsModel_suxdMuj_PatchManagementObject struct {
	Criteria      *hipObjectRsModel_suxdMuj_CriteriaObject               `tfsdk:"criteria"`
	ExcludeVendor types.Bool                                             `tfsdk:"exclude_vendor"`
	Vendors       []hipObjectRsModel_suxdMuj_PatchManagementVendorObject `tfsdk:"vendors"`
}

type hipObjectRsModel_suxdMuj_CriteriaObject struct {
	IsEnabled      types.String                                   `tfsdk:"is_enabled"`
	IsInstalled    types.Bool                                     `tfsdk:"is_installed"`
	MissingPatches *hipObjectRsModel_suxdMuj_MissingPatchesObject `tfsdk:"missing_patches"`
}

type hipObjectRsModel_suxdMuj_MissingPatchesObject struct {
	Check    types.String                             `tfsdk:"check"`
	Patches  types.List                               `tfsdk:"patches"`
	Severity *hipObjectRsModel_suxdMuj_SeverityObject `tfsdk:"severity"`
}

type hipObjectRsModel_suxdMuj_SeverityObject struct {
	GreaterEqual types.Int64 `tfsdk:"greater_equal"`
	GreaterThan  types.Int64 `tfsdk:"greater_than"`
	Is           types.Int64 `tfsdk:"is"`
	IsNot        types.Int64 `tfsdk:"is_not"`
	LessEqual    types.Int64 `tfsdk:"less_equal"`
	LessThan     types.Int64 `tfsdk:"less_than"`
}

type hipObjectRsModel_suxdMuj_PatchManagementVendorObject struct {
	Name     types.String `tfsdk:"name"`
	Products types.List   `tfsdk:"products"`
}

// Metadata returns the data source type name.
func (r *hipObjectResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_hip_object"
}

// Schema defines the schema for this data source.
func (r *hipObjectResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = rsschema.Schema{
		Description: "Retrieves a config item.",

		Attributes: map[string]rsschema.Attribute{
			// inputs:map[string]bool{"anti_malware":true, "certificate":true, "custom_checks":true, "data_loss_prevention":true, "description":true, "device":true, "disk_backup":true, "disk_encryption":true, "firewall":true, "folder":true, "host_info":true, "id":true, "mobile_device":true, "name":true, "network_info":true, "patch_management":true, "snippet":true} outputs:map[string]bool{"anti_malware":true, "certificate":true, "custom_checks":true, "data_loss_prevention":true, "description":true, "disk_backup":true, "disk_encryption":true, "firewall":true, "host_info":true, "id":true, "mobile_device":true, "name":true, "network_info":true, "patch_management":true, "tfid":true} forceNew:map[string]bool{"device":true, "folder":true, "snippet":true}
			"anti_malware": rsschema.SingleNestedAttribute{
				Description: "The AntiMalware param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
					"criteria": rsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"is_installed":true, "last_scan_time":true, "product_version":true, "real_time_protection":true, "virdef_version":true} outputs:map[string]bool{"is_installed":true, "last_scan_time":true, "product_version":true, "real_time_protection":true, "virdef_version":true} forceNew:map[string]bool(nil)
							"is_installed": rsschema.BoolAttribute{
								Description: "Is Installed. Default: `true`.",
								Optional:    true,
								Computed:    true,
								Default:     booldefault.StaticBool(true),
							},
							"last_scan_time": rsschema.SingleNestedAttribute{
								Description: "The LastScanTime param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"not_available":true, "not_within":true, "within":true} outputs:map[string]bool{"not_available":true, "not_within":true, "within":true} forceNew:map[string]bool(nil)
									"not_available": rsschema.BoolAttribute{
										Description: "The NotAvailable param. Ensure that only one of the following is specified: `not_available`, `not_within`, `within`",
										Optional:    true,
										Validators: []validator.Bool{
											boolvalidator.ExactlyOneOf(
												path.MatchRelative(),
												path.MatchRelative().AtParent().AtName("not_within"),
												path.MatchRelative().AtParent().AtName("within"),
											),
										},
									},
									"not_within": rsschema.SingleNestedAttribute{
										Description: "The NotWithin param. Ensure that only one of the following is specified: `not_available`, `not_within`, `within`",
										Optional:    true,
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"days":true, "hours":true} outputs:map[string]bool{"days":true, "hours":true} forceNew:map[string]bool(nil)
											"days": rsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 65535. Ensure that only one of the following is specified: `days`, `hours`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
													int64validator.ExactlyOneOf(
														path.MatchRelative(),
														path.MatchRelative().AtParent().AtName("hours"),
													),
												},
											},
											"hours": rsschema.Int64Attribute{
												Description: "specify time in hours. Value must be between 1 and 65535. Ensure that only one of the following is specified: `days`, `hours`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
												},
											},
										},
									},
									"within": rsschema.SingleNestedAttribute{
										Description: "The Within param. Ensure that only one of the following is specified: `not_available`, `not_within`, `within`",
										Optional:    true,
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"days":true, "hours":true} outputs:map[string]bool{"days":true, "hours":true} forceNew:map[string]bool(nil)
											"days": rsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 65535. Ensure that only one of the following is specified: `days`, `hours`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
													int64validator.ExactlyOneOf(
														path.MatchRelative(),
														path.MatchRelative().AtParent().AtName("hours"),
													),
												},
											},
											"hours": rsschema.Int64Attribute{
												Description: "specify time in hours. Value must be between 1 and 65535. Ensure that only one of the following is specified: `days`, `hours`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
												},
											},
										},
									},
								},
							},
							"product_version": rsschema.SingleNestedAttribute{
								Description: "The ProductVersion param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"contains":true, "greater_equal":true, "greater_than":true, "is":true, "is_not":true, "less_equal":true, "less_than":true, "not_within":true, "within":true} outputs:map[string]bool{"contains":true, "greater_equal":true, "greater_than":true, "is":true, "is_not":true, "less_equal":true, "less_than":true, "not_within":true, "within":true} forceNew:map[string]bool(nil)
									"contains": rsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, `within`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
											stringvalidator.ExactlyOneOf(
												path.MatchRelative(),
												path.MatchRelative().AtParent().AtName("greater_equal"),
												path.MatchRelative().AtParent().AtName("greater_than"),
												path.MatchRelative().AtParent().AtName("is"),
												path.MatchRelative().AtParent().AtName("is_not"),
												path.MatchRelative().AtParent().AtName("less_equal"),
												path.MatchRelative().AtParent().AtName("less_than"),
												path.MatchRelative().AtParent().AtName("not_within"),
												path.MatchRelative().AtParent().AtName("within"),
											),
										},
									},
									"greater_equal": rsschema.StringAttribute{
										Description: "The GreaterEqual param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, `within`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
									"greater_than": rsschema.StringAttribute{
										Description: "The GreaterThan param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, `within`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
									"is": rsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, `within`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
									"is_not": rsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, `within`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
									"less_equal": rsschema.StringAttribute{
										Description: "The LessEqual param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, `within`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
									"less_than": rsschema.StringAttribute{
										Description: "The LessThan param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, `within`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
									"not_within": rsschema.SingleNestedAttribute{
										Description: "The NotWithin param. Ensure that only one of the following is specified: `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, `within`",
										Optional:    true,
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"versions":true} outputs:map[string]bool{"versions":true} forceNew:map[string]bool(nil)
											"versions": rsschema.Int64Attribute{
												Description: "versions range. Value must be between 1 and 65535. Default: `1`.",
												Optional:    true,
												Computed:    true,
												Default:     int64default.StaticInt64(1),
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
												},
											},
										},
									},
									"within": rsschema.SingleNestedAttribute{
										Description: "The Within param. Ensure that only one of the following is specified: `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, `within`",
										Optional:    true,
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"versions":true} outputs:map[string]bool{"versions":true} forceNew:map[string]bool(nil)
											"versions": rsschema.Int64Attribute{
												Description: "versions range. Value must be between 1 and 65535. Default: `1`.",
												Optional:    true,
												Computed:    true,
												Default:     int64default.StaticInt64(1),
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
												},
											},
										},
									},
								},
							},
							"real_time_protection": rsschema.StringAttribute{
								Description: "real time protection. String must be one of these: `\"no\"`, `\"yes\"`, `\"not-available\"`.",
								Optional:    true,
								Validators: []validator.String{
									stringvalidator.OneOf("no", "yes", "not-available"),
								},
							},
							"virdef_version": rsschema.SingleNestedAttribute{
								Description: "The VirdefVersion param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"not_within":true, "within":true} outputs:map[string]bool{"not_within":true, "within":true} forceNew:map[string]bool(nil)
									"not_within": rsschema.SingleNestedAttribute{
										Description: "The NotWithin param. Ensure that only one of the following is specified: `not_within`, `within`",
										Optional:    true,
										Validators: []validator.Object{
											objectvalidator.ExactlyOneOf(
												path.MatchRelative(),
												path.MatchRelative().AtParent().AtName("within"),
											),
										},
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"days":true, "versions":true} outputs:map[string]bool{"days":true, "versions":true} forceNew:map[string]bool(nil)
											"days": rsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 65535. Ensure that only one of the following is specified: `days`, `versions`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
													int64validator.ExactlyOneOf(
														path.MatchRelative(),
														path.MatchRelative().AtParent().AtName("versions"),
													),
												},
											},
											"versions": rsschema.Int64Attribute{
												Description: "specify versions range. Value must be between 1 and 65535. Ensure that only one of the following is specified: `days`, `versions`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
												},
											},
										},
									},
									"within": rsschema.SingleNestedAttribute{
										Description: "The Within param. Ensure that only one of the following is specified: `not_within`, `within`",
										Optional:    true,
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"days":true, "versions":true} outputs:map[string]bool{"days":true, "versions":true} forceNew:map[string]bool(nil)
											"days": rsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 65535. Ensure that only one of the following is specified: `days`, `versions`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
													int64validator.ExactlyOneOf(
														path.MatchRelative(),
														path.MatchRelative().AtParent().AtName("versions"),
													),
												},
											},
											"versions": rsschema.Int64Attribute{
												Description: "specify versions range. Value must be between 1 and 65535. Ensure that only one of the following is specified: `days`, `versions`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
												},
											},
										},
									},
								},
							},
						},
					},
					"exclude_vendor": rsschema.BoolAttribute{
						Description: "The ExcludeVendor param. Default: `false`.",
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
					},
					"vendors": rsschema.ListNestedAttribute{
						Description: "Vendor name.",
						Optional:    true,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// inputs:map[string]bool{"name":true, "product":true} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
								"name": rsschema.StringAttribute{
									Description: "The Name param. String length must not exceed 103 characters.",
									Required:    true,
									Validators: []validator.String{
										stringvalidator.LengthAtMost(103),
									},
								},
								"products": rsschema.ListAttribute{
									Description: "The Products param. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
									Optional:    true,
									ElementType: types.StringType,
									Validators: []validator.List{
										listvalidator.ValueStringsAre(
											stringvalidator.LengthAtMost(1023),
											stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
										),
									},
								},
							},
						},
					},
				},
			},
			"certificate": rsschema.SingleNestedAttribute{
				Description: "The Certificate param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"criteria":true} outputs:map[string]bool{"criteria":true} forceNew:map[string]bool(nil)
					"criteria": rsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"certificate_attributes":true, "certificate_profile":true} outputs:map[string]bool{"certificate_attributes":true, "certificate_profile":true} forceNew:map[string]bool(nil)
							"certificate_attributes": rsschema.ListNestedAttribute{
								Description: "The CertificateAttributes param.",
								Optional:    true,
								NestedObject: rsschema.NestedAttributeObject{
									Attributes: map[string]rsschema.Attribute{
										// inputs:map[string]bool{"name":true, "value":true} outputs:map[string]bool{"name":true, "value":true} forceNew:map[string]bool(nil)
										"name": rsschema.StringAttribute{
											Description: "Attribute Name.",
											Required:    true,
										},
										"value": rsschema.StringAttribute{
											Description: "Key value. String length must not exceed 1024 characters. String validation regex: `.*`.",
											Optional:    true,
											Validators: []validator.String{
												stringvalidator.LengthAtMost(1024),
												stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
											},
										},
									},
								},
							},
							"certificate_profile": rsschema.StringAttribute{
								Description: "Profile for authenticating client certificates.",
								Optional:    true,
							},
						},
					},
				},
			},
			"custom_checks": rsschema.SingleNestedAttribute{
				Description: "The CustomChecks param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"criteria":true} outputs:map[string]bool{"criteria":true} forceNew:map[string]bool(nil)
					"criteria": rsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Required:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"plist":true, "process_list":true, "registry_key":true} outputs:map[string]bool{"plist":true, "process_list":true, "registry_key":true} forceNew:map[string]bool(nil)
							"plist": rsschema.ListNestedAttribute{
								Description: "The Plist param.",
								Optional:    true,
								NestedObject: rsschema.NestedAttributeObject{
									Attributes: map[string]rsschema.Attribute{
										// inputs:map[string]bool{"key":true, "name":true, "negate":true} outputs:map[string]bool{"key":true, "name":true, "negate":true} forceNew:map[string]bool(nil)
										"keys": rsschema.ListNestedAttribute{
											Description: "The Keys param.",
											Optional:    true,
											NestedObject: rsschema.NestedAttributeObject{
												Attributes: map[string]rsschema.Attribute{
													// inputs:map[string]bool{"name":true, "negate":true, "value":true} outputs:map[string]bool{"name":true, "negate":true, "value":true} forceNew:map[string]bool(nil)
													"name": rsschema.StringAttribute{
														Description: "Key name. String length must not exceed 1023 characters.",
														Required:    true,
														Validators: []validator.String{
															stringvalidator.LengthAtMost(1023),
														},
													},
													"negate": rsschema.BoolAttribute{
														Description: "Value does not exist or match specified value data. Default: `false`.",
														Optional:    true,
														Computed:    true,
														Default:     booldefault.StaticBool(false),
													},
													"value": rsschema.StringAttribute{
														Description: "Key value. String length must not exceed 1024 characters. String validation regex: `.*`.",
														Optional:    true,
														Validators: []validator.String{
															stringvalidator.LengthAtMost(1024),
															stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
														},
													},
												},
											},
										},
										"name": rsschema.StringAttribute{
											Description: "Preference list. String length must not exceed 1023 characters.",
											Required:    true,
											Validators: []validator.String{
												stringvalidator.LengthAtMost(1023),
											},
										},
										"negate": rsschema.BoolAttribute{
											Description: "Plist does not exist. Default: `false`.",
											Optional:    true,
											Computed:    true,
											Default:     booldefault.StaticBool(false),
										},
									},
								},
							},
							"process_list": rsschema.ListNestedAttribute{
								Description: "The ProcessList param.",
								Optional:    true,
								NestedObject: rsschema.NestedAttributeObject{
									Attributes: map[string]rsschema.Attribute{
										// inputs:map[string]bool{"name":true, "running":true} outputs:map[string]bool{"name":true, "running":true} forceNew:map[string]bool(nil)
										"name": rsschema.StringAttribute{
											Description: "Process Name. String length must not exceed 1023 characters.",
											Required:    true,
											Validators: []validator.String{
												stringvalidator.LengthAtMost(1023),
											},
										},
										"running": rsschema.BoolAttribute{
											Description: "The Running param. Default: `true`.",
											Optional:    true,
											Computed:    true,
											Default:     booldefault.StaticBool(true),
										},
									},
								},
							},
							"registry_keys": rsschema.ListNestedAttribute{
								Description: "The RegistryKeys param.",
								Optional:    true,
								NestedObject: rsschema.NestedAttributeObject{
									Attributes: map[string]rsschema.Attribute{
										// inputs:map[string]bool{"default_value_data":true, "name":true, "negate":true, "registry_value":true} outputs:map[string]bool{"default_value_data":true, "name":true, "negate":true, "registry_value":true} forceNew:map[string]bool(nil)
										"default_value_data": rsschema.StringAttribute{
											Description: "Registry key default value data. String length must not exceed 1024 characters. String validation regex: `.*`.",
											Optional:    true,
											Validators: []validator.String{
												stringvalidator.LengthAtMost(1024),
												stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
											},
										},
										"name": rsschema.StringAttribute{
											Description: "Registry key. String length must not exceed 1023 characters.",
											Required:    true,
											Validators: []validator.String{
												stringvalidator.LengthAtMost(1023),
											},
										},
										"negate": rsschema.BoolAttribute{
											Description: "Key does not exist or match specified value data. Default: `false`.",
											Optional:    true,
											Computed:    true,
											Default:     booldefault.StaticBool(false),
										},
										"registry_values": rsschema.ListNestedAttribute{
											Description: "The RegistryValues param.",
											Optional:    true,
											NestedObject: rsschema.NestedAttributeObject{
												Attributes: map[string]rsschema.Attribute{
													// inputs:map[string]bool{"name":true, "negate":true, "value_data":true} outputs:map[string]bool{"name":true, "negate":true, "value_data":true} forceNew:map[string]bool(nil)
													"name": rsschema.StringAttribute{
														Description: "Registry value name. String length must not exceed 1023 characters.",
														Required:    true,
														Validators: []validator.String{
															stringvalidator.LengthAtMost(1023),
														},
													},
													"negate": rsschema.BoolAttribute{
														Description: "Value does not exist or match specified value data. Default: `false`.",
														Optional:    true,
														Computed:    true,
														Default:     booldefault.StaticBool(false),
													},
													"value_data": rsschema.StringAttribute{
														Description: "Registry value data. String length must not exceed 1024 characters. String validation regex: `.*`.",
														Optional:    true,
														Validators: []validator.String{
															stringvalidator.LengthAtMost(1024),
															stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"data_loss_prevention": rsschema.SingleNestedAttribute{
				Description: "The DataLossPrevention param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
					"criteria": rsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"is_enabled":true, "is_installed":true} outputs:map[string]bool{"is_enabled":true, "is_installed":true} forceNew:map[string]bool(nil)
							"is_enabled": rsschema.StringAttribute{
								Description: "is enabled. String must be one of these: `\"no\"`, `\"yes\"`, `\"not-available\"`.",
								Optional:    true,
								Validators: []validator.String{
									stringvalidator.OneOf("no", "yes", "not-available"),
								},
							},
							"is_installed": rsschema.BoolAttribute{
								Description: "Is Installed. Default: `true`.",
								Optional:    true,
								Computed:    true,
								Default:     booldefault.StaticBool(true),
							},
						},
					},
					"exclude_vendor": rsschema.BoolAttribute{
						Description: "The ExcludeVendor param. Default: `false`.",
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
					},
					"vendors": rsschema.ListNestedAttribute{
						Description: "Vendor name.",
						Optional:    true,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// inputs:map[string]bool{"name":true, "product":true} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
								"name": rsschema.StringAttribute{
									Description: "The Name param. String length must not exceed 103 characters.",
									Required:    true,
									Validators: []validator.String{
										stringvalidator.LengthAtMost(103),
									},
								},
								"products": rsschema.ListAttribute{
									Description: "Product name. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
									Optional:    true,
									ElementType: types.StringType,
									Validators: []validator.List{
										listvalidator.ValueStringsAre(
											stringvalidator.LengthAtMost(1023),
											stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
										),
									},
								},
							},
						},
					},
				},
			},
			"description": rsschema.StringAttribute{
				Description: "The Description param. String length must not exceed 255 characters.",
				Optional:    true,
				Validators: []validator.String{
					stringvalidator.LengthAtMost(255),
				},
			},
			"device": rsschema.StringAttribute{
				Description: "The Device param.",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"disk_backup": rsschema.SingleNestedAttribute{
				Description: "The DiskBackup param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
					"criteria": rsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"is_installed":true, "last_backup_time":true} outputs:map[string]bool{"is_installed":true, "last_backup_time":true} forceNew:map[string]bool(nil)
							"is_installed": rsschema.BoolAttribute{
								Description: "Is Installed. Default: `true`.",
								Optional:    true,
								Computed:    true,
								Default:     booldefault.StaticBool(true),
							},
							"last_backup_time": rsschema.SingleNestedAttribute{
								Description: "The LastBackupTime param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"not_available":true, "not_within":true, "within":true} outputs:map[string]bool{"not_available":true, "not_within":true, "within":true} forceNew:map[string]bool(nil)
									"not_available": rsschema.BoolAttribute{
										Description: "The NotAvailable param. Ensure that only one of the following is specified: `not_available`, `not_within`, `within`",
										Optional:    true,
										Validators: []validator.Bool{
											boolvalidator.ExactlyOneOf(
												path.MatchRelative(),
												path.MatchRelative().AtParent().AtName("not_within"),
												path.MatchRelative().AtParent().AtName("within"),
											),
										},
									},
									"not_within": rsschema.SingleNestedAttribute{
										Description: "The NotWithin param. Ensure that only one of the following is specified: `not_available`, `not_within`, `within`",
										Optional:    true,
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"days":true, "hours":true} outputs:map[string]bool{"days":true, "hours":true} forceNew:map[string]bool(nil)
											"days": rsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 65535. Ensure that only one of the following is specified: `days`, `hours`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
													int64validator.ExactlyOneOf(
														path.MatchRelative(),
														path.MatchRelative().AtParent().AtName("hours"),
													),
												},
											},
											"hours": rsschema.Int64Attribute{
												Description: "specify time in hours. Value must be between 1 and 65535. Ensure that only one of the following is specified: `days`, `hours`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
												},
											},
										},
									},
									"within": rsschema.SingleNestedAttribute{
										Description: "The Within param. Ensure that only one of the following is specified: `not_available`, `not_within`, `within`",
										Optional:    true,
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"days":true, "hours":true} outputs:map[string]bool{"days":true, "hours":true} forceNew:map[string]bool(nil)
											"days": rsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 65535. Ensure that only one of the following is specified: `days`, `hours`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
													int64validator.ExactlyOneOf(
														path.MatchRelative(),
														path.MatchRelative().AtParent().AtName("hours"),
													),
												},
											},
											"hours": rsschema.Int64Attribute{
												Description: "specify time in hours. Value must be between 1 and 65535. Ensure that only one of the following is specified: `days`, `hours`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
												},
											},
										},
									},
								},
							},
						},
					},
					"exclude_vendor": rsschema.BoolAttribute{
						Description: "The ExcludeVendor param. Default: `false`.",
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
					},
					"vendors": rsschema.ListNestedAttribute{
						Description: "Vendor name.",
						Optional:    true,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// inputs:map[string]bool{"name":true, "product":true} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
								"name": rsschema.StringAttribute{
									Description: "The Name param. String length must not exceed 103 characters.",
									Required:    true,
									Validators: []validator.String{
										stringvalidator.LengthAtMost(103),
									},
								},
								"products": rsschema.ListAttribute{
									Description: "The Products param. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
									Optional:    true,
									ElementType: types.StringType,
									Validators: []validator.List{
										listvalidator.ValueStringsAre(
											stringvalidator.LengthAtMost(1023),
											stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
										),
									},
								},
							},
						},
					},
				},
			},
			"disk_encryption": rsschema.SingleNestedAttribute{
				Description: "The DiskEncryption param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
					"criteria": rsschema.SingleNestedAttribute{
						Description: "Encryption locations.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"encrypted_locations":true, "is_installed":true} outputs:map[string]bool{"encrypted_locations":true, "is_installed":true} forceNew:map[string]bool(nil)
							"encrypted_locations": rsschema.ListNestedAttribute{
								Description: "The EncryptedLocations param.",
								Optional:    true,
								NestedObject: rsschema.NestedAttributeObject{
									Attributes: map[string]rsschema.Attribute{
										// inputs:map[string]bool{"encryption_state":true, "name":true} outputs:map[string]bool{"encryption_state":true, "name":true} forceNew:map[string]bool(nil)
										"encryption_state": rsschema.SingleNestedAttribute{
											Description: "The EncryptionState param.",
											Optional:    true,
											Attributes: map[string]rsschema.Attribute{
												// inputs:map[string]bool{"is":true, "is_not":true} outputs:map[string]bool{"is":true, "is_not":true} forceNew:map[string]bool(nil)
												"is": rsschema.StringAttribute{
													Description: "The Is param. String must be one of these: `\"encrypted\"`, `\"unencrypted\"`, `\"partial\"`, `\"unknown\"`. Ensure that only one of the following is specified: `is`, `is_not`",
													Optional:    true,
													Validators: []validator.String{
														stringvalidator.OneOf("encrypted", "unencrypted", "partial", "unknown"),
														stringvalidator.ExactlyOneOf(
															path.MatchRelative(),
															path.MatchRelative().AtParent().AtName("is_not"),
														),
													},
												},
												"is_not": rsschema.StringAttribute{
													Description: "The IsNot param. String must be one of these: `\"encrypted\"`, `\"unencrypted\"`, `\"partial\"`, `\"unknown\"`. Ensure that only one of the following is specified: `is`, `is_not`",
													Optional:    true,
													Validators: []validator.String{
														stringvalidator.OneOf("encrypted", "unencrypted", "partial", "unknown"),
													},
												},
											},
										},
										"name": rsschema.StringAttribute{
											Description: "Encryption location. String length must not exceed 1023 characters.",
											Required:    true,
											Validators: []validator.String{
												stringvalidator.LengthAtMost(1023),
											},
										},
									},
								},
							},
							"is_installed": rsschema.BoolAttribute{
								Description: "Is Installed. Default: `true`.",
								Optional:    true,
								Computed:    true,
								Default:     booldefault.StaticBool(true),
							},
						},
					},
					"exclude_vendor": rsschema.BoolAttribute{
						Description: "The ExcludeVendor param. Default: `false`.",
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
					},
					"vendors": rsschema.ListNestedAttribute{
						Description: "Vendor name.",
						Optional:    true,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// inputs:map[string]bool{"name":true, "product":true} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
								"name": rsschema.StringAttribute{
									Description: "The Name param. String length must not exceed 103 characters.",
									Required:    true,
									Validators: []validator.String{
										stringvalidator.LengthAtMost(103),
									},
								},
								"products": rsschema.ListAttribute{
									Description: "The Products param. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
									Optional:    true,
									ElementType: types.StringType,
									Validators: []validator.List{
										listvalidator.ValueStringsAre(
											stringvalidator.LengthAtMost(1023),
											stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
										),
									},
								},
							},
						},
					},
				},
			},
			"firewall": rsschema.SingleNestedAttribute{
				Description: "The Firewall param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
					"criteria": rsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"is_enabled":true, "is_installed":true} outputs:map[string]bool{"is_enabled":true, "is_installed":true} forceNew:map[string]bool(nil)
							"is_enabled": rsschema.StringAttribute{
								Description: "is enabled. String must be one of these: `\"no\"`, `\"yes\"`, `\"not-available\"`.",
								Optional:    true,
								Validators: []validator.String{
									stringvalidator.OneOf("no", "yes", "not-available"),
								},
							},
							"is_installed": rsschema.BoolAttribute{
								Description: "Is Installed. Default: `true`.",
								Optional:    true,
								Computed:    true,
								Default:     booldefault.StaticBool(true),
							},
						},
					},
					"exclude_vendor": rsschema.BoolAttribute{
						Description: "The ExcludeVendor param. Default: `false`.",
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
					},
					"vendors": rsschema.ListNestedAttribute{
						Description: "Vendor name.",
						Optional:    true,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// inputs:map[string]bool{"name":true, "product":true} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
								"name": rsschema.StringAttribute{
									Description: "The Name param. String length must not exceed 103 characters.",
									Required:    true,
									Validators: []validator.String{
										stringvalidator.LengthAtMost(103),
									},
								},
								"products": rsschema.ListAttribute{
									Description: "The Products param. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
									Optional:    true,
									ElementType: types.StringType,
									Validators: []validator.List{
										listvalidator.ValueStringsAre(
											stringvalidator.LengthAtMost(1023),
											stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
										),
									},
								},
							},
						},
					},
				},
			},
			"folder": rsschema.StringAttribute{
				Description: "The Folder param.",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"host_info": rsschema.SingleNestedAttribute{
				Description: "The HostInfo param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"criteria":true} outputs:map[string]bool{"criteria":true} forceNew:map[string]bool(nil)
					"criteria": rsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Required:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"client_version":true, "domain":true, "host_id":true, "host_name":true, "managed":true, "os":true, "serial_number":true} outputs:map[string]bool{"client_version":true, "domain":true, "host_id":true, "host_name":true, "managed":true, "os":true, "serial_number":true} forceNew:map[string]bool(nil)
							"client_version": rsschema.SingleNestedAttribute{
								Description: "The ClientVersion param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"contains":true, "is":true, "is_not":true} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": rsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
											stringvalidator.ExactlyOneOf(
												path.MatchRelative(),
												path.MatchRelative().AtParent().AtName("is"),
												path.MatchRelative().AtParent().AtName("is_not"),
											),
										},
									},
									"is": rsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
									"is_not": rsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
								},
							},
							"domain": rsschema.SingleNestedAttribute{
								Description: "The Domain param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"contains":true, "is":true, "is_not":true} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": rsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
											stringvalidator.ExactlyOneOf(
												path.MatchRelative(),
												path.MatchRelative().AtParent().AtName("is"),
												path.MatchRelative().AtParent().AtName("is_not"),
											),
										},
									},
									"is": rsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
									"is_not": rsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
								},
							},
							"host_id": rsschema.SingleNestedAttribute{
								Description: "The HostId param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"contains":true, "is":true, "is_not":true} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": rsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
											stringvalidator.ExactlyOneOf(
												path.MatchRelative(),
												path.MatchRelative().AtParent().AtName("is"),
												path.MatchRelative().AtParent().AtName("is_not"),
											),
										},
									},
									"is": rsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
									"is_not": rsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
								},
							},
							"host_name": rsschema.SingleNestedAttribute{
								Description: "The HostName param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"contains":true, "is":true, "is_not":true} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": rsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
											stringvalidator.ExactlyOneOf(
												path.MatchRelative(),
												path.MatchRelative().AtParent().AtName("is"),
												path.MatchRelative().AtParent().AtName("is_not"),
											),
										},
									},
									"is": rsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
									"is_not": rsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
								},
							},
							"managed": rsschema.BoolAttribute{
								Description: "If device is managed.",
								Optional:    true,
							},
							"os": rsschema.SingleNestedAttribute{
								Description: "The Os param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"contains":true} outputs:map[string]bool{"contains":true} forceNew:map[string]bool(nil)
									"contains": rsschema.SingleNestedAttribute{
										Description: "The Contains param. Ensure that only one of the following is specified: `contains`",
										Optional:    true,
										Validators: []validator.Object{
											objectvalidator.ExactlyOneOf(
												path.MatchRelative(),
											),
										},
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"Apple":true, "Google":true, "Linux":true, "Microsoft":true, "Other":true} outputs:map[string]bool{"Apple":true, "Google":true, "Linux":true, "Microsoft":true, "Other":true} forceNew:map[string]bool(nil)
											"apple": rsschema.StringAttribute{
												Description: "Apple vendor. String length must not exceed 255 characters. Ensure that only one of the following is specified: `Apple`, `Google`, `Linux`, `Microsoft`, `Other`",
												Optional:    true,
												Validators: []validator.String{
													stringvalidator.LengthAtMost(255),
													stringvalidator.ExactlyOneOf(
														path.MatchRelative(),
														path.MatchRelative().AtParent().AtName("google"),
														path.MatchRelative().AtParent().AtName("linux"),
														path.MatchRelative().AtParent().AtName("microsoft"),
														path.MatchRelative().AtParent().AtName("other"),
													),
												},
											},
											"google": rsschema.StringAttribute{
												Description: "Google vendor. String length must not exceed 255 characters. Ensure that only one of the following is specified: `Apple`, `Google`, `Linux`, `Microsoft`, `Other`",
												Optional:    true,
												Validators: []validator.String{
													stringvalidator.LengthAtMost(255),
												},
											},
											"linux": rsschema.StringAttribute{
												Description: "Linux vendor. String length must not exceed 255 characters. Ensure that only one of the following is specified: `Apple`, `Google`, `Linux`, `Microsoft`, `Other`",
												Optional:    true,
												Validators: []validator.String{
													stringvalidator.LengthAtMost(255),
												},
											},
											"microsoft": rsschema.StringAttribute{
												Description: "Microsoft vendor. String length must not exceed 255 characters. Ensure that only one of the following is specified: `Apple`, `Google`, `Linux`, `Microsoft`, `Other`",
												Optional:    true,
												Validators: []validator.String{
													stringvalidator.LengthAtMost(255),
												},
											},
											"other": rsschema.StringAttribute{
												Description: "Other vendor. String length must not exceed 255 characters. Ensure that only one of the following is specified: `Apple`, `Google`, `Linux`, `Microsoft`, `Other`",
												Optional:    true,
												Validators: []validator.String{
													stringvalidator.LengthAtMost(255),
												},
											},
										},
									},
								},
							},
							"serial_number": rsschema.SingleNestedAttribute{
								Description: "The SerialNumber param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"contains":true, "is":true, "is_not":true} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": rsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
											stringvalidator.ExactlyOneOf(
												path.MatchRelative(),
												path.MatchRelative().AtParent().AtName("is"),
												path.MatchRelative().AtParent().AtName("is_not"),
											),
										},
									},
									"is": rsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
									"is_not": rsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
								},
							},
						},
					},
				},
			},
			"id": rsschema.StringAttribute{
				Description: "UUID of the resource.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"mobile_device": rsschema.SingleNestedAttribute{
				Description: "The MobileDevice param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"criteria":true} outputs:map[string]bool{"criteria":true} forceNew:map[string]bool(nil)
					"criteria": rsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"applications":true, "disk_encrypted":true, "imei":true, "jailbroken":true, "last_checkin_time":true, "model":true, "passcode_set":true, "phone_number":true, "tag":true} outputs:map[string]bool{"applications":true, "disk_encrypted":true, "imei":true, "jailbroken":true, "last_checkin_time":true, "model":true, "passcode_set":true, "phone_number":true, "tag":true} forceNew:map[string]bool(nil)
							"applications": rsschema.SingleNestedAttribute{
								Description: "The Applications param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"has_malware":true, "has_unmanaged_app":true, "includes":true} outputs:map[string]bool{"has_malware":true, "has_unmanaged_app":true, "includes":true} forceNew:map[string]bool(nil)
									"has_malware": rsschema.SingleNestedAttribute{
										Description: "The HasMalware param.",
										Optional:    true,
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"no":true, "yes":true} outputs:map[string]bool{"no":true, "yes":true} forceNew:map[string]bool(nil)
											"no": rsschema.BoolAttribute{
												Description: "The No param. Ensure that only one of the following is specified: `no`, `yes`",
												Optional:    true,
												Validators: []validator.Bool{
													boolvalidator.ExactlyOneOf(
														path.MatchRelative(),
														path.MatchRelative().AtParent().AtName("yes"),
													),
												},
											},
											"yes": rsschema.SingleNestedAttribute{
												Description: "The Yes param. Ensure that only one of the following is specified: `no`, `yes`",
												Optional:    true,
												Attributes: map[string]rsschema.Attribute{
													// inputs:map[string]bool{"excludes":true} outputs:map[string]bool{"excludes":true} forceNew:map[string]bool(nil)
													"excludes": rsschema.ListNestedAttribute{
														Description: "The Excludes param.",
														Optional:    true,
														NestedObject: rsschema.NestedAttributeObject{
															Attributes: map[string]rsschema.Attribute{
																// inputs:map[string]bool{"hash":true, "name":true, "package":true} outputs:map[string]bool{"hash":true, "name":true, "package":true} forceNew:map[string]bool(nil)
																"hash": rsschema.StringAttribute{
																	Description: "application hash. String length must not exceed 1024 characters. String validation regex: `.*`.",
																	Optional:    true,
																	Validators: []validator.String{
																		stringvalidator.LengthAtMost(1024),
																		stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
																	},
																},
																"name": rsschema.StringAttribute{
																	Description: "The Name param. String length must not exceed 31 characters.",
																	Required:    true,
																	Validators: []validator.String{
																		stringvalidator.LengthAtMost(31),
																	},
																},
																"package": rsschema.StringAttribute{
																	Description: "application package name. String length must not exceed 1024 characters. String validation regex: `.*`.",
																	Optional:    true,
																	Validators: []validator.String{
																		stringvalidator.LengthAtMost(1024),
																		stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"has_unmanaged_app": rsschema.BoolAttribute{
										Description: "Has apps that are not managed.",
										Optional:    true,
									},
									"includes": rsschema.ListNestedAttribute{
										Description: "The Includes param.",
										Optional:    true,
										NestedObject: rsschema.NestedAttributeObject{
											Attributes: map[string]rsschema.Attribute{
												// inputs:map[string]bool{"hash":true, "name":true, "package":true} outputs:map[string]bool{"hash":true, "name":true, "package":true} forceNew:map[string]bool(nil)
												"hash": rsschema.StringAttribute{
													Description: "application hash. String length must not exceed 1024 characters. String validation regex: `.*`.",
													Optional:    true,
													Validators: []validator.String{
														stringvalidator.LengthAtMost(1024),
														stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
													},
												},
												"name": rsschema.StringAttribute{
													Description: "The Name param. String length must not exceed 31 characters.",
													Required:    true,
													Validators: []validator.String{
														stringvalidator.LengthAtMost(31),
													},
												},
												"package": rsschema.StringAttribute{
													Description: "application package name. String length must not exceed 1024 characters. String validation regex: `.*`.",
													Optional:    true,
													Validators: []validator.String{
														stringvalidator.LengthAtMost(1024),
														stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
													},
												},
											},
										},
									},
								},
							},
							"disk_encrypted": rsschema.BoolAttribute{
								Description: "If device's disk is encrypted.",
								Optional:    true,
							},
							"imei": rsschema.SingleNestedAttribute{
								Description: "The Imei param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"contains":true, "is":true, "is_not":true} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": rsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
											stringvalidator.ExactlyOneOf(
												path.MatchRelative(),
												path.MatchRelative().AtParent().AtName("is"),
												path.MatchRelative().AtParent().AtName("is_not"),
											),
										},
									},
									"is": rsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
									"is_not": rsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
								},
							},
							"jailbroken": rsschema.BoolAttribute{
								Description: "If device is by rooted/jailbroken.",
								Optional:    true,
							},
							"last_checkin_time": rsschema.SingleNestedAttribute{
								Description: "The LastCheckinTime param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"not_within":true, "within":true} outputs:map[string]bool{"not_within":true, "within":true} forceNew:map[string]bool(nil)
									"not_within": rsschema.SingleNestedAttribute{
										Description: "The NotWithin param. Ensure that only one of the following is specified: `not_within`, `within`",
										Optional:    true,
										Validators: []validator.Object{
											objectvalidator.ExactlyOneOf(
												path.MatchRelative(),
												path.MatchRelative().AtParent().AtName("within"),
											),
										},
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"days":true} outputs:map[string]bool{"days":true} forceNew:map[string]bool(nil)
											"days": rsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 365. Default: `30`.",
												Optional:    true,
												Computed:    true,
												Default:     int64default.StaticInt64(30),
												Validators: []validator.Int64{
													int64validator.Between(1, 365),
												},
											},
										},
									},
									"within": rsschema.SingleNestedAttribute{
										Description: "The Within param. Ensure that only one of the following is specified: `not_within`, `within`",
										Optional:    true,
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"days":true} outputs:map[string]bool{"days":true} forceNew:map[string]bool(nil)
											"days": rsschema.Int64Attribute{
												Description: "specify time in days. Value must be between 1 and 365. Default: `30`.",
												Optional:    true,
												Computed:    true,
												Default:     int64default.StaticInt64(30),
												Validators: []validator.Int64{
													int64validator.Between(1, 365),
												},
											},
										},
									},
								},
							},
							"model": rsschema.SingleNestedAttribute{
								Description: "The Model param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"contains":true, "is":true, "is_not":true} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": rsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
											stringvalidator.ExactlyOneOf(
												path.MatchRelative(),
												path.MatchRelative().AtParent().AtName("is"),
												path.MatchRelative().AtParent().AtName("is_not"),
											),
										},
									},
									"is": rsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
									"is_not": rsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
								},
							},
							"passcode_set": rsschema.BoolAttribute{
								Description: "If device's passcode is present.",
								Optional:    true,
							},
							"phone_number": rsschema.SingleNestedAttribute{
								Description: "The PhoneNumber param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"contains":true, "is":true, "is_not":true} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": rsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
											stringvalidator.ExactlyOneOf(
												path.MatchRelative(),
												path.MatchRelative().AtParent().AtName("is"),
												path.MatchRelative().AtParent().AtName("is_not"),
											),
										},
									},
									"is": rsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
									"is_not": rsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
								},
							},
							"tag": rsschema.SingleNestedAttribute{
								Description: "The Tag param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"contains":true, "is":true, "is_not":true} outputs:map[string]bool{"contains":true, "is":true, "is_not":true} forceNew:map[string]bool(nil)
									"contains": rsschema.StringAttribute{
										Description: "The Contains param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
											stringvalidator.ExactlyOneOf(
												path.MatchRelative(),
												path.MatchRelative().AtParent().AtName("is"),
												path.MatchRelative().AtParent().AtName("is_not"),
											),
										},
									},
									"is": rsschema.StringAttribute{
										Description: "The Is param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
									"is_not": rsschema.StringAttribute{
										Description: "The IsNot param. String length must not exceed 255 characters. Ensure that only one of the following is specified: `contains`, `is`, `is_not`",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
								},
							},
						},
					},
				},
			},
			"name": rsschema.StringAttribute{
				Description: "Alphanumeric string [ 0-9a-zA-Z._-]. String length must not exceed 31 characters.",
				Required:    true,
				Validators: []validator.String{
					stringvalidator.LengthAtMost(31),
				},
			},
			"network_info": rsschema.SingleNestedAttribute{
				Description: "The NetworkInfo param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"criteria":true} outputs:map[string]bool{"criteria":true} forceNew:map[string]bool(nil)
					"criteria": rsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"network":true} outputs:map[string]bool{"network":true} forceNew:map[string]bool(nil)
							"network": rsschema.SingleNestedAttribute{
								Description: "The Network param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"is":true, "is_not":true} outputs:map[string]bool{"is":true, "is_not":true} forceNew:map[string]bool(nil)
									"is": rsschema.SingleNestedAttribute{
										Description: "The Is param. Ensure that only one of the following is specified: `is`, `is_not`",
										Optional:    true,
										Validators: []validator.Object{
											objectvalidator.ExactlyOneOf(
												path.MatchRelative(),
												path.MatchRelative().AtParent().AtName("is_not"),
											),
										},
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"mobile":true, "unknown":true, "wifi":true} outputs:map[string]bool{"mobile":true, "unknown":true, "wifi":true} forceNew:map[string]bool(nil)
											"mobile": rsschema.SingleNestedAttribute{
												Description: "The Mobile param. Ensure that only one of the following is specified: `mobile`, `unknown`, `wifi`",
												Optional:    true,
												Validators: []validator.Object{
													objectvalidator.ExactlyOneOf(
														path.MatchRelative(),
														path.MatchRelative().AtParent().AtName("unknown"),
														path.MatchRelative().AtParent().AtName("wifi"),
													),
												},
												Attributes: map[string]rsschema.Attribute{
													// inputs:map[string]bool{"carrier":true} outputs:map[string]bool{"carrier":true} forceNew:map[string]bool(nil)
													"carrier": rsschema.StringAttribute{
														Description: "The Carrier param. String length must not exceed 1023 characters. String validation regex: `.*`.",
														Optional:    true,
														Validators: []validator.String{
															stringvalidator.LengthAtMost(1023),
															stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
														},
													},
												},
											},
											"unknown": rsschema.BoolAttribute{
												Description: "The Unknown param. Ensure that only one of the following is specified: `mobile`, `unknown`, `wifi`",
												Optional:    true,
											},
											"wifi": rsschema.SingleNestedAttribute{
												Description: "The Wifi param. Ensure that only one of the following is specified: `mobile`, `unknown`, `wifi`",
												Optional:    true,
												Attributes: map[string]rsschema.Attribute{
													// inputs:map[string]bool{"ssid":true} outputs:map[string]bool{"ssid":true} forceNew:map[string]bool(nil)
													"ssid": rsschema.StringAttribute{
														Description: "SSID. String length must not exceed 1023 characters. String validation regex: `.*`.",
														Optional:    true,
														Validators: []validator.String{
															stringvalidator.LengthAtMost(1023),
															stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
														},
													},
												},
											},
										},
									},
									"is_not": rsschema.SingleNestedAttribute{
										Description: "The IsNot param. Ensure that only one of the following is specified: `is`, `is_not`",
										Optional:    true,
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"ethernet":true, "mobile":true, "unknown":true, "wifi":true} outputs:map[string]bool{"ethernet":true, "mobile":true, "unknown":true, "wifi":true} forceNew:map[string]bool(nil)
											"ethernet": rsschema.BoolAttribute{
												Description: "The Ethernet param. Ensure that only one of the following is specified: `ethernet`, `mobile`, `unknown`, `wifi`",
												Optional:    true,
												Validators: []validator.Bool{
													boolvalidator.ExactlyOneOf(
														path.MatchRelative(),
														path.MatchRelative().AtParent().AtName("mobile"),
														path.MatchRelative().AtParent().AtName("unknown"),
														path.MatchRelative().AtParent().AtName("wifi"),
													),
												},
											},
											"mobile": rsschema.SingleNestedAttribute{
												Description: "The Mobile param. Ensure that only one of the following is specified: `ethernet`, `mobile`, `unknown`, `wifi`",
												Optional:    true,
												Attributes: map[string]rsschema.Attribute{
													// inputs:map[string]bool{"carrier":true} outputs:map[string]bool{"carrier":true} forceNew:map[string]bool(nil)
													"carrier": rsschema.StringAttribute{
														Description: "The Carrier param. String length must not exceed 1023 characters. String validation regex: `.*`.",
														Optional:    true,
														Validators: []validator.String{
															stringvalidator.LengthAtMost(1023),
															stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
														},
													},
												},
											},
											"unknown": rsschema.BoolAttribute{
												Description: "The Unknown param. Ensure that only one of the following is specified: `ethernet`, `mobile`, `unknown`, `wifi`",
												Optional:    true,
											},
											"wifi": rsschema.SingleNestedAttribute{
												Description: "The Wifi param. Ensure that only one of the following is specified: `ethernet`, `mobile`, `unknown`, `wifi`",
												Optional:    true,
												Attributes: map[string]rsschema.Attribute{
													// inputs:map[string]bool{"ssid":true} outputs:map[string]bool{"ssid":true} forceNew:map[string]bool(nil)
													"ssid": rsschema.StringAttribute{
														Description: "SSID. String length must not exceed 1023 characters. String validation regex: `.*`.",
														Optional:    true,
														Validators: []validator.String{
															stringvalidator.LengthAtMost(1023),
															stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"patch_management": rsschema.SingleNestedAttribute{
				Description: "The PatchManagement param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} outputs:map[string]bool{"criteria":true, "exclude_vendor":true, "vendor":true} forceNew:map[string]bool(nil)
					"criteria": rsschema.SingleNestedAttribute{
						Description: "The Criteria param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"is_enabled":true, "is_installed":true, "missing_patches":true} outputs:map[string]bool{"is_enabled":true, "is_installed":true, "missing_patches":true} forceNew:map[string]bool(nil)
							"is_enabled": rsschema.StringAttribute{
								Description: "is enabled. String must be one of these: `\"no\"`, `\"yes\"`, `\"not-available\"`.",
								Optional:    true,
								Validators: []validator.String{
									stringvalidator.OneOf("no", "yes", "not-available"),
								},
							},
							"is_installed": rsschema.BoolAttribute{
								Description: "Is Installed. Default: `true`.",
								Optional:    true,
								Computed:    true,
								Default:     booldefault.StaticBool(true),
							},
							"missing_patches": rsschema.SingleNestedAttribute{
								Description: "The MissingPatches param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"check":true, "patches":true, "severity":true} outputs:map[string]bool{"check":true, "patches":true, "severity":true} forceNew:map[string]bool(nil)
									"check": rsschema.StringAttribute{
										Description: "The Check param. String must be one of these: `\"has-any\"`, `\"has-none\"`, `\"has-all\"`. Default: `\"has-any\"`.",
										Optional:    true,
										Computed:    true,
										Default:     stringdefault.StaticString("has-any"),
										Validators: []validator.String{
											stringvalidator.OneOf("has-any", "has-none", "has-all"),
										},
									},
									"patches": rsschema.ListAttribute{
										Description: "The Patches param. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
										Optional:    true,
										ElementType: types.StringType,
										Validators: []validator.List{
											listvalidator.ValueStringsAre(
												stringvalidator.LengthAtMost(1023),
												stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
											),
										},
									},
									"severity": rsschema.SingleNestedAttribute{
										Description: "The Severity param.",
										Optional:    true,
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"greater_equal":true, "greater_than":true, "is":true, "is_not":true, "less_equal":true, "less_than":true} outputs:map[string]bool{"greater_equal":true, "greater_than":true, "is":true, "is_not":true, "less_equal":true, "less_than":true} forceNew:map[string]bool(nil)
											"greater_equal": rsschema.Int64Attribute{
												Description: "The GreaterEqual param. Value must be between 0 and 100000. Ensure that only one of the following is specified: `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(0, 100000),
													int64validator.ExactlyOneOf(
														path.MatchRelative(),
														path.MatchRelative().AtParent().AtName("greater_than"),
														path.MatchRelative().AtParent().AtName("is"),
														path.MatchRelative().AtParent().AtName("is_not"),
														path.MatchRelative().AtParent().AtName("less_equal"),
														path.MatchRelative().AtParent().AtName("less_than"),
													),
												},
											},
											"greater_than": rsschema.Int64Attribute{
												Description: "The GreaterThan param. Value must be between 0 and 100000. Ensure that only one of the following is specified: `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(0, 100000),
												},
											},
											"is": rsschema.Int64Attribute{
												Description: "The Is param. Value must be between 0 and 100000. Ensure that only one of the following is specified: `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(0, 100000),
												},
											},
											"is_not": rsschema.Int64Attribute{
												Description: "The IsNot param. Value must be between 0 and 100000. Ensure that only one of the following is specified: `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(0, 100000),
												},
											},
											"less_equal": rsschema.Int64Attribute{
												Description: "The LessEqual param. Value must be between 0 and 100000. Ensure that only one of the following is specified: `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(0, 100000),
												},
											},
											"less_than": rsschema.Int64Attribute{
												Description: "The LessThan param. Value must be between 0 and 100000. Ensure that only one of the following is specified: `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`",
												Optional:    true,
												Validators: []validator.Int64{
													int64validator.Between(0, 100000),
												},
											},
										},
									},
								},
							},
						},
					},
					"exclude_vendor": rsschema.BoolAttribute{
						Description: "The ExcludeVendor param. Default: `false`.",
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
					},
					"vendors": rsschema.ListNestedAttribute{
						Description: "Vendor name.",
						Optional:    true,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// inputs:map[string]bool{"name":true, "product":true} outputs:map[string]bool{"name":true, "product":true} forceNew:map[string]bool(nil)
								"name": rsschema.StringAttribute{
									Description: "The Name param. String length must not exceed 103 characters.",
									Required:    true,
									Validators: []validator.String{
										stringvalidator.LengthAtMost(103),
									},
								},
								"products": rsschema.ListAttribute{
									Description: "Product name. Individual elements in this list are subject to additional validation. String length must not exceed 1023 characters. String validation regex: `.*`.",
									Optional:    true,
									ElementType: types.StringType,
									Validators: []validator.List{
										listvalidator.ValueStringsAre(
											stringvalidator.LengthAtMost(1023),
											stringvalidator.RegexMatches(regexp.MustCompile(".*"), ""),
										),
									},
								},
							},
						},
					},
				},
			},
			"snippet": rsschema.StringAttribute{
				Description: "The Snippet param.",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"tfid": rsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
	}
}

// Configure prepares the struct.
func (r *hipObjectResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*scm.Client)
}

// Create resource.
func (r *hipObjectResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state hipObjectRsModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name":               "scm_hip_object",
		"terraform_provider_function": "Create",
		"folder":                      state.Folder.ValueString(),
		"snippet":                     state.Snippet.ValueString(),
		"device":                      state.Device.ValueString(),
	})

	// Prepare to create the config.
	svc := sdhSKaQ.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := sdhSKaQ.CreateInput{}

	input.Folder = state.Folder.ValueStringPointer()

	input.Snippet = state.Snippet.ValueStringPointer()

	input.Device = state.Device.ValueStringPointer()
	input.Request = &suxdMuj.Config{}

	if state.AntiMalware != nil {
		input.Request.AntiMalware = &suxdMuj.AntiMalwareObject{}

		if state.AntiMalware.Criteria != nil {
			input.Request.AntiMalware.Criteria = &suxdMuj.AntiMalwareCriteriaObject{}

			input.Request.AntiMalware.Criteria.IsInstalled = state.AntiMalware.Criteria.IsInstalled.ValueBoolPointer()

			if state.AntiMalware.Criteria.LastScanTime != nil {
				input.Request.AntiMalware.Criteria.LastScanTime = &suxdMuj.LastScanTimeObject{}

				if !state.AntiMalware.Criteria.LastScanTime.NotAvailable.IsNull() && state.AntiMalware.Criteria.LastScanTime.NotAvailable.ValueBool() {
					input.Request.AntiMalware.Criteria.LastScanTime.NotAvailable = map[string]interface{}{}
				}

				if state.AntiMalware.Criteria.LastScanTime.NotWithin != nil {
					input.Request.AntiMalware.Criteria.LastScanTime.NotWithin = &suxdMuj.LastScanTimeNotWithinObject{}

					input.Request.AntiMalware.Criteria.LastScanTime.NotWithin.Days = state.AntiMalware.Criteria.LastScanTime.NotWithin.Days.ValueInt64Pointer()

					input.Request.AntiMalware.Criteria.LastScanTime.NotWithin.Hours = state.AntiMalware.Criteria.LastScanTime.NotWithin.Hours.ValueInt64Pointer()
				}

				if state.AntiMalware.Criteria.LastScanTime.Within != nil {
					input.Request.AntiMalware.Criteria.LastScanTime.Within = &suxdMuj.LastScanTimeWithinObject{}

					input.Request.AntiMalware.Criteria.LastScanTime.Within.Days = state.AntiMalware.Criteria.LastScanTime.Within.Days.ValueInt64Pointer()

					input.Request.AntiMalware.Criteria.LastScanTime.Within.Hours = state.AntiMalware.Criteria.LastScanTime.Within.Hours.ValueInt64Pointer()
				}
			}

			if state.AntiMalware.Criteria.ProductVersion != nil {
				input.Request.AntiMalware.Criteria.ProductVersion = &suxdMuj.ProductVersionObject{}

				input.Request.AntiMalware.Criteria.ProductVersion.Contains = state.AntiMalware.Criteria.ProductVersion.Contains.ValueStringPointer()

				input.Request.AntiMalware.Criteria.ProductVersion.GreaterEqual = state.AntiMalware.Criteria.ProductVersion.GreaterEqual.ValueStringPointer()

				input.Request.AntiMalware.Criteria.ProductVersion.GreaterThan = state.AntiMalware.Criteria.ProductVersion.GreaterThan.ValueStringPointer()

				input.Request.AntiMalware.Criteria.ProductVersion.Is = state.AntiMalware.Criteria.ProductVersion.Is.ValueStringPointer()

				input.Request.AntiMalware.Criteria.ProductVersion.IsNot = state.AntiMalware.Criteria.ProductVersion.IsNot.ValueStringPointer()

				input.Request.AntiMalware.Criteria.ProductVersion.LessEqual = state.AntiMalware.Criteria.ProductVersion.LessEqual.ValueStringPointer()

				input.Request.AntiMalware.Criteria.ProductVersion.LessThan = state.AntiMalware.Criteria.ProductVersion.LessThan.ValueStringPointer()

				if state.AntiMalware.Criteria.ProductVersion.NotWithin != nil {
					input.Request.AntiMalware.Criteria.ProductVersion.NotWithin = &suxdMuj.ProductVersionNotWithinObject{}

					input.Request.AntiMalware.Criteria.ProductVersion.NotWithin.Versions = state.AntiMalware.Criteria.ProductVersion.NotWithin.Versions.ValueInt64()
				}

				if state.AntiMalware.Criteria.ProductVersion.Within != nil {
					input.Request.AntiMalware.Criteria.ProductVersion.Within = &suxdMuj.ProductVersionWithinObject{}

					input.Request.AntiMalware.Criteria.ProductVersion.Within.Versions = state.AntiMalware.Criteria.ProductVersion.Within.Versions.ValueInt64()
				}
			}

			input.Request.AntiMalware.Criteria.RealTimeProtection = state.AntiMalware.Criteria.RealTimeProtection.ValueStringPointer()

			if state.AntiMalware.Criteria.VirdefVersion != nil {
				input.Request.AntiMalware.Criteria.VirdefVersion = &suxdMuj.VirdefVersionObject{}

				if state.AntiMalware.Criteria.VirdefVersion.NotWithin != nil {
					input.Request.AntiMalware.Criteria.VirdefVersion.NotWithin = &suxdMuj.VirdefVersionNotWithinObject{}

					input.Request.AntiMalware.Criteria.VirdefVersion.NotWithin.Days = state.AntiMalware.Criteria.VirdefVersion.NotWithin.Days.ValueInt64Pointer()

					input.Request.AntiMalware.Criteria.VirdefVersion.NotWithin.Versions = state.AntiMalware.Criteria.VirdefVersion.NotWithin.Versions.ValueInt64Pointer()
				}

				if state.AntiMalware.Criteria.VirdefVersion.Within != nil {
					input.Request.AntiMalware.Criteria.VirdefVersion.Within = &suxdMuj.VirdefVersionWithinObject{}

					input.Request.AntiMalware.Criteria.VirdefVersion.Within.Days = state.AntiMalware.Criteria.VirdefVersion.Within.Days.ValueInt64Pointer()

					input.Request.AntiMalware.Criteria.VirdefVersion.Within.Versions = state.AntiMalware.Criteria.VirdefVersion.Within.Versions.ValueInt64Pointer()
				}
			}
		}

		input.Request.AntiMalware.ExcludeVendor = state.AntiMalware.ExcludeVendor.ValueBoolPointer()

		if len(state.AntiMalware.Vendors) != 0 {
			input.Request.AntiMalware.Vendors = make([]suxdMuj.AntiMalwareVendorObject, 0, len(state.AntiMalware.Vendors))
			for _, var0 := range state.AntiMalware.Vendors {
				var var1 suxdMuj.AntiMalwareVendorObject

				var1.Name = var0.Name.ValueString()

				resp.Diagnostics.Append(var0.Products.ElementsAs(ctx, &var1.Products, false)...)
				//if len(var0.Products) != 0 {
				//    var1.Products = make([]string, 0, len(var0.Products))
				//    for _, var2 := range var0.Products {
				//        var1.Products = append(var1.Products, var2.ValueString())
				//    }
				//}
				input.Request.AntiMalware.Vendors = append(input.Request.AntiMalware.Vendors, var1)
			}
		}
	}

	if state.Certificate != nil {
		input.Request.Certificate = &suxdMuj.CertificateObject{}

		if state.Certificate.Criteria != nil {
			input.Request.Certificate.Criteria = &suxdMuj.CertificateCriteriaObject{}

			if len(state.Certificate.Criteria.CertificateAttributes) != 0 {
				input.Request.Certificate.Criteria.CertificateAttributes = make([]suxdMuj.CertificateAttributeObject, 0, len(state.Certificate.Criteria.CertificateAttributes))
				for _, var3 := range state.Certificate.Criteria.CertificateAttributes {
					var var4 suxdMuj.CertificateAttributeObject

					var4.Name = var3.Name.ValueString()

					var4.Value = var3.Value.ValueStringPointer()
					input.Request.Certificate.Criteria.CertificateAttributes = append(input.Request.Certificate.Criteria.CertificateAttributes, var4)
				}
			}

			input.Request.Certificate.Criteria.CertificateProfile = state.Certificate.Criteria.CertificateProfile.ValueStringPointer()
		}
	}

	if state.CustomChecks != nil {
		input.Request.CustomChecks = &suxdMuj.CustomChecksObject{}

		if len(state.CustomChecks.Criteria.Plist) != 0 {
			input.Request.CustomChecks.Criteria.Plist = make([]suxdMuj.PlistObject, 0, len(state.CustomChecks.Criteria.Plist))
			for _, var5 := range state.CustomChecks.Criteria.Plist {
				var var6 suxdMuj.PlistObject

				if len(var5.Keys) != 0 {
					var6.Keys = make([]suxdMuj.KeyObject, 0, len(var5.Keys))
					for _, var7 := range var5.Keys {
						var var8 suxdMuj.KeyObject

						var8.Name = var7.Name.ValueString()

						var8.Negate = var7.Negate.ValueBoolPointer()

						var8.Value = var7.Value.ValueStringPointer()
						var6.Keys = append(var6.Keys, var8)
					}
				}

				var6.Name = var5.Name.ValueString()

				var6.Negate = var5.Negate.ValueBoolPointer()
				input.Request.CustomChecks.Criteria.Plist = append(input.Request.CustomChecks.Criteria.Plist, var6)
			}
		}

		if len(state.CustomChecks.Criteria.ProcessList) != 0 {
			input.Request.CustomChecks.Criteria.ProcessList = make([]suxdMuj.ProcessListObject, 0, len(state.CustomChecks.Criteria.ProcessList))
			for _, var9 := range state.CustomChecks.Criteria.ProcessList {
				var var10 suxdMuj.ProcessListObject

				var10.Name = var9.Name.ValueString()

				var10.Running = var9.Running.ValueBoolPointer()
				input.Request.CustomChecks.Criteria.ProcessList = append(input.Request.CustomChecks.Criteria.ProcessList, var10)
			}
		}

		if len(state.CustomChecks.Criteria.RegistryKeys) != 0 {
			input.Request.CustomChecks.Criteria.RegistryKeys = make([]suxdMuj.RegistryKeyObject, 0, len(state.CustomChecks.Criteria.RegistryKeys))
			for _, var11 := range state.CustomChecks.Criteria.RegistryKeys {
				var var12 suxdMuj.RegistryKeyObject

				var12.DefaultValueData = var11.DefaultValueData.ValueStringPointer()

				var12.Name = var11.Name.ValueString()

				var12.Negate = var11.Negate.ValueBoolPointer()

				if len(var11.RegistryValues) != 0 {
					var12.RegistryValues = make([]suxdMuj.RegistryValueObject, 0, len(var11.RegistryValues))
					for _, var13 := range var11.RegistryValues {
						var var14 suxdMuj.RegistryValueObject

						var14.Name = var13.Name.ValueString()

						var14.Negate = var13.Negate.ValueBoolPointer()

						var14.ValueData = var13.ValueData.ValueStringPointer()
						var12.RegistryValues = append(var12.RegistryValues, var14)
					}
				}
				input.Request.CustomChecks.Criteria.RegistryKeys = append(input.Request.CustomChecks.Criteria.RegistryKeys, var12)
			}
		}
	}

	if state.DataLossPrevention != nil {
		input.Request.DataLossPrevention = &suxdMuj.DataLossPreventionObject{}

		if state.DataLossPrevention.Criteria != nil {
			input.Request.DataLossPrevention.Criteria = &suxdMuj.DataLossPreventionCriteriaObject{}

			input.Request.DataLossPrevention.Criteria.IsEnabled = state.DataLossPrevention.Criteria.IsEnabled.ValueStringPointer()

			input.Request.DataLossPrevention.Criteria.IsInstalled = state.DataLossPrevention.Criteria.IsInstalled.ValueBoolPointer()
		}

		input.Request.DataLossPrevention.ExcludeVendor = state.DataLossPrevention.ExcludeVendor.ValueBoolPointer()

		if len(state.DataLossPrevention.Vendors) != 0 {
			input.Request.DataLossPrevention.Vendors = make([]suxdMuj.DataLossPreventionVendorObject, 0, len(state.DataLossPrevention.Vendors))
			for _, var15 := range state.DataLossPrevention.Vendors {
				var var16 suxdMuj.DataLossPreventionVendorObject

				var16.Name = var15.Name.ValueString()

				resp.Diagnostics.Append(var15.Products.ElementsAs(ctx, &var16.Products, false)...)
				//if len(var15.Products) != 0 {
				//    var16.Products = make([]string, 0, len(var15.Products))
				//    for _, var17 := range var15.Products {
				//        var16.Products = append(var16.Products, var17.ValueString())
				//    }
				//}
				input.Request.DataLossPrevention.Vendors = append(input.Request.DataLossPrevention.Vendors, var16)
			}
		}
	}

	input.Request.Description = state.Description.ValueStringPointer()

	if state.DiskBackup != nil {
		input.Request.DiskBackup = &suxdMuj.DiskBackupObject{}

		if state.DiskBackup.Criteria != nil {
			input.Request.DiskBackup.Criteria = &suxdMuj.DiskBackupCriteriaObject{}

			input.Request.DiskBackup.Criteria.IsInstalled = state.DiskBackup.Criteria.IsInstalled.ValueBoolPointer()

			if state.DiskBackup.Criteria.LastBackupTime != nil {
				input.Request.DiskBackup.Criteria.LastBackupTime = &suxdMuj.LastBackupTimeObject{}

				if !state.DiskBackup.Criteria.LastBackupTime.NotAvailable.IsNull() && state.DiskBackup.Criteria.LastBackupTime.NotAvailable.ValueBool() {
					input.Request.DiskBackup.Criteria.LastBackupTime.NotAvailable = map[string]interface{}{}
				}

				if state.DiskBackup.Criteria.LastBackupTime.NotWithin != nil {
					input.Request.DiskBackup.Criteria.LastBackupTime.NotWithin = &suxdMuj.LastBackupTimeNotWithinObject{}

					input.Request.DiskBackup.Criteria.LastBackupTime.NotWithin.Days = state.DiskBackup.Criteria.LastBackupTime.NotWithin.Days.ValueInt64Pointer()

					input.Request.DiskBackup.Criteria.LastBackupTime.NotWithin.Hours = state.DiskBackup.Criteria.LastBackupTime.NotWithin.Hours.ValueInt64Pointer()
				}

				if state.DiskBackup.Criteria.LastBackupTime.Within != nil {
					input.Request.DiskBackup.Criteria.LastBackupTime.Within = &suxdMuj.LastBackupTimeWithinObject{}

					input.Request.DiskBackup.Criteria.LastBackupTime.Within.Days = state.DiskBackup.Criteria.LastBackupTime.Within.Days.ValueInt64Pointer()

					input.Request.DiskBackup.Criteria.LastBackupTime.Within.Hours = state.DiskBackup.Criteria.LastBackupTime.Within.Hours.ValueInt64Pointer()
				}
			}
		}

		input.Request.DiskBackup.ExcludeVendor = state.DiskBackup.ExcludeVendor.ValueBoolPointer()

		if len(state.DiskBackup.Vendors) != 0 {
			input.Request.DiskBackup.Vendors = make([]suxdMuj.DiskBackupVendorObject, 0, len(state.DiskBackup.Vendors))
			for _, var18 := range state.DiskBackup.Vendors {
				var var19 suxdMuj.DiskBackupVendorObject

				var19.Name = var18.Name.ValueString()

				resp.Diagnostics.Append(var18.Products.ElementsAs(ctx, &var19.Products, false)...)
				//if len(var18.Products) != 0 {
				//    var19.Products = make([]string, 0, len(var18.Products))
				//    for _, var20 := range var18.Products {
				//        var19.Products = append(var19.Products, var20.ValueString())
				//    }
				//}
				input.Request.DiskBackup.Vendors = append(input.Request.DiskBackup.Vendors, var19)
			}
		}
	}

	if state.DiskEncryption != nil {
		input.Request.DiskEncryption = &suxdMuj.DiskEncryptionObject{}

		if state.DiskEncryption.Criteria != nil {
			input.Request.DiskEncryption.Criteria = &suxdMuj.DiskEncryptionCriteriaObject{}

			if len(state.DiskEncryption.Criteria.EncryptedLocations) != 0 {
				input.Request.DiskEncryption.Criteria.EncryptedLocations = make([]suxdMuj.EncryptedLocationObject, 0, len(state.DiskEncryption.Criteria.EncryptedLocations))
				for _, var21 := range state.DiskEncryption.Criteria.EncryptedLocations {
					var var22 suxdMuj.EncryptedLocationObject

					if var21.EncryptionState != nil {
						var22.EncryptionState = &suxdMuj.EncryptionStateObject{}

						var22.EncryptionState.Is = var21.EncryptionState.Is.ValueStringPointer()

						var22.EncryptionState.IsNot = var21.EncryptionState.IsNot.ValueStringPointer()
					}

					var22.Name = var21.Name.ValueString()
					input.Request.DiskEncryption.Criteria.EncryptedLocations = append(input.Request.DiskEncryption.Criteria.EncryptedLocations, var22)
				}
			}

			input.Request.DiskEncryption.Criteria.IsInstalled = state.DiskEncryption.Criteria.IsInstalled.ValueBoolPointer()
		}

		input.Request.DiskEncryption.ExcludeVendor = state.DiskEncryption.ExcludeVendor.ValueBoolPointer()

		if len(state.DiskEncryption.Vendors) != 0 {
			input.Request.DiskEncryption.Vendors = make([]suxdMuj.DiskEncryptionVendorObject, 0, len(state.DiskEncryption.Vendors))
			for _, var23 := range state.DiskEncryption.Vendors {
				var var24 suxdMuj.DiskEncryptionVendorObject

				var24.Name = var23.Name.ValueString()

				resp.Diagnostics.Append(var23.Products.ElementsAs(ctx, &var24.Products, false)...)
				//if len(var23.Products) != 0 {
				//    var24.Products = make([]string, 0, len(var23.Products))
				//    for _, var25 := range var23.Products {
				//        var24.Products = append(var24.Products, var25.ValueString())
				//    }
				//}
				input.Request.DiskEncryption.Vendors = append(input.Request.DiskEncryption.Vendors, var24)
			}
		}
	}

	if state.Firewall != nil {
		input.Request.Firewall = &suxdMuj.FirewallObject{}

		if state.Firewall.Criteria != nil {
			input.Request.Firewall.Criteria = &suxdMuj.FirewallCriteriaObject{}

			input.Request.Firewall.Criteria.IsEnabled = state.Firewall.Criteria.IsEnabled.ValueStringPointer()

			input.Request.Firewall.Criteria.IsInstalled = state.Firewall.Criteria.IsInstalled.ValueBoolPointer()
		}

		input.Request.Firewall.ExcludeVendor = state.Firewall.ExcludeVendor.ValueBoolPointer()

		if len(state.Firewall.Vendors) != 0 {
			input.Request.Firewall.Vendors = make([]suxdMuj.FirewallVendorObject, 0, len(state.Firewall.Vendors))
			for _, var26 := range state.Firewall.Vendors {
				var var27 suxdMuj.FirewallVendorObject

				var27.Name = var26.Name.ValueString()

				resp.Diagnostics.Append(var26.Products.ElementsAs(ctx, &var27.Products, false)...)
				//if len(var26.Products) != 0 {
				//    var27.Products = make([]string, 0, len(var26.Products))
				//    for _, var28 := range var26.Products {
				//        var27.Products = append(var27.Products, var28.ValueString())
				//    }
				//}
				input.Request.Firewall.Vendors = append(input.Request.Firewall.Vendors, var27)
			}
		}
	}

	if state.HostInfo != nil {
		input.Request.HostInfo = &suxdMuj.HostInfoObject{}

		if state.HostInfo.Criteria.ClientVersion != nil {
			input.Request.HostInfo.Criteria.ClientVersion = &suxdMuj.ClientVersionObject{}

			input.Request.HostInfo.Criteria.ClientVersion.Contains = state.HostInfo.Criteria.ClientVersion.Contains.ValueStringPointer()

			input.Request.HostInfo.Criteria.ClientVersion.Is = state.HostInfo.Criteria.ClientVersion.Is.ValueStringPointer()

			input.Request.HostInfo.Criteria.ClientVersion.IsNot = state.HostInfo.Criteria.ClientVersion.IsNot.ValueStringPointer()
		}

		if state.HostInfo.Criteria.Domain != nil {
			input.Request.HostInfo.Criteria.Domain = &suxdMuj.DomainObject{}

			input.Request.HostInfo.Criteria.Domain.Contains = state.HostInfo.Criteria.Domain.Contains.ValueStringPointer()

			input.Request.HostInfo.Criteria.Domain.Is = state.HostInfo.Criteria.Domain.Is.ValueStringPointer()

			input.Request.HostInfo.Criteria.Domain.IsNot = state.HostInfo.Criteria.Domain.IsNot.ValueStringPointer()
		}

		if state.HostInfo.Criteria.HostId != nil {
			input.Request.HostInfo.Criteria.HostId = &suxdMuj.HostIdObject{}

			input.Request.HostInfo.Criteria.HostId.Contains = state.HostInfo.Criteria.HostId.Contains.ValueStringPointer()

			input.Request.HostInfo.Criteria.HostId.Is = state.HostInfo.Criteria.HostId.Is.ValueStringPointer()

			input.Request.HostInfo.Criteria.HostId.IsNot = state.HostInfo.Criteria.HostId.IsNot.ValueStringPointer()
		}

		if state.HostInfo.Criteria.HostName != nil {
			input.Request.HostInfo.Criteria.HostName = &suxdMuj.HostNameObject{}

			input.Request.HostInfo.Criteria.HostName.Contains = state.HostInfo.Criteria.HostName.Contains.ValueStringPointer()

			input.Request.HostInfo.Criteria.HostName.Is = state.HostInfo.Criteria.HostName.Is.ValueStringPointer()

			input.Request.HostInfo.Criteria.HostName.IsNot = state.HostInfo.Criteria.HostName.IsNot.ValueStringPointer()
		}

		input.Request.HostInfo.Criteria.Managed = state.HostInfo.Criteria.Managed.ValueBoolPointer()

		if state.HostInfo.Criteria.Os != nil {
			input.Request.HostInfo.Criteria.Os = &suxdMuj.OsObject{}

			if state.HostInfo.Criteria.Os.Contains != nil {
				input.Request.HostInfo.Criteria.Os.Contains = &suxdMuj.ContainsObject{}

				input.Request.HostInfo.Criteria.Os.Contains.Apple = state.HostInfo.Criteria.Os.Contains.Apple.ValueStringPointer()

				input.Request.HostInfo.Criteria.Os.Contains.Google = state.HostInfo.Criteria.Os.Contains.Google.ValueStringPointer()

				input.Request.HostInfo.Criteria.Os.Contains.Linux = state.HostInfo.Criteria.Os.Contains.Linux.ValueStringPointer()

				input.Request.HostInfo.Criteria.Os.Contains.Microsoft = state.HostInfo.Criteria.Os.Contains.Microsoft.ValueStringPointer()

				input.Request.HostInfo.Criteria.Os.Contains.Other = state.HostInfo.Criteria.Os.Contains.Other.ValueStringPointer()
			}
		}

		if state.HostInfo.Criteria.SerialNumber != nil {
			input.Request.HostInfo.Criteria.SerialNumber = &suxdMuj.SerialNumberObject{}

			input.Request.HostInfo.Criteria.SerialNumber.Contains = state.HostInfo.Criteria.SerialNumber.Contains.ValueStringPointer()

			input.Request.HostInfo.Criteria.SerialNumber.Is = state.HostInfo.Criteria.SerialNumber.Is.ValueStringPointer()

			input.Request.HostInfo.Criteria.SerialNumber.IsNot = state.HostInfo.Criteria.SerialNumber.IsNot.ValueStringPointer()
		}
	}

	if state.MobileDevice != nil {
		input.Request.MobileDevice = &suxdMuj.MobileDeviceObject{}

		if state.MobileDevice.Criteria != nil {
			input.Request.MobileDevice.Criteria = &suxdMuj.MobileDeviceCriteriaObject{}

			if state.MobileDevice.Criteria.Applications != nil {
				input.Request.MobileDevice.Criteria.Applications = &suxdMuj.ApplicationsObject{}

				if state.MobileDevice.Criteria.Applications.HasMalware != nil {
					input.Request.MobileDevice.Criteria.Applications.HasMalware = &suxdMuj.HasMalwareObject{}

					if !state.MobileDevice.Criteria.Applications.HasMalware.No.IsNull() && state.MobileDevice.Criteria.Applications.HasMalware.No.ValueBool() {
						input.Request.MobileDevice.Criteria.Applications.HasMalware.No = map[string]interface{}{}
					}

					if state.MobileDevice.Criteria.Applications.HasMalware.Yes != nil {
						input.Request.MobileDevice.Criteria.Applications.HasMalware.Yes = &suxdMuj.YesObject{}

						if len(state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes) != 0 {
							input.Request.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = make([]suxdMuj.ExcludeObject, 0, len(state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes))
							for _, var29 := range state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes {
								var var30 suxdMuj.ExcludeObject

								var30.Hash = var29.Hash.ValueStringPointer()

								var30.Name = var29.Name.ValueString()

								var30.Package = var29.Package.ValueStringPointer()
								input.Request.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = append(input.Request.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes, var30)
							}
						}
					}
				}

				input.Request.MobileDevice.Criteria.Applications.HasUnmanagedApp = state.MobileDevice.Criteria.Applications.HasUnmanagedApp.ValueBoolPointer()

				if len(state.MobileDevice.Criteria.Applications.Includes) != 0 {
					input.Request.MobileDevice.Criteria.Applications.Includes = make([]suxdMuj.IncludeObject, 0, len(state.MobileDevice.Criteria.Applications.Includes))
					for _, var31 := range state.MobileDevice.Criteria.Applications.Includes {
						var var32 suxdMuj.IncludeObject

						var32.Hash = var31.Hash.ValueStringPointer()

						var32.Name = var31.Name.ValueString()

						var32.Package = var31.Package.ValueStringPointer()
						input.Request.MobileDevice.Criteria.Applications.Includes = append(input.Request.MobileDevice.Criteria.Applications.Includes, var32)
					}
				}
			}

			input.Request.MobileDevice.Criteria.DiskEncrypted = state.MobileDevice.Criteria.DiskEncrypted.ValueBoolPointer()

			if state.MobileDevice.Criteria.Imei != nil {
				input.Request.MobileDevice.Criteria.Imei = &suxdMuj.ImeiObject{}

				input.Request.MobileDevice.Criteria.Imei.Contains = state.MobileDevice.Criteria.Imei.Contains.ValueStringPointer()

				input.Request.MobileDevice.Criteria.Imei.Is = state.MobileDevice.Criteria.Imei.Is.ValueStringPointer()

				input.Request.MobileDevice.Criteria.Imei.IsNot = state.MobileDevice.Criteria.Imei.IsNot.ValueStringPointer()
			}

			input.Request.MobileDevice.Criteria.Jailbroken = state.MobileDevice.Criteria.Jailbroken.ValueBoolPointer()

			if state.MobileDevice.Criteria.LastCheckinTime != nil {
				input.Request.MobileDevice.Criteria.LastCheckinTime = &suxdMuj.LastCheckinTimeObject{}

				if state.MobileDevice.Criteria.LastCheckinTime.NotWithin != nil {
					input.Request.MobileDevice.Criteria.LastCheckinTime.NotWithin = &suxdMuj.LastCheckinTimeNotWithinObject{}

					input.Request.MobileDevice.Criteria.LastCheckinTime.NotWithin.Days = state.MobileDevice.Criteria.LastCheckinTime.NotWithin.Days.ValueInt64()
				}

				if state.MobileDevice.Criteria.LastCheckinTime.Within != nil {
					input.Request.MobileDevice.Criteria.LastCheckinTime.Within = &suxdMuj.LastCheckinTimeWithinObject{}

					input.Request.MobileDevice.Criteria.LastCheckinTime.Within.Days = state.MobileDevice.Criteria.LastCheckinTime.Within.Days.ValueInt64()
				}
			}

			if state.MobileDevice.Criteria.Model != nil {
				input.Request.MobileDevice.Criteria.Model = &suxdMuj.ModelObject{}

				input.Request.MobileDevice.Criteria.Model.Contains = state.MobileDevice.Criteria.Model.Contains.ValueStringPointer()

				input.Request.MobileDevice.Criteria.Model.Is = state.MobileDevice.Criteria.Model.Is.ValueStringPointer()

				input.Request.MobileDevice.Criteria.Model.IsNot = state.MobileDevice.Criteria.Model.IsNot.ValueStringPointer()
			}

			input.Request.MobileDevice.Criteria.PasscodeSet = state.MobileDevice.Criteria.PasscodeSet.ValueBoolPointer()

			if state.MobileDevice.Criteria.PhoneNumber != nil {
				input.Request.MobileDevice.Criteria.PhoneNumber = &suxdMuj.PhoneNumberObject{}

				input.Request.MobileDevice.Criteria.PhoneNumber.Contains = state.MobileDevice.Criteria.PhoneNumber.Contains.ValueStringPointer()

				input.Request.MobileDevice.Criteria.PhoneNumber.Is = state.MobileDevice.Criteria.PhoneNumber.Is.ValueStringPointer()

				input.Request.MobileDevice.Criteria.PhoneNumber.IsNot = state.MobileDevice.Criteria.PhoneNumber.IsNot.ValueStringPointer()
			}

			if state.MobileDevice.Criteria.Tag != nil {
				input.Request.MobileDevice.Criteria.Tag = &suxdMuj.TagObject{}

				input.Request.MobileDevice.Criteria.Tag.Contains = state.MobileDevice.Criteria.Tag.Contains.ValueStringPointer()

				input.Request.MobileDevice.Criteria.Tag.Is = state.MobileDevice.Criteria.Tag.Is.ValueStringPointer()

				input.Request.MobileDevice.Criteria.Tag.IsNot = state.MobileDevice.Criteria.Tag.IsNot.ValueStringPointer()
			}
		}
	}

	input.Request.Name = state.Name.ValueString()

	if state.NetworkInfo != nil {
		input.Request.NetworkInfo = &suxdMuj.NetworkInfoObject{}

		if state.NetworkInfo.Criteria != nil {
			input.Request.NetworkInfo.Criteria = &suxdMuj.NetworkInfoCriteriaObject{}

			if state.NetworkInfo.Criteria.Network != nil {
				input.Request.NetworkInfo.Criteria.Network = &suxdMuj.NetworkObject{}

				if state.NetworkInfo.Criteria.Network.Is != nil {
					input.Request.NetworkInfo.Criteria.Network.Is = &suxdMuj.IsObject{}

					if state.NetworkInfo.Criteria.Network.Is.Mobile != nil {
						input.Request.NetworkInfo.Criteria.Network.Is.Mobile = &suxdMuj.IsMobileObject{}

						input.Request.NetworkInfo.Criteria.Network.Is.Mobile.Carrier = state.NetworkInfo.Criteria.Network.Is.Mobile.Carrier.ValueStringPointer()
					}

					if !state.NetworkInfo.Criteria.Network.Is.Unknown.IsNull() && state.NetworkInfo.Criteria.Network.Is.Unknown.ValueBool() {
						input.Request.NetworkInfo.Criteria.Network.Is.Unknown = map[string]interface{}{}
					}

					if state.NetworkInfo.Criteria.Network.Is.Wifi != nil {
						input.Request.NetworkInfo.Criteria.Network.Is.Wifi = &suxdMuj.IsWifiObject{}

						input.Request.NetworkInfo.Criteria.Network.Is.Wifi.Ssid = state.NetworkInfo.Criteria.Network.Is.Wifi.Ssid.ValueStringPointer()
					}
				}

				if state.NetworkInfo.Criteria.Network.IsNot != nil {
					input.Request.NetworkInfo.Criteria.Network.IsNot = &suxdMuj.IsNotObject{}

					if !state.NetworkInfo.Criteria.Network.IsNot.Ethernet.IsNull() && state.NetworkInfo.Criteria.Network.IsNot.Ethernet.ValueBool() {
						input.Request.NetworkInfo.Criteria.Network.IsNot.Ethernet = map[string]interface{}{}
					}

					if state.NetworkInfo.Criteria.Network.IsNot.Mobile != nil {
						input.Request.NetworkInfo.Criteria.Network.IsNot.Mobile = &suxdMuj.IsNotMobileObject{}

						input.Request.NetworkInfo.Criteria.Network.IsNot.Mobile.Carrier = state.NetworkInfo.Criteria.Network.IsNot.Mobile.Carrier.ValueStringPointer()
					}

					if !state.NetworkInfo.Criteria.Network.IsNot.Unknown.IsNull() && state.NetworkInfo.Criteria.Network.IsNot.Unknown.ValueBool() {
						input.Request.NetworkInfo.Criteria.Network.IsNot.Unknown = map[string]interface{}{}
					}

					if state.NetworkInfo.Criteria.Network.IsNot.Wifi != nil {
						input.Request.NetworkInfo.Criteria.Network.IsNot.Wifi = &suxdMuj.IsNotWifiObject{}

						input.Request.NetworkInfo.Criteria.Network.IsNot.Wifi.Ssid = state.NetworkInfo.Criteria.Network.IsNot.Wifi.Ssid.ValueStringPointer()
					}
				}
			}
		}
	}

	if state.PatchManagement != nil {
		input.Request.PatchManagement = &suxdMuj.PatchManagementObject{}

		if state.PatchManagement.Criteria != nil {
			input.Request.PatchManagement.Criteria = &suxdMuj.CriteriaObject{}

			input.Request.PatchManagement.Criteria.IsEnabled = state.PatchManagement.Criteria.IsEnabled.ValueStringPointer()

			input.Request.PatchManagement.Criteria.IsInstalled = state.PatchManagement.Criteria.IsInstalled.ValueBoolPointer()

			if state.PatchManagement.Criteria.MissingPatches != nil {
				input.Request.PatchManagement.Criteria.MissingPatches = &suxdMuj.MissingPatchesObject{}

				input.Request.PatchManagement.Criteria.MissingPatches.Check = state.PatchManagement.Criteria.MissingPatches.Check.ValueString()

				resp.Diagnostics.Append(state.PatchManagement.Criteria.MissingPatches.Patches.ElementsAs(ctx, &input.Request.PatchManagement.Criteria.MissingPatches.Patches, false)...)
				//if len(state.PatchManagement.Criteria.MissingPatches.Patches) != 0 {
				//    input.Request.PatchManagement.Criteria.MissingPatches.Patches = make([]string, 0, len(state.PatchManagement.Criteria.MissingPatches.Patches))
				//    for _, var33 := range state.PatchManagement.Criteria.MissingPatches.Patches {
				//        input.Request.PatchManagement.Criteria.MissingPatches.Patches = append(input.Request.PatchManagement.Criteria.MissingPatches.Patches, var33.ValueString())
				//    }
				//}

				if state.PatchManagement.Criteria.MissingPatches.Severity != nil {
					input.Request.PatchManagement.Criteria.MissingPatches.Severity = &suxdMuj.SeverityObject{}

					input.Request.PatchManagement.Criteria.MissingPatches.Severity.GreaterEqual = state.PatchManagement.Criteria.MissingPatches.Severity.GreaterEqual.ValueInt64Pointer()

					input.Request.PatchManagement.Criteria.MissingPatches.Severity.GreaterThan = state.PatchManagement.Criteria.MissingPatches.Severity.GreaterThan.ValueInt64Pointer()

					input.Request.PatchManagement.Criteria.MissingPatches.Severity.Is = state.PatchManagement.Criteria.MissingPatches.Severity.Is.ValueInt64Pointer()

					input.Request.PatchManagement.Criteria.MissingPatches.Severity.IsNot = state.PatchManagement.Criteria.MissingPatches.Severity.IsNot.ValueInt64Pointer()

					input.Request.PatchManagement.Criteria.MissingPatches.Severity.LessEqual = state.PatchManagement.Criteria.MissingPatches.Severity.LessEqual.ValueInt64Pointer()

					input.Request.PatchManagement.Criteria.MissingPatches.Severity.LessThan = state.PatchManagement.Criteria.MissingPatches.Severity.LessThan.ValueInt64Pointer()
				}
			}
		}

		input.Request.PatchManagement.ExcludeVendor = state.PatchManagement.ExcludeVendor.ValueBoolPointer()

		if len(state.PatchManagement.Vendors) != 0 {
			input.Request.PatchManagement.Vendors = make([]suxdMuj.PatchManagementVendorObject, 0, len(state.PatchManagement.Vendors))
			for _, var34 := range state.PatchManagement.Vendors {
				var var35 suxdMuj.PatchManagementVendorObject

				var35.Name = var34.Name.ValueString()

				resp.Diagnostics.Append(var34.Products.ElementsAs(ctx, &var35.Products, false)...)
				//if len(var34.Products) != 0 {
				//    var35.Products = make([]string, 0, len(var34.Products))
				//    for _, var36 := range var34.Products {
				//        var35.Products = append(var35.Products, var36.ValueString())
				//    }
				//}
				input.Request.PatchManagement.Vendors = append(input.Request.PatchManagement.Vendors, var35)
			}
		}
	}

	// Perform the operation.
	ans, err := svc.Create(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error creating config", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	if input.Folder != nil {
		idBuilder.WriteString(*input.Folder)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Snippet != nil {
		idBuilder.WriteString(*input.Snippet)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Device != nil {
		idBuilder.WriteString(*input.Device)
	}

	idBuilder.WriteString(IdSeparator)
	if ans.Id == nil {
		resp.Diagnostics.AddError("Undefined param required for ID", "Id")
		return
	}
	if ans.Id != nil {
		idBuilder.WriteString(*ans.Id)
	}

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	if ans.AntiMalware == nil {
		state.AntiMalware = nil
	} else {
		state.AntiMalware = &hipObjectRsModel_suxdMuj_AntiMalwareObject{}

		if ans.AntiMalware.Criteria == nil {
			state.AntiMalware.Criteria = nil
		} else {
			state.AntiMalware.Criteria = &hipObjectRsModel_suxdMuj_AntiMalwareCriteriaObject{}

			state.AntiMalware.Criteria.IsInstalled = types.BoolPointerValue(ans.AntiMalware.Criteria.IsInstalled)

			if ans.AntiMalware.Criteria.LastScanTime == nil {
				state.AntiMalware.Criteria.LastScanTime = nil
			} else {
				state.AntiMalware.Criteria.LastScanTime = &hipObjectRsModel_suxdMuj_LastScanTimeObject{}

				if ans.AntiMalware.Criteria.LastScanTime.NotAvailable != nil {
					state.AntiMalware.Criteria.LastScanTime.NotAvailable = types.BoolValue(true)
				} else {
					state.AntiMalware.Criteria.LastScanTime.NotAvailable = types.BoolPointerValue(nil)
				}
				//state.AntiMalware.Criteria.LastScanTime.NotAvailable = types.BoolValue(ans.AntiMalware.Criteria.LastScanTime.NotAvailable != nil)

				if ans.AntiMalware.Criteria.LastScanTime.NotWithin == nil {
					state.AntiMalware.Criteria.LastScanTime.NotWithin = nil
				} else {
					state.AntiMalware.Criteria.LastScanTime.NotWithin = &hipObjectRsModel_suxdMuj_LastScanTimeNotWithinObject{}

					state.AntiMalware.Criteria.LastScanTime.NotWithin.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.NotWithin.Days)

					state.AntiMalware.Criteria.LastScanTime.NotWithin.Hours = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.NotWithin.Hours)
				}

				if ans.AntiMalware.Criteria.LastScanTime.Within == nil {
					state.AntiMalware.Criteria.LastScanTime.Within = nil
				} else {
					state.AntiMalware.Criteria.LastScanTime.Within = &hipObjectRsModel_suxdMuj_LastScanTimeWithinObject{}

					state.AntiMalware.Criteria.LastScanTime.Within.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.Within.Days)

					state.AntiMalware.Criteria.LastScanTime.Within.Hours = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.Within.Hours)
				}
			}

			if ans.AntiMalware.Criteria.ProductVersion == nil {
				state.AntiMalware.Criteria.ProductVersion = nil
			} else {
				state.AntiMalware.Criteria.ProductVersion = &hipObjectRsModel_suxdMuj_ProductVersionObject{}

				state.AntiMalware.Criteria.ProductVersion.Contains = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.Contains)

				state.AntiMalware.Criteria.ProductVersion.GreaterEqual = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.GreaterEqual)

				state.AntiMalware.Criteria.ProductVersion.GreaterThan = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.GreaterThan)

				state.AntiMalware.Criteria.ProductVersion.Is = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.Is)

				state.AntiMalware.Criteria.ProductVersion.IsNot = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.IsNot)

				state.AntiMalware.Criteria.ProductVersion.LessEqual = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.LessEqual)

				state.AntiMalware.Criteria.ProductVersion.LessThan = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.LessThan)

				if ans.AntiMalware.Criteria.ProductVersion.NotWithin == nil {
					state.AntiMalware.Criteria.ProductVersion.NotWithin = nil
				} else {
					state.AntiMalware.Criteria.ProductVersion.NotWithin = &hipObjectRsModel_suxdMuj_ProductVersionNotWithinObject{}

					state.AntiMalware.Criteria.ProductVersion.NotWithin.Versions = types.Int64Value(ans.AntiMalware.Criteria.ProductVersion.NotWithin.Versions)
				}

				if ans.AntiMalware.Criteria.ProductVersion.Within == nil {
					state.AntiMalware.Criteria.ProductVersion.Within = nil
				} else {
					state.AntiMalware.Criteria.ProductVersion.Within = &hipObjectRsModel_suxdMuj_ProductVersionWithinObject{}

					state.AntiMalware.Criteria.ProductVersion.Within.Versions = types.Int64Value(ans.AntiMalware.Criteria.ProductVersion.Within.Versions)
				}
			}

			state.AntiMalware.Criteria.RealTimeProtection = types.StringPointerValue(ans.AntiMalware.Criteria.RealTimeProtection)

			if ans.AntiMalware.Criteria.VirdefVersion == nil {
				state.AntiMalware.Criteria.VirdefVersion = nil
			} else {
				state.AntiMalware.Criteria.VirdefVersion = &hipObjectRsModel_suxdMuj_VirdefVersionObject{}

				if ans.AntiMalware.Criteria.VirdefVersion.NotWithin == nil {
					state.AntiMalware.Criteria.VirdefVersion.NotWithin = nil
				} else {
					state.AntiMalware.Criteria.VirdefVersion.NotWithin = &hipObjectRsModel_suxdMuj_VirdefVersionNotWithinObject{}

					state.AntiMalware.Criteria.VirdefVersion.NotWithin.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.NotWithin.Days)

					state.AntiMalware.Criteria.VirdefVersion.NotWithin.Versions = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.NotWithin.Versions)
				}

				if ans.AntiMalware.Criteria.VirdefVersion.Within == nil {
					state.AntiMalware.Criteria.VirdefVersion.Within = nil
				} else {
					state.AntiMalware.Criteria.VirdefVersion.Within = &hipObjectRsModel_suxdMuj_VirdefVersionWithinObject{}

					state.AntiMalware.Criteria.VirdefVersion.Within.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.Within.Days)

					state.AntiMalware.Criteria.VirdefVersion.Within.Versions = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.Within.Versions)
				}
			}
		}

		state.AntiMalware.ExcludeVendor = types.BoolPointerValue(ans.AntiMalware.ExcludeVendor)

		if len(ans.AntiMalware.Vendors) == 0 {
			state.AntiMalware.Vendors = nil
		} else {
			state.AntiMalware.Vendors = make([]hipObjectRsModel_suxdMuj_AntiMalwareVendorObject, 0, len(ans.AntiMalware.Vendors))
			for _, var37 := range ans.AntiMalware.Vendors {
				var38 := hipObjectRsModel_suxdMuj_AntiMalwareVendorObject{}

				var38.Name = types.StringValue(var37.Name)

				var39, var40 := types.ListValueFrom(ctx, types.StringType, var37.Products)
				var38.Products = var39
				resp.Diagnostics.Append(var40.Errors()...)
				state.AntiMalware.Vendors = append(state.AntiMalware.Vendors, var38)
			}
		}
	}

	if ans.Certificate == nil {
		state.Certificate = nil
	} else {
		state.Certificate = &hipObjectRsModel_suxdMuj_CertificateObject{}

		if ans.Certificate.Criteria == nil {
			state.Certificate.Criteria = nil
		} else {
			state.Certificate.Criteria = &hipObjectRsModel_suxdMuj_CertificateCriteriaObject{}

			if len(ans.Certificate.Criteria.CertificateAttributes) == 0 {
				state.Certificate.Criteria.CertificateAttributes = nil
			} else {
				state.Certificate.Criteria.CertificateAttributes = make([]hipObjectRsModel_suxdMuj_CertificateAttributeObject, 0, len(ans.Certificate.Criteria.CertificateAttributes))
				for _, var41 := range ans.Certificate.Criteria.CertificateAttributes {
					var42 := hipObjectRsModel_suxdMuj_CertificateAttributeObject{}

					var42.Name = types.StringValue(var41.Name)

					var42.Value = types.StringPointerValue(var41.Value)
					state.Certificate.Criteria.CertificateAttributes = append(state.Certificate.Criteria.CertificateAttributes, var42)
				}
			}

			state.Certificate.Criteria.CertificateProfile = types.StringPointerValue(ans.Certificate.Criteria.CertificateProfile)
		}
	}

	if ans.CustomChecks == nil {
		state.CustomChecks = nil
	} else {
		state.CustomChecks = &hipObjectRsModel_suxdMuj_CustomChecksObject{}

		state.CustomChecks.Criteria = hipObjectRsModel_suxdMuj_CustomChecksCriteriaObject{}

		if len(ans.CustomChecks.Criteria.Plist) == 0 {
			state.CustomChecks.Criteria.Plist = nil
		} else {
			state.CustomChecks.Criteria.Plist = make([]hipObjectRsModel_suxdMuj_PlistObject, 0, len(ans.CustomChecks.Criteria.Plist))
			for _, var43 := range ans.CustomChecks.Criteria.Plist {
				var44 := hipObjectRsModel_suxdMuj_PlistObject{}

				if len(var43.Keys) == 0 {
					var44.Keys = nil
				} else {
					var44.Keys = make([]hipObjectRsModel_suxdMuj_KeyObject, 0, len(var43.Keys))
					for _, var45 := range var43.Keys {
						var46 := hipObjectRsModel_suxdMuj_KeyObject{}

						var46.Name = types.StringValue(var45.Name)

						var46.Negate = types.BoolPointerValue(var45.Negate)

						var46.Value = types.StringPointerValue(var45.Value)
						var44.Keys = append(var44.Keys, var46)
					}
				}

				var44.Name = types.StringValue(var43.Name)

				var44.Negate = types.BoolPointerValue(var43.Negate)
				state.CustomChecks.Criteria.Plist = append(state.CustomChecks.Criteria.Plist, var44)
			}
		}

		if len(ans.CustomChecks.Criteria.ProcessList) == 0 {
			state.CustomChecks.Criteria.ProcessList = nil
		} else {
			state.CustomChecks.Criteria.ProcessList = make([]hipObjectRsModel_suxdMuj_ProcessListObject, 0, len(ans.CustomChecks.Criteria.ProcessList))
			for _, var47 := range ans.CustomChecks.Criteria.ProcessList {
				var48 := hipObjectRsModel_suxdMuj_ProcessListObject{}

				var48.Name = types.StringValue(var47.Name)

				var48.Running = types.BoolPointerValue(var47.Running)
				state.CustomChecks.Criteria.ProcessList = append(state.CustomChecks.Criteria.ProcessList, var48)
			}
		}

		if len(ans.CustomChecks.Criteria.RegistryKeys) == 0 {
			state.CustomChecks.Criteria.RegistryKeys = nil
		} else {
			state.CustomChecks.Criteria.RegistryKeys = make([]hipObjectRsModel_suxdMuj_RegistryKeyObject, 0, len(ans.CustomChecks.Criteria.RegistryKeys))
			for _, var49 := range ans.CustomChecks.Criteria.RegistryKeys {
				var50 := hipObjectRsModel_suxdMuj_RegistryKeyObject{}

				var50.DefaultValueData = types.StringPointerValue(var49.DefaultValueData)

				var50.Name = types.StringValue(var49.Name)

				var50.Negate = types.BoolPointerValue(var49.Negate)

				if len(var49.RegistryValues) == 0 {
					var50.RegistryValues = nil
				} else {
					var50.RegistryValues = make([]hipObjectRsModel_suxdMuj_RegistryValueObject, 0, len(var49.RegistryValues))
					for _, var51 := range var49.RegistryValues {
						var52 := hipObjectRsModel_suxdMuj_RegistryValueObject{}

						var52.Name = types.StringValue(var51.Name)

						var52.Negate = types.BoolPointerValue(var51.Negate)

						var52.ValueData = types.StringPointerValue(var51.ValueData)
						var50.RegistryValues = append(var50.RegistryValues, var52)
					}
				}
				state.CustomChecks.Criteria.RegistryKeys = append(state.CustomChecks.Criteria.RegistryKeys, var50)
			}
		}
	}

	if ans.DataLossPrevention == nil {
		state.DataLossPrevention = nil
	} else {
		state.DataLossPrevention = &hipObjectRsModel_suxdMuj_DataLossPreventionObject{}

		if ans.DataLossPrevention.Criteria == nil {
			state.DataLossPrevention.Criteria = nil
		} else {
			state.DataLossPrevention.Criteria = &hipObjectRsModel_suxdMuj_DataLossPreventionCriteriaObject{}

			state.DataLossPrevention.Criteria.IsEnabled = types.StringPointerValue(ans.DataLossPrevention.Criteria.IsEnabled)

			state.DataLossPrevention.Criteria.IsInstalled = types.BoolPointerValue(ans.DataLossPrevention.Criteria.IsInstalled)
		}

		state.DataLossPrevention.ExcludeVendor = types.BoolPointerValue(ans.DataLossPrevention.ExcludeVendor)

		if len(ans.DataLossPrevention.Vendors) == 0 {
			state.DataLossPrevention.Vendors = nil
		} else {
			state.DataLossPrevention.Vendors = make([]hipObjectRsModel_suxdMuj_DataLossPreventionVendorObject, 0, len(ans.DataLossPrevention.Vendors))
			for _, var53 := range ans.DataLossPrevention.Vendors {
				var54 := hipObjectRsModel_suxdMuj_DataLossPreventionVendorObject{}

				var54.Name = types.StringValue(var53.Name)

				var55, var56 := types.ListValueFrom(ctx, types.StringType, var53.Products)
				var54.Products = var55
				resp.Diagnostics.Append(var56.Errors()...)
				state.DataLossPrevention.Vendors = append(state.DataLossPrevention.Vendors, var54)
			}
		}
	}

	state.Description = types.StringPointerValue(ans.Description)

	if ans.DiskBackup == nil {
		state.DiskBackup = nil
	} else {
		state.DiskBackup = &hipObjectRsModel_suxdMuj_DiskBackupObject{}

		if ans.DiskBackup.Criteria == nil {
			state.DiskBackup.Criteria = nil
		} else {
			state.DiskBackup.Criteria = &hipObjectRsModel_suxdMuj_DiskBackupCriteriaObject{}

			state.DiskBackup.Criteria.IsInstalled = types.BoolPointerValue(ans.DiskBackup.Criteria.IsInstalled)

			if ans.DiskBackup.Criteria.LastBackupTime == nil {
				state.DiskBackup.Criteria.LastBackupTime = nil
			} else {
				state.DiskBackup.Criteria.LastBackupTime = &hipObjectRsModel_suxdMuj_LastBackupTimeObject{}

				if ans.DiskBackup.Criteria.LastBackupTime.NotAvailable != nil {
					state.DiskBackup.Criteria.LastBackupTime.NotAvailable = types.BoolValue(true)
				} else {
					state.DiskBackup.Criteria.LastBackupTime.NotAvailable = types.BoolPointerValue(nil)
				}
				//state.DiskBackup.Criteria.LastBackupTime.NotAvailable = types.BoolValue(ans.DiskBackup.Criteria.LastBackupTime.NotAvailable != nil)

				if ans.DiskBackup.Criteria.LastBackupTime.NotWithin == nil {
					state.DiskBackup.Criteria.LastBackupTime.NotWithin = nil
				} else {
					state.DiskBackup.Criteria.LastBackupTime.NotWithin = &hipObjectRsModel_suxdMuj_LastBackupTimeNotWithinObject{}

					state.DiskBackup.Criteria.LastBackupTime.NotWithin.Days = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.NotWithin.Days)

					state.DiskBackup.Criteria.LastBackupTime.NotWithin.Hours = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.NotWithin.Hours)
				}

				if ans.DiskBackup.Criteria.LastBackupTime.Within == nil {
					state.DiskBackup.Criteria.LastBackupTime.Within = nil
				} else {
					state.DiskBackup.Criteria.LastBackupTime.Within = &hipObjectRsModel_suxdMuj_LastBackupTimeWithinObject{}

					state.DiskBackup.Criteria.LastBackupTime.Within.Days = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.Within.Days)

					state.DiskBackup.Criteria.LastBackupTime.Within.Hours = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.Within.Hours)
				}
			}
		}

		state.DiskBackup.ExcludeVendor = types.BoolPointerValue(ans.DiskBackup.ExcludeVendor)

		if len(ans.DiskBackup.Vendors) == 0 {
			state.DiskBackup.Vendors = nil
		} else {
			state.DiskBackup.Vendors = make([]hipObjectRsModel_suxdMuj_DiskBackupVendorObject, 0, len(ans.DiskBackup.Vendors))
			for _, var57 := range ans.DiskBackup.Vendors {
				var58 := hipObjectRsModel_suxdMuj_DiskBackupVendorObject{}

				var58.Name = types.StringValue(var57.Name)

				var59, var60 := types.ListValueFrom(ctx, types.StringType, var57.Products)
				var58.Products = var59
				resp.Diagnostics.Append(var60.Errors()...)
				state.DiskBackup.Vendors = append(state.DiskBackup.Vendors, var58)
			}
		}
	}

	if ans.DiskEncryption == nil {
		state.DiskEncryption = nil
	} else {
		state.DiskEncryption = &hipObjectRsModel_suxdMuj_DiskEncryptionObject{}

		if ans.DiskEncryption.Criteria == nil {
			state.DiskEncryption.Criteria = nil
		} else {
			state.DiskEncryption.Criteria = &hipObjectRsModel_suxdMuj_DiskEncryptionCriteriaObject{}

			if len(ans.DiskEncryption.Criteria.EncryptedLocations) == 0 {
				state.DiskEncryption.Criteria.EncryptedLocations = nil
			} else {
				state.DiskEncryption.Criteria.EncryptedLocations = make([]hipObjectRsModel_suxdMuj_EncryptedLocationObject, 0, len(ans.DiskEncryption.Criteria.EncryptedLocations))
				for _, var61 := range ans.DiskEncryption.Criteria.EncryptedLocations {
					var62 := hipObjectRsModel_suxdMuj_EncryptedLocationObject{}

					if var61.EncryptionState == nil {
						var62.EncryptionState = nil
					} else {
						var62.EncryptionState = &hipObjectRsModel_suxdMuj_EncryptionStateObject{}

						var62.EncryptionState.Is = types.StringPointerValue(var61.EncryptionState.Is)

						var62.EncryptionState.IsNot = types.StringPointerValue(var61.EncryptionState.IsNot)
					}

					var62.Name = types.StringValue(var61.Name)
					state.DiskEncryption.Criteria.EncryptedLocations = append(state.DiskEncryption.Criteria.EncryptedLocations, var62)
				}
			}

			state.DiskEncryption.Criteria.IsInstalled = types.BoolPointerValue(ans.DiskEncryption.Criteria.IsInstalled)
		}

		state.DiskEncryption.ExcludeVendor = types.BoolPointerValue(ans.DiskEncryption.ExcludeVendor)

		if len(ans.DiskEncryption.Vendors) == 0 {
			state.DiskEncryption.Vendors = nil
		} else {
			state.DiskEncryption.Vendors = make([]hipObjectRsModel_suxdMuj_DiskEncryptionVendorObject, 0, len(ans.DiskEncryption.Vendors))
			for _, var63 := range ans.DiskEncryption.Vendors {
				var64 := hipObjectRsModel_suxdMuj_DiskEncryptionVendorObject{}

				var64.Name = types.StringValue(var63.Name)

				var65, var66 := types.ListValueFrom(ctx, types.StringType, var63.Products)
				var64.Products = var65
				resp.Diagnostics.Append(var66.Errors()...)
				state.DiskEncryption.Vendors = append(state.DiskEncryption.Vendors, var64)
			}
		}
	}

	if ans.Firewall == nil {
		state.Firewall = nil
	} else {
		state.Firewall = &hipObjectRsModel_suxdMuj_FirewallObject{}

		if ans.Firewall.Criteria == nil {
			state.Firewall.Criteria = nil
		} else {
			state.Firewall.Criteria = &hipObjectRsModel_suxdMuj_FirewallCriteriaObject{}

			state.Firewall.Criteria.IsEnabled = types.StringPointerValue(ans.Firewall.Criteria.IsEnabled)

			state.Firewall.Criteria.IsInstalled = types.BoolPointerValue(ans.Firewall.Criteria.IsInstalled)
		}

		state.Firewall.ExcludeVendor = types.BoolPointerValue(ans.Firewall.ExcludeVendor)

		if len(ans.Firewall.Vendors) == 0 {
			state.Firewall.Vendors = nil
		} else {
			state.Firewall.Vendors = make([]hipObjectRsModel_suxdMuj_FirewallVendorObject, 0, len(ans.Firewall.Vendors))
			for _, var67 := range ans.Firewall.Vendors {
				var68 := hipObjectRsModel_suxdMuj_FirewallVendorObject{}

				var68.Name = types.StringValue(var67.Name)

				var69, var70 := types.ListValueFrom(ctx, types.StringType, var67.Products)
				var68.Products = var69
				resp.Diagnostics.Append(var70.Errors()...)
				state.Firewall.Vendors = append(state.Firewall.Vendors, var68)
			}
		}
	}

	if ans.HostInfo == nil {
		state.HostInfo = nil
	} else {
		state.HostInfo = &hipObjectRsModel_suxdMuj_HostInfoObject{}

		state.HostInfo.Criteria = hipObjectRsModel_suxdMuj_HostInfoCriteriaObject{}

		if ans.HostInfo.Criteria.ClientVersion == nil {
			state.HostInfo.Criteria.ClientVersion = nil
		} else {
			state.HostInfo.Criteria.ClientVersion = &hipObjectRsModel_suxdMuj_ClientVersionObject{}

			state.HostInfo.Criteria.ClientVersion.Contains = types.StringPointerValue(ans.HostInfo.Criteria.ClientVersion.Contains)

			state.HostInfo.Criteria.ClientVersion.Is = types.StringPointerValue(ans.HostInfo.Criteria.ClientVersion.Is)

			state.HostInfo.Criteria.ClientVersion.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.ClientVersion.IsNot)
		}

		if ans.HostInfo.Criteria.Domain == nil {
			state.HostInfo.Criteria.Domain = nil
		} else {
			state.HostInfo.Criteria.Domain = &hipObjectRsModel_suxdMuj_DomainObject{}

			state.HostInfo.Criteria.Domain.Contains = types.StringPointerValue(ans.HostInfo.Criteria.Domain.Contains)

			state.HostInfo.Criteria.Domain.Is = types.StringPointerValue(ans.HostInfo.Criteria.Domain.Is)

			state.HostInfo.Criteria.Domain.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.Domain.IsNot)
		}

		if ans.HostInfo.Criteria.HostId == nil {
			state.HostInfo.Criteria.HostId = nil
		} else {
			state.HostInfo.Criteria.HostId = &hipObjectRsModel_suxdMuj_HostIdObject{}

			state.HostInfo.Criteria.HostId.Contains = types.StringPointerValue(ans.HostInfo.Criteria.HostId.Contains)

			state.HostInfo.Criteria.HostId.Is = types.StringPointerValue(ans.HostInfo.Criteria.HostId.Is)

			state.HostInfo.Criteria.HostId.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.HostId.IsNot)
		}

		if ans.HostInfo.Criteria.HostName == nil {
			state.HostInfo.Criteria.HostName = nil
		} else {
			state.HostInfo.Criteria.HostName = &hipObjectRsModel_suxdMuj_HostNameObject{}

			state.HostInfo.Criteria.HostName.Contains = types.StringPointerValue(ans.HostInfo.Criteria.HostName.Contains)

			state.HostInfo.Criteria.HostName.Is = types.StringPointerValue(ans.HostInfo.Criteria.HostName.Is)

			state.HostInfo.Criteria.HostName.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.HostName.IsNot)
		}

		state.HostInfo.Criteria.Managed = types.BoolPointerValue(ans.HostInfo.Criteria.Managed)

		if ans.HostInfo.Criteria.Os == nil {
			state.HostInfo.Criteria.Os = nil
		} else {
			state.HostInfo.Criteria.Os = &hipObjectRsModel_suxdMuj_OsObject{}

			if ans.HostInfo.Criteria.Os.Contains == nil {
				state.HostInfo.Criteria.Os.Contains = nil
			} else {
				state.HostInfo.Criteria.Os.Contains = &hipObjectRsModel_suxdMuj_ContainsObject{}

				state.HostInfo.Criteria.Os.Contains.Apple = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Apple)

				state.HostInfo.Criteria.Os.Contains.Google = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Google)

				state.HostInfo.Criteria.Os.Contains.Linux = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Linux)

				state.HostInfo.Criteria.Os.Contains.Microsoft = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Microsoft)

				state.HostInfo.Criteria.Os.Contains.Other = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Other)
			}
		}

		if ans.HostInfo.Criteria.SerialNumber == nil {
			state.HostInfo.Criteria.SerialNumber = nil
		} else {
			state.HostInfo.Criteria.SerialNumber = &hipObjectRsModel_suxdMuj_SerialNumberObject{}

			state.HostInfo.Criteria.SerialNumber.Contains = types.StringPointerValue(ans.HostInfo.Criteria.SerialNumber.Contains)

			state.HostInfo.Criteria.SerialNumber.Is = types.StringPointerValue(ans.HostInfo.Criteria.SerialNumber.Is)

			state.HostInfo.Criteria.SerialNumber.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.SerialNumber.IsNot)
		}
	}

	state.Id = types.StringPointerValue(ans.Id)

	if ans.MobileDevice == nil {
		state.MobileDevice = nil
	} else {
		state.MobileDevice = &hipObjectRsModel_suxdMuj_MobileDeviceObject{}

		if ans.MobileDevice.Criteria == nil {
			state.MobileDevice.Criteria = nil
		} else {
			state.MobileDevice.Criteria = &hipObjectRsModel_suxdMuj_MobileDeviceCriteriaObject{}

			if ans.MobileDevice.Criteria.Applications == nil {
				state.MobileDevice.Criteria.Applications = nil
			} else {
				state.MobileDevice.Criteria.Applications = &hipObjectRsModel_suxdMuj_ApplicationsObject{}

				if ans.MobileDevice.Criteria.Applications.HasMalware == nil {
					state.MobileDevice.Criteria.Applications.HasMalware = nil
				} else {
					state.MobileDevice.Criteria.Applications.HasMalware = &hipObjectRsModel_suxdMuj_HasMalwareObject{}

					if ans.MobileDevice.Criteria.Applications.HasMalware.No != nil {
						state.MobileDevice.Criteria.Applications.HasMalware.No = types.BoolValue(true)
					} else {
						state.MobileDevice.Criteria.Applications.HasMalware.No = types.BoolPointerValue(nil)
					}
					//state.MobileDevice.Criteria.Applications.HasMalware.No = types.BoolValue(ans.MobileDevice.Criteria.Applications.HasMalware.No != nil)

					if ans.MobileDevice.Criteria.Applications.HasMalware.Yes == nil {
						state.MobileDevice.Criteria.Applications.HasMalware.Yes = nil
					} else {
						state.MobileDevice.Criteria.Applications.HasMalware.Yes = &hipObjectRsModel_suxdMuj_YesObject{}

						if len(ans.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes) == 0 {
							state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = nil
						} else {
							state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = make([]hipObjectRsModel_suxdMuj_ExcludeObject, 0, len(ans.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes))
							for _, var71 := range ans.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes {
								var72 := hipObjectRsModel_suxdMuj_ExcludeObject{}

								var72.Hash = types.StringPointerValue(var71.Hash)

								var72.Name = types.StringValue(var71.Name)

								var72.Package = types.StringPointerValue(var71.Package)
								state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = append(state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes, var72)
							}
						}
					}
				}

				state.MobileDevice.Criteria.Applications.HasUnmanagedApp = types.BoolPointerValue(ans.MobileDevice.Criteria.Applications.HasUnmanagedApp)

				if len(ans.MobileDevice.Criteria.Applications.Includes) == 0 {
					state.MobileDevice.Criteria.Applications.Includes = nil
				} else {
					state.MobileDevice.Criteria.Applications.Includes = make([]hipObjectRsModel_suxdMuj_IncludeObject, 0, len(ans.MobileDevice.Criteria.Applications.Includes))
					for _, var73 := range ans.MobileDevice.Criteria.Applications.Includes {
						var74 := hipObjectRsModel_suxdMuj_IncludeObject{}

						var74.Hash = types.StringPointerValue(var73.Hash)

						var74.Name = types.StringValue(var73.Name)

						var74.Package = types.StringPointerValue(var73.Package)
						state.MobileDevice.Criteria.Applications.Includes = append(state.MobileDevice.Criteria.Applications.Includes, var74)
					}
				}
			}

			state.MobileDevice.Criteria.DiskEncrypted = types.BoolPointerValue(ans.MobileDevice.Criteria.DiskEncrypted)

			if ans.MobileDevice.Criteria.Imei == nil {
				state.MobileDevice.Criteria.Imei = nil
			} else {
				state.MobileDevice.Criteria.Imei = &hipObjectRsModel_suxdMuj_ImeiObject{}

				state.MobileDevice.Criteria.Imei.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.Imei.Contains)

				state.MobileDevice.Criteria.Imei.Is = types.StringPointerValue(ans.MobileDevice.Criteria.Imei.Is)

				state.MobileDevice.Criteria.Imei.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.Imei.IsNot)
			}

			state.MobileDevice.Criteria.Jailbroken = types.BoolPointerValue(ans.MobileDevice.Criteria.Jailbroken)

			if ans.MobileDevice.Criteria.LastCheckinTime == nil {
				state.MobileDevice.Criteria.LastCheckinTime = nil
			} else {
				state.MobileDevice.Criteria.LastCheckinTime = &hipObjectRsModel_suxdMuj_LastCheckinTimeObject{}

				if ans.MobileDevice.Criteria.LastCheckinTime.NotWithin == nil {
					state.MobileDevice.Criteria.LastCheckinTime.NotWithin = nil
				} else {
					state.MobileDevice.Criteria.LastCheckinTime.NotWithin = &hipObjectRsModel_suxdMuj_LastCheckinTimeNotWithinObject{}

					state.MobileDevice.Criteria.LastCheckinTime.NotWithin.Days = types.Int64Value(ans.MobileDevice.Criteria.LastCheckinTime.NotWithin.Days)
				}

				if ans.MobileDevice.Criteria.LastCheckinTime.Within == nil {
					state.MobileDevice.Criteria.LastCheckinTime.Within = nil
				} else {
					state.MobileDevice.Criteria.LastCheckinTime.Within = &hipObjectRsModel_suxdMuj_LastCheckinTimeWithinObject{}

					state.MobileDevice.Criteria.LastCheckinTime.Within.Days = types.Int64Value(ans.MobileDevice.Criteria.LastCheckinTime.Within.Days)
				}
			}

			if ans.MobileDevice.Criteria.Model == nil {
				state.MobileDevice.Criteria.Model = nil
			} else {
				state.MobileDevice.Criteria.Model = &hipObjectRsModel_suxdMuj_ModelObject{}

				state.MobileDevice.Criteria.Model.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.Model.Contains)

				state.MobileDevice.Criteria.Model.Is = types.StringPointerValue(ans.MobileDevice.Criteria.Model.Is)

				state.MobileDevice.Criteria.Model.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.Model.IsNot)
			}

			state.MobileDevice.Criteria.PasscodeSet = types.BoolPointerValue(ans.MobileDevice.Criteria.PasscodeSet)

			if ans.MobileDevice.Criteria.PhoneNumber == nil {
				state.MobileDevice.Criteria.PhoneNumber = nil
			} else {
				state.MobileDevice.Criteria.PhoneNumber = &hipObjectRsModel_suxdMuj_PhoneNumberObject{}

				state.MobileDevice.Criteria.PhoneNumber.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.PhoneNumber.Contains)

				state.MobileDevice.Criteria.PhoneNumber.Is = types.StringPointerValue(ans.MobileDevice.Criteria.PhoneNumber.Is)

				state.MobileDevice.Criteria.PhoneNumber.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.PhoneNumber.IsNot)
			}

			if ans.MobileDevice.Criteria.Tag == nil {
				state.MobileDevice.Criteria.Tag = nil
			} else {
				state.MobileDevice.Criteria.Tag = &hipObjectRsModel_suxdMuj_TagObject{}

				state.MobileDevice.Criteria.Tag.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.Tag.Contains)

				state.MobileDevice.Criteria.Tag.Is = types.StringPointerValue(ans.MobileDevice.Criteria.Tag.Is)

				state.MobileDevice.Criteria.Tag.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.Tag.IsNot)
			}
		}
	}

	state.Name = types.StringValue(ans.Name)

	if ans.NetworkInfo == nil {
		state.NetworkInfo = nil
	} else {
		state.NetworkInfo = &hipObjectRsModel_suxdMuj_NetworkInfoObject{}

		if ans.NetworkInfo.Criteria == nil {
			state.NetworkInfo.Criteria = nil
		} else {
			state.NetworkInfo.Criteria = &hipObjectRsModel_suxdMuj_NetworkInfoCriteriaObject{}

			if ans.NetworkInfo.Criteria.Network == nil {
				state.NetworkInfo.Criteria.Network = nil
			} else {
				state.NetworkInfo.Criteria.Network = &hipObjectRsModel_suxdMuj_NetworkObject{}

				if ans.NetworkInfo.Criteria.Network.Is == nil {
					state.NetworkInfo.Criteria.Network.Is = nil
				} else {
					state.NetworkInfo.Criteria.Network.Is = &hipObjectRsModel_suxdMuj_IsObject{}

					if ans.NetworkInfo.Criteria.Network.Is.Mobile == nil {
						state.NetworkInfo.Criteria.Network.Is.Mobile = nil
					} else {
						state.NetworkInfo.Criteria.Network.Is.Mobile = &hipObjectRsModel_suxdMuj_IsMobileObject{}

						state.NetworkInfo.Criteria.Network.Is.Mobile.Carrier = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.Is.Mobile.Carrier)
					}

					if ans.NetworkInfo.Criteria.Network.Is.Unknown != nil {
						state.NetworkInfo.Criteria.Network.Is.Unknown = types.BoolValue(true)
					} else {
						state.NetworkInfo.Criteria.Network.Is.Unknown = types.BoolPointerValue(nil)
					}
					//state.NetworkInfo.Criteria.Network.Is.Unknown = types.BoolValue(ans.NetworkInfo.Criteria.Network.Is.Unknown != nil)

					if ans.NetworkInfo.Criteria.Network.Is.Wifi == nil {
						state.NetworkInfo.Criteria.Network.Is.Wifi = nil
					} else {
						state.NetworkInfo.Criteria.Network.Is.Wifi = &hipObjectRsModel_suxdMuj_IsWifiObject{}

						state.NetworkInfo.Criteria.Network.Is.Wifi.Ssid = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.Is.Wifi.Ssid)
					}
				}

				if ans.NetworkInfo.Criteria.Network.IsNot == nil {
					state.NetworkInfo.Criteria.Network.IsNot = nil
				} else {
					state.NetworkInfo.Criteria.Network.IsNot = &hipObjectRsModel_suxdMuj_IsNotObject{}

					if ans.NetworkInfo.Criteria.Network.IsNot.Ethernet != nil {
						state.NetworkInfo.Criteria.Network.IsNot.Ethernet = types.BoolValue(true)
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Ethernet = types.BoolPointerValue(nil)
					}
					//state.NetworkInfo.Criteria.Network.IsNot.Ethernet = types.BoolValue(ans.NetworkInfo.Criteria.Network.IsNot.Ethernet != nil)

					if ans.NetworkInfo.Criteria.Network.IsNot.Mobile == nil {
						state.NetworkInfo.Criteria.Network.IsNot.Mobile = nil
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Mobile = &hipObjectRsModel_suxdMuj_IsNotMobileObject{}

						state.NetworkInfo.Criteria.Network.IsNot.Mobile.Carrier = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.IsNot.Mobile.Carrier)
					}

					if ans.NetworkInfo.Criteria.Network.IsNot.Unknown != nil {
						state.NetworkInfo.Criteria.Network.IsNot.Unknown = types.BoolValue(true)
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Unknown = types.BoolPointerValue(nil)
					}
					//state.NetworkInfo.Criteria.Network.IsNot.Unknown = types.BoolValue(ans.NetworkInfo.Criteria.Network.IsNot.Unknown != nil)

					if ans.NetworkInfo.Criteria.Network.IsNot.Wifi == nil {
						state.NetworkInfo.Criteria.Network.IsNot.Wifi = nil
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Wifi = &hipObjectRsModel_suxdMuj_IsNotWifiObject{}

						state.NetworkInfo.Criteria.Network.IsNot.Wifi.Ssid = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.IsNot.Wifi.Ssid)
					}
				}
			}
		}
	}

	if ans.PatchManagement == nil {
		state.PatchManagement = nil
	} else {
		state.PatchManagement = &hipObjectRsModel_suxdMuj_PatchManagementObject{}

		if ans.PatchManagement.Criteria == nil {
			state.PatchManagement.Criteria = nil
		} else {
			state.PatchManagement.Criteria = &hipObjectRsModel_suxdMuj_CriteriaObject{}

			state.PatchManagement.Criteria.IsEnabled = types.StringPointerValue(ans.PatchManagement.Criteria.IsEnabled)

			state.PatchManagement.Criteria.IsInstalled = types.BoolPointerValue(ans.PatchManagement.Criteria.IsInstalled)

			if ans.PatchManagement.Criteria.MissingPatches == nil {
				state.PatchManagement.Criteria.MissingPatches = nil
			} else {
				state.PatchManagement.Criteria.MissingPatches = &hipObjectRsModel_suxdMuj_MissingPatchesObject{}

				state.PatchManagement.Criteria.MissingPatches.Check = types.StringValue(ans.PatchManagement.Criteria.MissingPatches.Check)

				var75, var76 := types.ListValueFrom(ctx, types.StringType, ans.PatchManagement.Criteria.MissingPatches.Patches)
				state.PatchManagement.Criteria.MissingPatches.Patches = var75
				resp.Diagnostics.Append(var76.Errors()...)

				if ans.PatchManagement.Criteria.MissingPatches.Severity == nil {
					state.PatchManagement.Criteria.MissingPatches.Severity = nil
				} else {
					state.PatchManagement.Criteria.MissingPatches.Severity = &hipObjectRsModel_suxdMuj_SeverityObject{}

					state.PatchManagement.Criteria.MissingPatches.Severity.GreaterEqual = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.GreaterEqual)

					state.PatchManagement.Criteria.MissingPatches.Severity.GreaterThan = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.GreaterThan)

					state.PatchManagement.Criteria.MissingPatches.Severity.Is = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.Is)

					state.PatchManagement.Criteria.MissingPatches.Severity.IsNot = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.IsNot)

					state.PatchManagement.Criteria.MissingPatches.Severity.LessEqual = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.LessEqual)

					state.PatchManagement.Criteria.MissingPatches.Severity.LessThan = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.LessThan)
				}
			}
		}

		state.PatchManagement.ExcludeVendor = types.BoolPointerValue(ans.PatchManagement.ExcludeVendor)

		if len(ans.PatchManagement.Vendors) == 0 {
			state.PatchManagement.Vendors = nil
		} else {
			state.PatchManagement.Vendors = make([]hipObjectRsModel_suxdMuj_PatchManagementVendorObject, 0, len(ans.PatchManagement.Vendors))
			for _, var77 := range ans.PatchManagement.Vendors {
				var78 := hipObjectRsModel_suxdMuj_PatchManagementVendorObject{}

				var78.Name = types.StringValue(var77.Name)

				var79, var80 := types.ListValueFrom(ctx, types.StringType, var77.Products)
				var78.Products = var79
				resp.Diagnostics.Append(var80.Errors()...)
				state.PatchManagement.Vendors = append(state.PatchManagement.Vendors, var78)
			}
		}
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Read performs Read for the struct.
func (r *hipObjectResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var savestate, state hipObjectRsModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	tfid := savestate.Tfid.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 4 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 4 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"terraform_provider_function": "Read",
		"resource_name":               "scm_hip_object",
		"locMap":                      map[string]int{"device": 2, "folder": 0, "id": 3, "snippet": 1},
		"tokens":                      tokens,
	})

	// Prepare to read the config.
	svc := sdhSKaQ.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := sdhSKaQ.ReadInput{}

	input.Id = tokens[3]

	// Perform the operation.
	ans, err := svc.Read(ctx, input)
	if err != nil {
		if IsObjectNotFound(err) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading config", err.Error())
		}
		return
	}

	// Store the answer to state.

	if tokens[0] == "" {
		state.Folder = types.StringNull()
	} else {
		state.Folder = types.StringValue(tokens[0])
	}

	if tokens[1] == "" {
		state.Snippet = types.StringNull()
	} else {
		state.Snippet = types.StringValue(tokens[1])
	}

	if tokens[2] == "" {
		state.Device = types.StringNull()
	} else {
		state.Device = types.StringValue(tokens[2])
	}
	state.Tfid = savestate.Tfid

	if ans.AntiMalware == nil {
		state.AntiMalware = nil
	} else {
		state.AntiMalware = &hipObjectRsModel_suxdMuj_AntiMalwareObject{}

		if ans.AntiMalware.Criteria == nil {
			state.AntiMalware.Criteria = nil
		} else {
			state.AntiMalware.Criteria = &hipObjectRsModel_suxdMuj_AntiMalwareCriteriaObject{}

			state.AntiMalware.Criteria.IsInstalled = types.BoolPointerValue(ans.AntiMalware.Criteria.IsInstalled)

			if ans.AntiMalware.Criteria.LastScanTime == nil {
				state.AntiMalware.Criteria.LastScanTime = nil
			} else {
				state.AntiMalware.Criteria.LastScanTime = &hipObjectRsModel_suxdMuj_LastScanTimeObject{}

				if ans.AntiMalware.Criteria.LastScanTime.NotAvailable != nil {
					state.AntiMalware.Criteria.LastScanTime.NotAvailable = types.BoolValue(true)
				} else {
					state.AntiMalware.Criteria.LastScanTime.NotAvailable = types.BoolPointerValue(nil)
				}
				//state.AntiMalware.Criteria.LastScanTime.NotAvailable = types.BoolValue(ans.AntiMalware.Criteria.LastScanTime.NotAvailable != nil)

				if ans.AntiMalware.Criteria.LastScanTime.NotWithin == nil {
					state.AntiMalware.Criteria.LastScanTime.NotWithin = nil
				} else {
					state.AntiMalware.Criteria.LastScanTime.NotWithin = &hipObjectRsModel_suxdMuj_LastScanTimeNotWithinObject{}

					state.AntiMalware.Criteria.LastScanTime.NotWithin.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.NotWithin.Days)

					state.AntiMalware.Criteria.LastScanTime.NotWithin.Hours = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.NotWithin.Hours)
				}

				if ans.AntiMalware.Criteria.LastScanTime.Within == nil {
					state.AntiMalware.Criteria.LastScanTime.Within = nil
				} else {
					state.AntiMalware.Criteria.LastScanTime.Within = &hipObjectRsModel_suxdMuj_LastScanTimeWithinObject{}

					state.AntiMalware.Criteria.LastScanTime.Within.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.Within.Days)

					state.AntiMalware.Criteria.LastScanTime.Within.Hours = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.Within.Hours)
				}
			}

			if ans.AntiMalware.Criteria.ProductVersion == nil {
				state.AntiMalware.Criteria.ProductVersion = nil
			} else {
				state.AntiMalware.Criteria.ProductVersion = &hipObjectRsModel_suxdMuj_ProductVersionObject{}

				state.AntiMalware.Criteria.ProductVersion.Contains = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.Contains)

				state.AntiMalware.Criteria.ProductVersion.GreaterEqual = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.GreaterEqual)

				state.AntiMalware.Criteria.ProductVersion.GreaterThan = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.GreaterThan)

				state.AntiMalware.Criteria.ProductVersion.Is = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.Is)

				state.AntiMalware.Criteria.ProductVersion.IsNot = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.IsNot)

				state.AntiMalware.Criteria.ProductVersion.LessEqual = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.LessEqual)

				state.AntiMalware.Criteria.ProductVersion.LessThan = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.LessThan)

				if ans.AntiMalware.Criteria.ProductVersion.NotWithin == nil {
					state.AntiMalware.Criteria.ProductVersion.NotWithin = nil
				} else {
					state.AntiMalware.Criteria.ProductVersion.NotWithin = &hipObjectRsModel_suxdMuj_ProductVersionNotWithinObject{}

					state.AntiMalware.Criteria.ProductVersion.NotWithin.Versions = types.Int64Value(ans.AntiMalware.Criteria.ProductVersion.NotWithin.Versions)
				}

				if ans.AntiMalware.Criteria.ProductVersion.Within == nil {
					state.AntiMalware.Criteria.ProductVersion.Within = nil
				} else {
					state.AntiMalware.Criteria.ProductVersion.Within = &hipObjectRsModel_suxdMuj_ProductVersionWithinObject{}

					state.AntiMalware.Criteria.ProductVersion.Within.Versions = types.Int64Value(ans.AntiMalware.Criteria.ProductVersion.Within.Versions)
				}
			}

			state.AntiMalware.Criteria.RealTimeProtection = types.StringPointerValue(ans.AntiMalware.Criteria.RealTimeProtection)

			if ans.AntiMalware.Criteria.VirdefVersion == nil {
				state.AntiMalware.Criteria.VirdefVersion = nil
			} else {
				state.AntiMalware.Criteria.VirdefVersion = &hipObjectRsModel_suxdMuj_VirdefVersionObject{}

				if ans.AntiMalware.Criteria.VirdefVersion.NotWithin == nil {
					state.AntiMalware.Criteria.VirdefVersion.NotWithin = nil
				} else {
					state.AntiMalware.Criteria.VirdefVersion.NotWithin = &hipObjectRsModel_suxdMuj_VirdefVersionNotWithinObject{}

					state.AntiMalware.Criteria.VirdefVersion.NotWithin.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.NotWithin.Days)

					state.AntiMalware.Criteria.VirdefVersion.NotWithin.Versions = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.NotWithin.Versions)
				}

				if ans.AntiMalware.Criteria.VirdefVersion.Within == nil {
					state.AntiMalware.Criteria.VirdefVersion.Within = nil
				} else {
					state.AntiMalware.Criteria.VirdefVersion.Within = &hipObjectRsModel_suxdMuj_VirdefVersionWithinObject{}

					state.AntiMalware.Criteria.VirdefVersion.Within.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.Within.Days)

					state.AntiMalware.Criteria.VirdefVersion.Within.Versions = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.Within.Versions)
				}
			}
		}

		state.AntiMalware.ExcludeVendor = types.BoolPointerValue(ans.AntiMalware.ExcludeVendor)

		if len(ans.AntiMalware.Vendors) == 0 {
			state.AntiMalware.Vendors = nil
		} else {
			state.AntiMalware.Vendors = make([]hipObjectRsModel_suxdMuj_AntiMalwareVendorObject, 0, len(ans.AntiMalware.Vendors))
			for _, var0 := range ans.AntiMalware.Vendors {
				var1 := hipObjectRsModel_suxdMuj_AntiMalwareVendorObject{}

				var1.Name = types.StringValue(var0.Name)

				var2, var3 := types.ListValueFrom(ctx, types.StringType, var0.Products)
				var1.Products = var2
				resp.Diagnostics.Append(var3.Errors()...)
				state.AntiMalware.Vendors = append(state.AntiMalware.Vendors, var1)
			}
		}
	}

	if ans.Certificate == nil {
		state.Certificate = nil
	} else {
		state.Certificate = &hipObjectRsModel_suxdMuj_CertificateObject{}

		if ans.Certificate.Criteria == nil {
			state.Certificate.Criteria = nil
		} else {
			state.Certificate.Criteria = &hipObjectRsModel_suxdMuj_CertificateCriteriaObject{}

			if len(ans.Certificate.Criteria.CertificateAttributes) == 0 {
				state.Certificate.Criteria.CertificateAttributes = nil
			} else {
				state.Certificate.Criteria.CertificateAttributes = make([]hipObjectRsModel_suxdMuj_CertificateAttributeObject, 0, len(ans.Certificate.Criteria.CertificateAttributes))
				for _, var4 := range ans.Certificate.Criteria.CertificateAttributes {
					var5 := hipObjectRsModel_suxdMuj_CertificateAttributeObject{}

					var5.Name = types.StringValue(var4.Name)

					var5.Value = types.StringPointerValue(var4.Value)
					state.Certificate.Criteria.CertificateAttributes = append(state.Certificate.Criteria.CertificateAttributes, var5)
				}
			}

			state.Certificate.Criteria.CertificateProfile = types.StringPointerValue(ans.Certificate.Criteria.CertificateProfile)
		}
	}

	if ans.CustomChecks == nil {
		state.CustomChecks = nil
	} else {
		state.CustomChecks = &hipObjectRsModel_suxdMuj_CustomChecksObject{}

		state.CustomChecks.Criteria = hipObjectRsModel_suxdMuj_CustomChecksCriteriaObject{}

		if len(ans.CustomChecks.Criteria.Plist) == 0 {
			state.CustomChecks.Criteria.Plist = nil
		} else {
			state.CustomChecks.Criteria.Plist = make([]hipObjectRsModel_suxdMuj_PlistObject, 0, len(ans.CustomChecks.Criteria.Plist))
			for _, var6 := range ans.CustomChecks.Criteria.Plist {
				var7 := hipObjectRsModel_suxdMuj_PlistObject{}

				if len(var6.Keys) == 0 {
					var7.Keys = nil
				} else {
					var7.Keys = make([]hipObjectRsModel_suxdMuj_KeyObject, 0, len(var6.Keys))
					for _, var8 := range var6.Keys {
						var9 := hipObjectRsModel_suxdMuj_KeyObject{}

						var9.Name = types.StringValue(var8.Name)

						var9.Negate = types.BoolPointerValue(var8.Negate)

						var9.Value = types.StringPointerValue(var8.Value)
						var7.Keys = append(var7.Keys, var9)
					}
				}

				var7.Name = types.StringValue(var6.Name)

				var7.Negate = types.BoolPointerValue(var6.Negate)
				state.CustomChecks.Criteria.Plist = append(state.CustomChecks.Criteria.Plist, var7)
			}
		}

		if len(ans.CustomChecks.Criteria.ProcessList) == 0 {
			state.CustomChecks.Criteria.ProcessList = nil
		} else {
			state.CustomChecks.Criteria.ProcessList = make([]hipObjectRsModel_suxdMuj_ProcessListObject, 0, len(ans.CustomChecks.Criteria.ProcessList))
			for _, var10 := range ans.CustomChecks.Criteria.ProcessList {
				var11 := hipObjectRsModel_suxdMuj_ProcessListObject{}

				var11.Name = types.StringValue(var10.Name)

				var11.Running = types.BoolPointerValue(var10.Running)
				state.CustomChecks.Criteria.ProcessList = append(state.CustomChecks.Criteria.ProcessList, var11)
			}
		}

		if len(ans.CustomChecks.Criteria.RegistryKeys) == 0 {
			state.CustomChecks.Criteria.RegistryKeys = nil
		} else {
			state.CustomChecks.Criteria.RegistryKeys = make([]hipObjectRsModel_suxdMuj_RegistryKeyObject, 0, len(ans.CustomChecks.Criteria.RegistryKeys))
			for _, var12 := range ans.CustomChecks.Criteria.RegistryKeys {
				var13 := hipObjectRsModel_suxdMuj_RegistryKeyObject{}

				var13.DefaultValueData = types.StringPointerValue(var12.DefaultValueData)

				var13.Name = types.StringValue(var12.Name)

				var13.Negate = types.BoolPointerValue(var12.Negate)

				if len(var12.RegistryValues) == 0 {
					var13.RegistryValues = nil
				} else {
					var13.RegistryValues = make([]hipObjectRsModel_suxdMuj_RegistryValueObject, 0, len(var12.RegistryValues))
					for _, var14 := range var12.RegistryValues {
						var15 := hipObjectRsModel_suxdMuj_RegistryValueObject{}

						var15.Name = types.StringValue(var14.Name)

						var15.Negate = types.BoolPointerValue(var14.Negate)

						var15.ValueData = types.StringPointerValue(var14.ValueData)
						var13.RegistryValues = append(var13.RegistryValues, var15)
					}
				}
				state.CustomChecks.Criteria.RegistryKeys = append(state.CustomChecks.Criteria.RegistryKeys, var13)
			}
		}
	}

	if ans.DataLossPrevention == nil {
		state.DataLossPrevention = nil
	} else {
		state.DataLossPrevention = &hipObjectRsModel_suxdMuj_DataLossPreventionObject{}

		if ans.DataLossPrevention.Criteria == nil {
			state.DataLossPrevention.Criteria = nil
		} else {
			state.DataLossPrevention.Criteria = &hipObjectRsModel_suxdMuj_DataLossPreventionCriteriaObject{}

			state.DataLossPrevention.Criteria.IsEnabled = types.StringPointerValue(ans.DataLossPrevention.Criteria.IsEnabled)

			state.DataLossPrevention.Criteria.IsInstalled = types.BoolPointerValue(ans.DataLossPrevention.Criteria.IsInstalled)
		}

		state.DataLossPrevention.ExcludeVendor = types.BoolPointerValue(ans.DataLossPrevention.ExcludeVendor)

		if len(ans.DataLossPrevention.Vendors) == 0 {
			state.DataLossPrevention.Vendors = nil
		} else {
			state.DataLossPrevention.Vendors = make([]hipObjectRsModel_suxdMuj_DataLossPreventionVendorObject, 0, len(ans.DataLossPrevention.Vendors))
			for _, var16 := range ans.DataLossPrevention.Vendors {
				var17 := hipObjectRsModel_suxdMuj_DataLossPreventionVendorObject{}

				var17.Name = types.StringValue(var16.Name)

				var18, var19 := types.ListValueFrom(ctx, types.StringType, var16.Products)
				var17.Products = var18
				resp.Diagnostics.Append(var19.Errors()...)
				state.DataLossPrevention.Vendors = append(state.DataLossPrevention.Vendors, var17)
			}
		}
	}

	state.Description = types.StringPointerValue(ans.Description)

	if ans.DiskBackup == nil {
		state.DiskBackup = nil
	} else {
		state.DiskBackup = &hipObjectRsModel_suxdMuj_DiskBackupObject{}

		if ans.DiskBackup.Criteria == nil {
			state.DiskBackup.Criteria = nil
		} else {
			state.DiskBackup.Criteria = &hipObjectRsModel_suxdMuj_DiskBackupCriteriaObject{}

			state.DiskBackup.Criteria.IsInstalled = types.BoolPointerValue(ans.DiskBackup.Criteria.IsInstalled)

			if ans.DiskBackup.Criteria.LastBackupTime == nil {
				state.DiskBackup.Criteria.LastBackupTime = nil
			} else {
				state.DiskBackup.Criteria.LastBackupTime = &hipObjectRsModel_suxdMuj_LastBackupTimeObject{}

				if ans.DiskBackup.Criteria.LastBackupTime.NotAvailable != nil {
					state.DiskBackup.Criteria.LastBackupTime.NotAvailable = types.BoolValue(true)
				} else {
					state.DiskBackup.Criteria.LastBackupTime.NotAvailable = types.BoolPointerValue(nil)
				}
				//state.DiskBackup.Criteria.LastBackupTime.NotAvailable = types.BoolValue(ans.DiskBackup.Criteria.LastBackupTime.NotAvailable != nil)

				if ans.DiskBackup.Criteria.LastBackupTime.NotWithin == nil {
					state.DiskBackup.Criteria.LastBackupTime.NotWithin = nil
				} else {
					state.DiskBackup.Criteria.LastBackupTime.NotWithin = &hipObjectRsModel_suxdMuj_LastBackupTimeNotWithinObject{}

					state.DiskBackup.Criteria.LastBackupTime.NotWithin.Days = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.NotWithin.Days)

					state.DiskBackup.Criteria.LastBackupTime.NotWithin.Hours = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.NotWithin.Hours)
				}

				if ans.DiskBackup.Criteria.LastBackupTime.Within == nil {
					state.DiskBackup.Criteria.LastBackupTime.Within = nil
				} else {
					state.DiskBackup.Criteria.LastBackupTime.Within = &hipObjectRsModel_suxdMuj_LastBackupTimeWithinObject{}

					state.DiskBackup.Criteria.LastBackupTime.Within.Days = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.Within.Days)

					state.DiskBackup.Criteria.LastBackupTime.Within.Hours = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.Within.Hours)
				}
			}
		}

		state.DiskBackup.ExcludeVendor = types.BoolPointerValue(ans.DiskBackup.ExcludeVendor)

		if len(ans.DiskBackup.Vendors) == 0 {
			state.DiskBackup.Vendors = nil
		} else {
			state.DiskBackup.Vendors = make([]hipObjectRsModel_suxdMuj_DiskBackupVendorObject, 0, len(ans.DiskBackup.Vendors))
			for _, var20 := range ans.DiskBackup.Vendors {
				var21 := hipObjectRsModel_suxdMuj_DiskBackupVendorObject{}

				var21.Name = types.StringValue(var20.Name)

				var22, var23 := types.ListValueFrom(ctx, types.StringType, var20.Products)
				var21.Products = var22
				resp.Diagnostics.Append(var23.Errors()...)
				state.DiskBackup.Vendors = append(state.DiskBackup.Vendors, var21)
			}
		}
	}

	if ans.DiskEncryption == nil {
		state.DiskEncryption = nil
	} else {
		state.DiskEncryption = &hipObjectRsModel_suxdMuj_DiskEncryptionObject{}

		if ans.DiskEncryption.Criteria == nil {
			state.DiskEncryption.Criteria = nil
		} else {
			state.DiskEncryption.Criteria = &hipObjectRsModel_suxdMuj_DiskEncryptionCriteriaObject{}

			if len(ans.DiskEncryption.Criteria.EncryptedLocations) == 0 {
				state.DiskEncryption.Criteria.EncryptedLocations = nil
			} else {
				state.DiskEncryption.Criteria.EncryptedLocations = make([]hipObjectRsModel_suxdMuj_EncryptedLocationObject, 0, len(ans.DiskEncryption.Criteria.EncryptedLocations))
				for _, var24 := range ans.DiskEncryption.Criteria.EncryptedLocations {
					var25 := hipObjectRsModel_suxdMuj_EncryptedLocationObject{}

					if var24.EncryptionState == nil {
						var25.EncryptionState = nil
					} else {
						var25.EncryptionState = &hipObjectRsModel_suxdMuj_EncryptionStateObject{}

						var25.EncryptionState.Is = types.StringPointerValue(var24.EncryptionState.Is)

						var25.EncryptionState.IsNot = types.StringPointerValue(var24.EncryptionState.IsNot)
					}

					var25.Name = types.StringValue(var24.Name)
					state.DiskEncryption.Criteria.EncryptedLocations = append(state.DiskEncryption.Criteria.EncryptedLocations, var25)
				}
			}

			state.DiskEncryption.Criteria.IsInstalled = types.BoolPointerValue(ans.DiskEncryption.Criteria.IsInstalled)
		}

		state.DiskEncryption.ExcludeVendor = types.BoolPointerValue(ans.DiskEncryption.ExcludeVendor)

		if len(ans.DiskEncryption.Vendors) == 0 {
			state.DiskEncryption.Vendors = nil
		} else {
			state.DiskEncryption.Vendors = make([]hipObjectRsModel_suxdMuj_DiskEncryptionVendorObject, 0, len(ans.DiskEncryption.Vendors))
			for _, var26 := range ans.DiskEncryption.Vendors {
				var27 := hipObjectRsModel_suxdMuj_DiskEncryptionVendorObject{}

				var27.Name = types.StringValue(var26.Name)

				var28, var29 := types.ListValueFrom(ctx, types.StringType, var26.Products)
				var27.Products = var28
				resp.Diagnostics.Append(var29.Errors()...)
				state.DiskEncryption.Vendors = append(state.DiskEncryption.Vendors, var27)
			}
		}
	}

	if ans.Firewall == nil {
		state.Firewall = nil
	} else {
		state.Firewall = &hipObjectRsModel_suxdMuj_FirewallObject{}

		if ans.Firewall.Criteria == nil {
			state.Firewall.Criteria = nil
		} else {
			state.Firewall.Criteria = &hipObjectRsModel_suxdMuj_FirewallCriteriaObject{}

			state.Firewall.Criteria.IsEnabled = types.StringPointerValue(ans.Firewall.Criteria.IsEnabled)

			state.Firewall.Criteria.IsInstalled = types.BoolPointerValue(ans.Firewall.Criteria.IsInstalled)
		}

		state.Firewall.ExcludeVendor = types.BoolPointerValue(ans.Firewall.ExcludeVendor)

		if len(ans.Firewall.Vendors) == 0 {
			state.Firewall.Vendors = nil
		} else {
			state.Firewall.Vendors = make([]hipObjectRsModel_suxdMuj_FirewallVendorObject, 0, len(ans.Firewall.Vendors))
			for _, var30 := range ans.Firewall.Vendors {
				var31 := hipObjectRsModel_suxdMuj_FirewallVendorObject{}

				var31.Name = types.StringValue(var30.Name)

				var32, var33 := types.ListValueFrom(ctx, types.StringType, var30.Products)
				var31.Products = var32
				resp.Diagnostics.Append(var33.Errors()...)
				state.Firewall.Vendors = append(state.Firewall.Vendors, var31)
			}
		}
	}

	if ans.HostInfo == nil {
		state.HostInfo = nil
	} else {
		state.HostInfo = &hipObjectRsModel_suxdMuj_HostInfoObject{}

		state.HostInfo.Criteria = hipObjectRsModel_suxdMuj_HostInfoCriteriaObject{}

		if ans.HostInfo.Criteria.ClientVersion == nil {
			state.HostInfo.Criteria.ClientVersion = nil
		} else {
			state.HostInfo.Criteria.ClientVersion = &hipObjectRsModel_suxdMuj_ClientVersionObject{}

			state.HostInfo.Criteria.ClientVersion.Contains = types.StringPointerValue(ans.HostInfo.Criteria.ClientVersion.Contains)

			state.HostInfo.Criteria.ClientVersion.Is = types.StringPointerValue(ans.HostInfo.Criteria.ClientVersion.Is)

			state.HostInfo.Criteria.ClientVersion.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.ClientVersion.IsNot)
		}

		if ans.HostInfo.Criteria.Domain == nil {
			state.HostInfo.Criteria.Domain = nil
		} else {
			state.HostInfo.Criteria.Domain = &hipObjectRsModel_suxdMuj_DomainObject{}

			state.HostInfo.Criteria.Domain.Contains = types.StringPointerValue(ans.HostInfo.Criteria.Domain.Contains)

			state.HostInfo.Criteria.Domain.Is = types.StringPointerValue(ans.HostInfo.Criteria.Domain.Is)

			state.HostInfo.Criteria.Domain.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.Domain.IsNot)
		}

		if ans.HostInfo.Criteria.HostId == nil {
			state.HostInfo.Criteria.HostId = nil
		} else {
			state.HostInfo.Criteria.HostId = &hipObjectRsModel_suxdMuj_HostIdObject{}

			state.HostInfo.Criteria.HostId.Contains = types.StringPointerValue(ans.HostInfo.Criteria.HostId.Contains)

			state.HostInfo.Criteria.HostId.Is = types.StringPointerValue(ans.HostInfo.Criteria.HostId.Is)

			state.HostInfo.Criteria.HostId.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.HostId.IsNot)
		}

		if ans.HostInfo.Criteria.HostName == nil {
			state.HostInfo.Criteria.HostName = nil
		} else {
			state.HostInfo.Criteria.HostName = &hipObjectRsModel_suxdMuj_HostNameObject{}

			state.HostInfo.Criteria.HostName.Contains = types.StringPointerValue(ans.HostInfo.Criteria.HostName.Contains)

			state.HostInfo.Criteria.HostName.Is = types.StringPointerValue(ans.HostInfo.Criteria.HostName.Is)

			state.HostInfo.Criteria.HostName.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.HostName.IsNot)
		}

		state.HostInfo.Criteria.Managed = types.BoolPointerValue(ans.HostInfo.Criteria.Managed)

		if ans.HostInfo.Criteria.Os == nil {
			state.HostInfo.Criteria.Os = nil
		} else {
			state.HostInfo.Criteria.Os = &hipObjectRsModel_suxdMuj_OsObject{}

			if ans.HostInfo.Criteria.Os.Contains == nil {
				state.HostInfo.Criteria.Os.Contains = nil
			} else {
				state.HostInfo.Criteria.Os.Contains = &hipObjectRsModel_suxdMuj_ContainsObject{}

				state.HostInfo.Criteria.Os.Contains.Apple = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Apple)

				state.HostInfo.Criteria.Os.Contains.Google = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Google)

				state.HostInfo.Criteria.Os.Contains.Linux = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Linux)

				state.HostInfo.Criteria.Os.Contains.Microsoft = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Microsoft)

				state.HostInfo.Criteria.Os.Contains.Other = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Other)
			}
		}

		if ans.HostInfo.Criteria.SerialNumber == nil {
			state.HostInfo.Criteria.SerialNumber = nil
		} else {
			state.HostInfo.Criteria.SerialNumber = &hipObjectRsModel_suxdMuj_SerialNumberObject{}

			state.HostInfo.Criteria.SerialNumber.Contains = types.StringPointerValue(ans.HostInfo.Criteria.SerialNumber.Contains)

			state.HostInfo.Criteria.SerialNumber.Is = types.StringPointerValue(ans.HostInfo.Criteria.SerialNumber.Is)

			state.HostInfo.Criteria.SerialNumber.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.SerialNumber.IsNot)
		}
	}

	state.Id = types.StringPointerValue(ans.Id)

	if ans.MobileDevice == nil {
		state.MobileDevice = nil
	} else {
		state.MobileDevice = &hipObjectRsModel_suxdMuj_MobileDeviceObject{}

		if ans.MobileDevice.Criteria == nil {
			state.MobileDevice.Criteria = nil
		} else {
			state.MobileDevice.Criteria = &hipObjectRsModel_suxdMuj_MobileDeviceCriteriaObject{}

			if ans.MobileDevice.Criteria.Applications == nil {
				state.MobileDevice.Criteria.Applications = nil
			} else {
				state.MobileDevice.Criteria.Applications = &hipObjectRsModel_suxdMuj_ApplicationsObject{}

				if ans.MobileDevice.Criteria.Applications.HasMalware == nil {
					state.MobileDevice.Criteria.Applications.HasMalware = nil
				} else {
					state.MobileDevice.Criteria.Applications.HasMalware = &hipObjectRsModel_suxdMuj_HasMalwareObject{}

					if ans.MobileDevice.Criteria.Applications.HasMalware.No != nil {
						state.MobileDevice.Criteria.Applications.HasMalware.No = types.BoolValue(true)
					} else {
						state.MobileDevice.Criteria.Applications.HasMalware.No = types.BoolPointerValue(nil)
					}
					//state.MobileDevice.Criteria.Applications.HasMalware.No = types.BoolValue(ans.MobileDevice.Criteria.Applications.HasMalware.No != nil)

					if ans.MobileDevice.Criteria.Applications.HasMalware.Yes == nil {
						state.MobileDevice.Criteria.Applications.HasMalware.Yes = nil
					} else {
						state.MobileDevice.Criteria.Applications.HasMalware.Yes = &hipObjectRsModel_suxdMuj_YesObject{}

						if len(ans.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes) == 0 {
							state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = nil
						} else {
							state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = make([]hipObjectRsModel_suxdMuj_ExcludeObject, 0, len(ans.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes))
							for _, var34 := range ans.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes {
								var35 := hipObjectRsModel_suxdMuj_ExcludeObject{}

								var35.Hash = types.StringPointerValue(var34.Hash)

								var35.Name = types.StringValue(var34.Name)

								var35.Package = types.StringPointerValue(var34.Package)
								state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = append(state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes, var35)
							}
						}
					}
				}

				state.MobileDevice.Criteria.Applications.HasUnmanagedApp = types.BoolPointerValue(ans.MobileDevice.Criteria.Applications.HasUnmanagedApp)

				if len(ans.MobileDevice.Criteria.Applications.Includes) == 0 {
					state.MobileDevice.Criteria.Applications.Includes = nil
				} else {
					state.MobileDevice.Criteria.Applications.Includes = make([]hipObjectRsModel_suxdMuj_IncludeObject, 0, len(ans.MobileDevice.Criteria.Applications.Includes))
					for _, var36 := range ans.MobileDevice.Criteria.Applications.Includes {
						var37 := hipObjectRsModel_suxdMuj_IncludeObject{}

						var37.Hash = types.StringPointerValue(var36.Hash)

						var37.Name = types.StringValue(var36.Name)

						var37.Package = types.StringPointerValue(var36.Package)
						state.MobileDevice.Criteria.Applications.Includes = append(state.MobileDevice.Criteria.Applications.Includes, var37)
					}
				}
			}

			state.MobileDevice.Criteria.DiskEncrypted = types.BoolPointerValue(ans.MobileDevice.Criteria.DiskEncrypted)

			if ans.MobileDevice.Criteria.Imei == nil {
				state.MobileDevice.Criteria.Imei = nil
			} else {
				state.MobileDevice.Criteria.Imei = &hipObjectRsModel_suxdMuj_ImeiObject{}

				state.MobileDevice.Criteria.Imei.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.Imei.Contains)

				state.MobileDevice.Criteria.Imei.Is = types.StringPointerValue(ans.MobileDevice.Criteria.Imei.Is)

				state.MobileDevice.Criteria.Imei.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.Imei.IsNot)
			}

			state.MobileDevice.Criteria.Jailbroken = types.BoolPointerValue(ans.MobileDevice.Criteria.Jailbroken)

			if ans.MobileDevice.Criteria.LastCheckinTime == nil {
				state.MobileDevice.Criteria.LastCheckinTime = nil
			} else {
				state.MobileDevice.Criteria.LastCheckinTime = &hipObjectRsModel_suxdMuj_LastCheckinTimeObject{}

				if ans.MobileDevice.Criteria.LastCheckinTime.NotWithin == nil {
					state.MobileDevice.Criteria.LastCheckinTime.NotWithin = nil
				} else {
					state.MobileDevice.Criteria.LastCheckinTime.NotWithin = &hipObjectRsModel_suxdMuj_LastCheckinTimeNotWithinObject{}

					state.MobileDevice.Criteria.LastCheckinTime.NotWithin.Days = types.Int64Value(ans.MobileDevice.Criteria.LastCheckinTime.NotWithin.Days)
				}

				if ans.MobileDevice.Criteria.LastCheckinTime.Within == nil {
					state.MobileDevice.Criteria.LastCheckinTime.Within = nil
				} else {
					state.MobileDevice.Criteria.LastCheckinTime.Within = &hipObjectRsModel_suxdMuj_LastCheckinTimeWithinObject{}

					state.MobileDevice.Criteria.LastCheckinTime.Within.Days = types.Int64Value(ans.MobileDevice.Criteria.LastCheckinTime.Within.Days)
				}
			}

			if ans.MobileDevice.Criteria.Model == nil {
				state.MobileDevice.Criteria.Model = nil
			} else {
				state.MobileDevice.Criteria.Model = &hipObjectRsModel_suxdMuj_ModelObject{}

				state.MobileDevice.Criteria.Model.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.Model.Contains)

				state.MobileDevice.Criteria.Model.Is = types.StringPointerValue(ans.MobileDevice.Criteria.Model.Is)

				state.MobileDevice.Criteria.Model.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.Model.IsNot)
			}

			state.MobileDevice.Criteria.PasscodeSet = types.BoolPointerValue(ans.MobileDevice.Criteria.PasscodeSet)

			if ans.MobileDevice.Criteria.PhoneNumber == nil {
				state.MobileDevice.Criteria.PhoneNumber = nil
			} else {
				state.MobileDevice.Criteria.PhoneNumber = &hipObjectRsModel_suxdMuj_PhoneNumberObject{}

				state.MobileDevice.Criteria.PhoneNumber.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.PhoneNumber.Contains)

				state.MobileDevice.Criteria.PhoneNumber.Is = types.StringPointerValue(ans.MobileDevice.Criteria.PhoneNumber.Is)

				state.MobileDevice.Criteria.PhoneNumber.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.PhoneNumber.IsNot)
			}

			if ans.MobileDevice.Criteria.Tag == nil {
				state.MobileDevice.Criteria.Tag = nil
			} else {
				state.MobileDevice.Criteria.Tag = &hipObjectRsModel_suxdMuj_TagObject{}

				state.MobileDevice.Criteria.Tag.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.Tag.Contains)

				state.MobileDevice.Criteria.Tag.Is = types.StringPointerValue(ans.MobileDevice.Criteria.Tag.Is)

				state.MobileDevice.Criteria.Tag.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.Tag.IsNot)
			}
		}
	}

	state.Name = types.StringValue(ans.Name)

	if ans.NetworkInfo == nil {
		state.NetworkInfo = nil
	} else {
		state.NetworkInfo = &hipObjectRsModel_suxdMuj_NetworkInfoObject{}

		if ans.NetworkInfo.Criteria == nil {
			state.NetworkInfo.Criteria = nil
		} else {
			state.NetworkInfo.Criteria = &hipObjectRsModel_suxdMuj_NetworkInfoCriteriaObject{}

			if ans.NetworkInfo.Criteria.Network == nil {
				state.NetworkInfo.Criteria.Network = nil
			} else {
				state.NetworkInfo.Criteria.Network = &hipObjectRsModel_suxdMuj_NetworkObject{}

				if ans.NetworkInfo.Criteria.Network.Is == nil {
					state.NetworkInfo.Criteria.Network.Is = nil
				} else {
					state.NetworkInfo.Criteria.Network.Is = &hipObjectRsModel_suxdMuj_IsObject{}

					if ans.NetworkInfo.Criteria.Network.Is.Mobile == nil {
						state.NetworkInfo.Criteria.Network.Is.Mobile = nil
					} else {
						state.NetworkInfo.Criteria.Network.Is.Mobile = &hipObjectRsModel_suxdMuj_IsMobileObject{}

						state.NetworkInfo.Criteria.Network.Is.Mobile.Carrier = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.Is.Mobile.Carrier)
					}

					if ans.NetworkInfo.Criteria.Network.Is.Unknown != nil {
						state.NetworkInfo.Criteria.Network.Is.Unknown = types.BoolValue(true)
					} else {
						state.NetworkInfo.Criteria.Network.Is.Unknown = types.BoolPointerValue(nil)
					}
					//state.NetworkInfo.Criteria.Network.Is.Unknown = types.BoolValue(ans.NetworkInfo.Criteria.Network.Is.Unknown != nil)

					if ans.NetworkInfo.Criteria.Network.Is.Wifi == nil {
						state.NetworkInfo.Criteria.Network.Is.Wifi = nil
					} else {
						state.NetworkInfo.Criteria.Network.Is.Wifi = &hipObjectRsModel_suxdMuj_IsWifiObject{}

						state.NetworkInfo.Criteria.Network.Is.Wifi.Ssid = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.Is.Wifi.Ssid)
					}
				}

				if ans.NetworkInfo.Criteria.Network.IsNot == nil {
					state.NetworkInfo.Criteria.Network.IsNot = nil
				} else {
					state.NetworkInfo.Criteria.Network.IsNot = &hipObjectRsModel_suxdMuj_IsNotObject{}

					if ans.NetworkInfo.Criteria.Network.IsNot.Ethernet != nil {
						state.NetworkInfo.Criteria.Network.IsNot.Ethernet = types.BoolValue(true)
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Ethernet = types.BoolPointerValue(nil)
					}
					//state.NetworkInfo.Criteria.Network.IsNot.Ethernet = types.BoolValue(ans.NetworkInfo.Criteria.Network.IsNot.Ethernet != nil)

					if ans.NetworkInfo.Criteria.Network.IsNot.Mobile == nil {
						state.NetworkInfo.Criteria.Network.IsNot.Mobile = nil
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Mobile = &hipObjectRsModel_suxdMuj_IsNotMobileObject{}

						state.NetworkInfo.Criteria.Network.IsNot.Mobile.Carrier = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.IsNot.Mobile.Carrier)
					}

					if ans.NetworkInfo.Criteria.Network.IsNot.Unknown != nil {
						state.NetworkInfo.Criteria.Network.IsNot.Unknown = types.BoolValue(true)
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Unknown = types.BoolPointerValue(nil)
					}
					//state.NetworkInfo.Criteria.Network.IsNot.Unknown = types.BoolValue(ans.NetworkInfo.Criteria.Network.IsNot.Unknown != nil)

					if ans.NetworkInfo.Criteria.Network.IsNot.Wifi == nil {
						state.NetworkInfo.Criteria.Network.IsNot.Wifi = nil
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Wifi = &hipObjectRsModel_suxdMuj_IsNotWifiObject{}

						state.NetworkInfo.Criteria.Network.IsNot.Wifi.Ssid = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.IsNot.Wifi.Ssid)
					}
				}
			}
		}
	}

	if ans.PatchManagement == nil {
		state.PatchManagement = nil
	} else {
		state.PatchManagement = &hipObjectRsModel_suxdMuj_PatchManagementObject{}

		if ans.PatchManagement.Criteria == nil {
			state.PatchManagement.Criteria = nil
		} else {
			state.PatchManagement.Criteria = &hipObjectRsModel_suxdMuj_CriteriaObject{}

			state.PatchManagement.Criteria.IsEnabled = types.StringPointerValue(ans.PatchManagement.Criteria.IsEnabled)

			state.PatchManagement.Criteria.IsInstalled = types.BoolPointerValue(ans.PatchManagement.Criteria.IsInstalled)

			if ans.PatchManagement.Criteria.MissingPatches == nil {
				state.PatchManagement.Criteria.MissingPatches = nil
			} else {
				state.PatchManagement.Criteria.MissingPatches = &hipObjectRsModel_suxdMuj_MissingPatchesObject{}

				state.PatchManagement.Criteria.MissingPatches.Check = types.StringValue(ans.PatchManagement.Criteria.MissingPatches.Check)

				var38, var39 := types.ListValueFrom(ctx, types.StringType, ans.PatchManagement.Criteria.MissingPatches.Patches)
				state.PatchManagement.Criteria.MissingPatches.Patches = var38
				resp.Diagnostics.Append(var39.Errors()...)

				if ans.PatchManagement.Criteria.MissingPatches.Severity == nil {
					state.PatchManagement.Criteria.MissingPatches.Severity = nil
				} else {
					state.PatchManagement.Criteria.MissingPatches.Severity = &hipObjectRsModel_suxdMuj_SeverityObject{}

					state.PatchManagement.Criteria.MissingPatches.Severity.GreaterEqual = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.GreaterEqual)

					state.PatchManagement.Criteria.MissingPatches.Severity.GreaterThan = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.GreaterThan)

					state.PatchManagement.Criteria.MissingPatches.Severity.Is = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.Is)

					state.PatchManagement.Criteria.MissingPatches.Severity.IsNot = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.IsNot)

					state.PatchManagement.Criteria.MissingPatches.Severity.LessEqual = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.LessEqual)

					state.PatchManagement.Criteria.MissingPatches.Severity.LessThan = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.LessThan)
				}
			}
		}

		state.PatchManagement.ExcludeVendor = types.BoolPointerValue(ans.PatchManagement.ExcludeVendor)

		if len(ans.PatchManagement.Vendors) == 0 {
			state.PatchManagement.Vendors = nil
		} else {
			state.PatchManagement.Vendors = make([]hipObjectRsModel_suxdMuj_PatchManagementVendorObject, 0, len(ans.PatchManagement.Vendors))
			for _, var40 := range ans.PatchManagement.Vendors {
				var41 := hipObjectRsModel_suxdMuj_PatchManagementVendorObject{}

				var41.Name = types.StringValue(var40.Name)

				var42, var43 := types.ListValueFrom(ctx, types.StringType, var40.Products)
				var41.Products = var42
				resp.Diagnostics.Append(var43.Errors()...)
				state.PatchManagement.Vendors = append(state.PatchManagement.Vendors, var41)
			}
		}
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Update performs the Update for the struct.
func (r *hipObjectResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, state hipObjectRsModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	tfid := state.Tfid.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 4 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 4 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"terraform_provider_function": "Update",
		"resource_name":               "scm_hip_object",
		"tfid":                        state.Tfid.ValueString(),
	})

	// Prepare to update the config.
	svc := sdhSKaQ.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := sdhSKaQ.UpdateInput{}

	if tokens[3] != "" {
		input.Id = tokens[3]
	}
	input.Request = &suxdMuj.Config{}

	if plan.AntiMalware != nil {
		input.Request.AntiMalware = &suxdMuj.AntiMalwareObject{}

		if plan.AntiMalware.Criteria != nil {
			input.Request.AntiMalware.Criteria = &suxdMuj.AntiMalwareCriteriaObject{}

			input.Request.AntiMalware.Criteria.IsInstalled = plan.AntiMalware.Criteria.IsInstalled.ValueBoolPointer()

			if plan.AntiMalware.Criteria.LastScanTime != nil {
				input.Request.AntiMalware.Criteria.LastScanTime = &suxdMuj.LastScanTimeObject{}

				if !plan.AntiMalware.Criteria.LastScanTime.NotAvailable.IsNull() && plan.AntiMalware.Criteria.LastScanTime.NotAvailable.ValueBool() {
					input.Request.AntiMalware.Criteria.LastScanTime.NotAvailable = map[string]interface{}{}
				}

				if plan.AntiMalware.Criteria.LastScanTime.NotWithin != nil {
					input.Request.AntiMalware.Criteria.LastScanTime.NotWithin = &suxdMuj.LastScanTimeNotWithinObject{}

					input.Request.AntiMalware.Criteria.LastScanTime.NotWithin.Days = plan.AntiMalware.Criteria.LastScanTime.NotWithin.Days.ValueInt64Pointer()

					input.Request.AntiMalware.Criteria.LastScanTime.NotWithin.Hours = plan.AntiMalware.Criteria.LastScanTime.NotWithin.Hours.ValueInt64Pointer()
				}

				if plan.AntiMalware.Criteria.LastScanTime.Within != nil {
					input.Request.AntiMalware.Criteria.LastScanTime.Within = &suxdMuj.LastScanTimeWithinObject{}

					input.Request.AntiMalware.Criteria.LastScanTime.Within.Days = plan.AntiMalware.Criteria.LastScanTime.Within.Days.ValueInt64Pointer()

					input.Request.AntiMalware.Criteria.LastScanTime.Within.Hours = plan.AntiMalware.Criteria.LastScanTime.Within.Hours.ValueInt64Pointer()
				}
			}

			if plan.AntiMalware.Criteria.ProductVersion != nil {
				input.Request.AntiMalware.Criteria.ProductVersion = &suxdMuj.ProductVersionObject{}

				input.Request.AntiMalware.Criteria.ProductVersion.Contains = plan.AntiMalware.Criteria.ProductVersion.Contains.ValueStringPointer()

				input.Request.AntiMalware.Criteria.ProductVersion.GreaterEqual = plan.AntiMalware.Criteria.ProductVersion.GreaterEqual.ValueStringPointer()

				input.Request.AntiMalware.Criteria.ProductVersion.GreaterThan = plan.AntiMalware.Criteria.ProductVersion.GreaterThan.ValueStringPointer()

				input.Request.AntiMalware.Criteria.ProductVersion.Is = plan.AntiMalware.Criteria.ProductVersion.Is.ValueStringPointer()

				input.Request.AntiMalware.Criteria.ProductVersion.IsNot = plan.AntiMalware.Criteria.ProductVersion.IsNot.ValueStringPointer()

				input.Request.AntiMalware.Criteria.ProductVersion.LessEqual = plan.AntiMalware.Criteria.ProductVersion.LessEqual.ValueStringPointer()

				input.Request.AntiMalware.Criteria.ProductVersion.LessThan = plan.AntiMalware.Criteria.ProductVersion.LessThan.ValueStringPointer()

				if plan.AntiMalware.Criteria.ProductVersion.NotWithin != nil {
					input.Request.AntiMalware.Criteria.ProductVersion.NotWithin = &suxdMuj.ProductVersionNotWithinObject{}

					input.Request.AntiMalware.Criteria.ProductVersion.NotWithin.Versions = plan.AntiMalware.Criteria.ProductVersion.NotWithin.Versions.ValueInt64()
				}

				if plan.AntiMalware.Criteria.ProductVersion.Within != nil {
					input.Request.AntiMalware.Criteria.ProductVersion.Within = &suxdMuj.ProductVersionWithinObject{}

					input.Request.AntiMalware.Criteria.ProductVersion.Within.Versions = plan.AntiMalware.Criteria.ProductVersion.Within.Versions.ValueInt64()
				}
			}

			input.Request.AntiMalware.Criteria.RealTimeProtection = plan.AntiMalware.Criteria.RealTimeProtection.ValueStringPointer()

			if plan.AntiMalware.Criteria.VirdefVersion != nil {
				input.Request.AntiMalware.Criteria.VirdefVersion = &suxdMuj.VirdefVersionObject{}

				if plan.AntiMalware.Criteria.VirdefVersion.NotWithin != nil {
					input.Request.AntiMalware.Criteria.VirdefVersion.NotWithin = &suxdMuj.VirdefVersionNotWithinObject{}

					input.Request.AntiMalware.Criteria.VirdefVersion.NotWithin.Days = plan.AntiMalware.Criteria.VirdefVersion.NotWithin.Days.ValueInt64Pointer()

					input.Request.AntiMalware.Criteria.VirdefVersion.NotWithin.Versions = plan.AntiMalware.Criteria.VirdefVersion.NotWithin.Versions.ValueInt64Pointer()
				}

				if plan.AntiMalware.Criteria.VirdefVersion.Within != nil {
					input.Request.AntiMalware.Criteria.VirdefVersion.Within = &suxdMuj.VirdefVersionWithinObject{}

					input.Request.AntiMalware.Criteria.VirdefVersion.Within.Days = plan.AntiMalware.Criteria.VirdefVersion.Within.Days.ValueInt64Pointer()

					input.Request.AntiMalware.Criteria.VirdefVersion.Within.Versions = plan.AntiMalware.Criteria.VirdefVersion.Within.Versions.ValueInt64Pointer()
				}
			}
		}

		input.Request.AntiMalware.ExcludeVendor = plan.AntiMalware.ExcludeVendor.ValueBoolPointer()

		if len(plan.AntiMalware.Vendors) != 0 {
			input.Request.AntiMalware.Vendors = make([]suxdMuj.AntiMalwareVendorObject, 0, len(plan.AntiMalware.Vendors))
			for _, var0 := range plan.AntiMalware.Vendors {
				var var1 suxdMuj.AntiMalwareVendorObject

				var1.Name = var0.Name.ValueString()

				resp.Diagnostics.Append(var0.Products.ElementsAs(ctx, &var1.Products, false)...)
				//if len(var0.Products) != 0 {
				//    var1.Products = make([]string, 0, len(var0.Products))
				//    for _, var2 := range var0.Products {
				//        var1.Products = append(var1.Products, var2.ValueString())
				//    }
				//}
				input.Request.AntiMalware.Vendors = append(input.Request.AntiMalware.Vendors, var1)
			}
		}
	}

	if plan.Certificate != nil {
		input.Request.Certificate = &suxdMuj.CertificateObject{}

		if plan.Certificate.Criteria != nil {
			input.Request.Certificate.Criteria = &suxdMuj.CertificateCriteriaObject{}

			if len(plan.Certificate.Criteria.CertificateAttributes) != 0 {
				input.Request.Certificate.Criteria.CertificateAttributes = make([]suxdMuj.CertificateAttributeObject, 0, len(plan.Certificate.Criteria.CertificateAttributes))
				for _, var3 := range plan.Certificate.Criteria.CertificateAttributes {
					var var4 suxdMuj.CertificateAttributeObject

					var4.Name = var3.Name.ValueString()

					var4.Value = var3.Value.ValueStringPointer()
					input.Request.Certificate.Criteria.CertificateAttributes = append(input.Request.Certificate.Criteria.CertificateAttributes, var4)
				}
			}

			input.Request.Certificate.Criteria.CertificateProfile = plan.Certificate.Criteria.CertificateProfile.ValueStringPointer()
		}
	}

	if plan.CustomChecks != nil {
		input.Request.CustomChecks = &suxdMuj.CustomChecksObject{}

		if len(plan.CustomChecks.Criteria.Plist) != 0 {
			input.Request.CustomChecks.Criteria.Plist = make([]suxdMuj.PlistObject, 0, len(plan.CustomChecks.Criteria.Plist))
			for _, var5 := range plan.CustomChecks.Criteria.Plist {
				var var6 suxdMuj.PlistObject

				if len(var5.Keys) != 0 {
					var6.Keys = make([]suxdMuj.KeyObject, 0, len(var5.Keys))
					for _, var7 := range var5.Keys {
						var var8 suxdMuj.KeyObject

						var8.Name = var7.Name.ValueString()

						var8.Negate = var7.Negate.ValueBoolPointer()

						var8.Value = var7.Value.ValueStringPointer()
						var6.Keys = append(var6.Keys, var8)
					}
				}

				var6.Name = var5.Name.ValueString()

				var6.Negate = var5.Negate.ValueBoolPointer()
				input.Request.CustomChecks.Criteria.Plist = append(input.Request.CustomChecks.Criteria.Plist, var6)
			}
		}

		if len(plan.CustomChecks.Criteria.ProcessList) != 0 {
			input.Request.CustomChecks.Criteria.ProcessList = make([]suxdMuj.ProcessListObject, 0, len(plan.CustomChecks.Criteria.ProcessList))
			for _, var9 := range plan.CustomChecks.Criteria.ProcessList {
				var var10 suxdMuj.ProcessListObject

				var10.Name = var9.Name.ValueString()

				var10.Running = var9.Running.ValueBoolPointer()
				input.Request.CustomChecks.Criteria.ProcessList = append(input.Request.CustomChecks.Criteria.ProcessList, var10)
			}
		}

		if len(plan.CustomChecks.Criteria.RegistryKeys) != 0 {
			input.Request.CustomChecks.Criteria.RegistryKeys = make([]suxdMuj.RegistryKeyObject, 0, len(plan.CustomChecks.Criteria.RegistryKeys))
			for _, var11 := range plan.CustomChecks.Criteria.RegistryKeys {
				var var12 suxdMuj.RegistryKeyObject

				var12.DefaultValueData = var11.DefaultValueData.ValueStringPointer()

				var12.Name = var11.Name.ValueString()

				var12.Negate = var11.Negate.ValueBoolPointer()

				if len(var11.RegistryValues) != 0 {
					var12.RegistryValues = make([]suxdMuj.RegistryValueObject, 0, len(var11.RegistryValues))
					for _, var13 := range var11.RegistryValues {
						var var14 suxdMuj.RegistryValueObject

						var14.Name = var13.Name.ValueString()

						var14.Negate = var13.Negate.ValueBoolPointer()

						var14.ValueData = var13.ValueData.ValueStringPointer()
						var12.RegistryValues = append(var12.RegistryValues, var14)
					}
				}
				input.Request.CustomChecks.Criteria.RegistryKeys = append(input.Request.CustomChecks.Criteria.RegistryKeys, var12)
			}
		}
	}

	if plan.DataLossPrevention != nil {
		input.Request.DataLossPrevention = &suxdMuj.DataLossPreventionObject{}

		if plan.DataLossPrevention.Criteria != nil {
			input.Request.DataLossPrevention.Criteria = &suxdMuj.DataLossPreventionCriteriaObject{}

			input.Request.DataLossPrevention.Criteria.IsEnabled = plan.DataLossPrevention.Criteria.IsEnabled.ValueStringPointer()

			input.Request.DataLossPrevention.Criteria.IsInstalled = plan.DataLossPrevention.Criteria.IsInstalled.ValueBoolPointer()
		}

		input.Request.DataLossPrevention.ExcludeVendor = plan.DataLossPrevention.ExcludeVendor.ValueBoolPointer()

		if len(plan.DataLossPrevention.Vendors) != 0 {
			input.Request.DataLossPrevention.Vendors = make([]suxdMuj.DataLossPreventionVendorObject, 0, len(plan.DataLossPrevention.Vendors))
			for _, var15 := range plan.DataLossPrevention.Vendors {
				var var16 suxdMuj.DataLossPreventionVendorObject

				var16.Name = var15.Name.ValueString()

				resp.Diagnostics.Append(var15.Products.ElementsAs(ctx, &var16.Products, false)...)
				//if len(var15.Products) != 0 {
				//    var16.Products = make([]string, 0, len(var15.Products))
				//    for _, var17 := range var15.Products {
				//        var16.Products = append(var16.Products, var17.ValueString())
				//    }
				//}
				input.Request.DataLossPrevention.Vendors = append(input.Request.DataLossPrevention.Vendors, var16)
			}
		}
	}

	input.Request.Description = plan.Description.ValueStringPointer()

	if plan.DiskBackup != nil {
		input.Request.DiskBackup = &suxdMuj.DiskBackupObject{}

		if plan.DiskBackup.Criteria != nil {
			input.Request.DiskBackup.Criteria = &suxdMuj.DiskBackupCriteriaObject{}

			input.Request.DiskBackup.Criteria.IsInstalled = plan.DiskBackup.Criteria.IsInstalled.ValueBoolPointer()

			if plan.DiskBackup.Criteria.LastBackupTime != nil {
				input.Request.DiskBackup.Criteria.LastBackupTime = &suxdMuj.LastBackupTimeObject{}

				if !plan.DiskBackup.Criteria.LastBackupTime.NotAvailable.IsNull() && plan.DiskBackup.Criteria.LastBackupTime.NotAvailable.ValueBool() {
					input.Request.DiskBackup.Criteria.LastBackupTime.NotAvailable = map[string]interface{}{}
				}

				if plan.DiskBackup.Criteria.LastBackupTime.NotWithin != nil {
					input.Request.DiskBackup.Criteria.LastBackupTime.NotWithin = &suxdMuj.LastBackupTimeNotWithinObject{}

					input.Request.DiskBackup.Criteria.LastBackupTime.NotWithin.Days = plan.DiskBackup.Criteria.LastBackupTime.NotWithin.Days.ValueInt64Pointer()

					input.Request.DiskBackup.Criteria.LastBackupTime.NotWithin.Hours = plan.DiskBackup.Criteria.LastBackupTime.NotWithin.Hours.ValueInt64Pointer()
				}

				if plan.DiskBackup.Criteria.LastBackupTime.Within != nil {
					input.Request.DiskBackup.Criteria.LastBackupTime.Within = &suxdMuj.LastBackupTimeWithinObject{}

					input.Request.DiskBackup.Criteria.LastBackupTime.Within.Days = plan.DiskBackup.Criteria.LastBackupTime.Within.Days.ValueInt64Pointer()

					input.Request.DiskBackup.Criteria.LastBackupTime.Within.Hours = plan.DiskBackup.Criteria.LastBackupTime.Within.Hours.ValueInt64Pointer()
				}
			}
		}

		input.Request.DiskBackup.ExcludeVendor = plan.DiskBackup.ExcludeVendor.ValueBoolPointer()

		if len(plan.DiskBackup.Vendors) != 0 {
			input.Request.DiskBackup.Vendors = make([]suxdMuj.DiskBackupVendorObject, 0, len(plan.DiskBackup.Vendors))
			for _, var18 := range plan.DiskBackup.Vendors {
				var var19 suxdMuj.DiskBackupVendorObject

				var19.Name = var18.Name.ValueString()

				resp.Diagnostics.Append(var18.Products.ElementsAs(ctx, &var19.Products, false)...)
				//if len(var18.Products) != 0 {
				//    var19.Products = make([]string, 0, len(var18.Products))
				//    for _, var20 := range var18.Products {
				//        var19.Products = append(var19.Products, var20.ValueString())
				//    }
				//}
				input.Request.DiskBackup.Vendors = append(input.Request.DiskBackup.Vendors, var19)
			}
		}
	}

	if plan.DiskEncryption != nil {
		input.Request.DiskEncryption = &suxdMuj.DiskEncryptionObject{}

		if plan.DiskEncryption.Criteria != nil {
			input.Request.DiskEncryption.Criteria = &suxdMuj.DiskEncryptionCriteriaObject{}

			if len(plan.DiskEncryption.Criteria.EncryptedLocations) != 0 {
				input.Request.DiskEncryption.Criteria.EncryptedLocations = make([]suxdMuj.EncryptedLocationObject, 0, len(plan.DiskEncryption.Criteria.EncryptedLocations))
				for _, var21 := range plan.DiskEncryption.Criteria.EncryptedLocations {
					var var22 suxdMuj.EncryptedLocationObject

					if var21.EncryptionState != nil {
						var22.EncryptionState = &suxdMuj.EncryptionStateObject{}

						var22.EncryptionState.Is = var21.EncryptionState.Is.ValueStringPointer()

						var22.EncryptionState.IsNot = var21.EncryptionState.IsNot.ValueStringPointer()
					}

					var22.Name = var21.Name.ValueString()
					input.Request.DiskEncryption.Criteria.EncryptedLocations = append(input.Request.DiskEncryption.Criteria.EncryptedLocations, var22)
				}
			}

			input.Request.DiskEncryption.Criteria.IsInstalled = plan.DiskEncryption.Criteria.IsInstalled.ValueBoolPointer()
		}

		input.Request.DiskEncryption.ExcludeVendor = plan.DiskEncryption.ExcludeVendor.ValueBoolPointer()

		if len(plan.DiskEncryption.Vendors) != 0 {
			input.Request.DiskEncryption.Vendors = make([]suxdMuj.DiskEncryptionVendorObject, 0, len(plan.DiskEncryption.Vendors))
			for _, var23 := range plan.DiskEncryption.Vendors {
				var var24 suxdMuj.DiskEncryptionVendorObject

				var24.Name = var23.Name.ValueString()

				resp.Diagnostics.Append(var23.Products.ElementsAs(ctx, &var24.Products, false)...)
				//if len(var23.Products) != 0 {
				//    var24.Products = make([]string, 0, len(var23.Products))
				//    for _, var25 := range var23.Products {
				//        var24.Products = append(var24.Products, var25.ValueString())
				//    }
				//}
				input.Request.DiskEncryption.Vendors = append(input.Request.DiskEncryption.Vendors, var24)
			}
		}
	}

	if plan.Firewall != nil {
		input.Request.Firewall = &suxdMuj.FirewallObject{}

		if plan.Firewall.Criteria != nil {
			input.Request.Firewall.Criteria = &suxdMuj.FirewallCriteriaObject{}

			input.Request.Firewall.Criteria.IsEnabled = plan.Firewall.Criteria.IsEnabled.ValueStringPointer()

			input.Request.Firewall.Criteria.IsInstalled = plan.Firewall.Criteria.IsInstalled.ValueBoolPointer()
		}

		input.Request.Firewall.ExcludeVendor = plan.Firewall.ExcludeVendor.ValueBoolPointer()

		if len(plan.Firewall.Vendors) != 0 {
			input.Request.Firewall.Vendors = make([]suxdMuj.FirewallVendorObject, 0, len(plan.Firewall.Vendors))
			for _, var26 := range plan.Firewall.Vendors {
				var var27 suxdMuj.FirewallVendorObject

				var27.Name = var26.Name.ValueString()

				resp.Diagnostics.Append(var26.Products.ElementsAs(ctx, &var27.Products, false)...)
				//if len(var26.Products) != 0 {
				//    var27.Products = make([]string, 0, len(var26.Products))
				//    for _, var28 := range var26.Products {
				//        var27.Products = append(var27.Products, var28.ValueString())
				//    }
				//}
				input.Request.Firewall.Vendors = append(input.Request.Firewall.Vendors, var27)
			}
		}
	}

	if plan.HostInfo != nil {
		input.Request.HostInfo = &suxdMuj.HostInfoObject{}

		if plan.HostInfo.Criteria.ClientVersion != nil {
			input.Request.HostInfo.Criteria.ClientVersion = &suxdMuj.ClientVersionObject{}

			input.Request.HostInfo.Criteria.ClientVersion.Contains = plan.HostInfo.Criteria.ClientVersion.Contains.ValueStringPointer()

			input.Request.HostInfo.Criteria.ClientVersion.Is = plan.HostInfo.Criteria.ClientVersion.Is.ValueStringPointer()

			input.Request.HostInfo.Criteria.ClientVersion.IsNot = plan.HostInfo.Criteria.ClientVersion.IsNot.ValueStringPointer()
		}

		if plan.HostInfo.Criteria.Domain != nil {
			input.Request.HostInfo.Criteria.Domain = &suxdMuj.DomainObject{}

			input.Request.HostInfo.Criteria.Domain.Contains = plan.HostInfo.Criteria.Domain.Contains.ValueStringPointer()

			input.Request.HostInfo.Criteria.Domain.Is = plan.HostInfo.Criteria.Domain.Is.ValueStringPointer()

			input.Request.HostInfo.Criteria.Domain.IsNot = plan.HostInfo.Criteria.Domain.IsNot.ValueStringPointer()
		}

		if plan.HostInfo.Criteria.HostId != nil {
			input.Request.HostInfo.Criteria.HostId = &suxdMuj.HostIdObject{}

			input.Request.HostInfo.Criteria.HostId.Contains = plan.HostInfo.Criteria.HostId.Contains.ValueStringPointer()

			input.Request.HostInfo.Criteria.HostId.Is = plan.HostInfo.Criteria.HostId.Is.ValueStringPointer()

			input.Request.HostInfo.Criteria.HostId.IsNot = plan.HostInfo.Criteria.HostId.IsNot.ValueStringPointer()
		}

		if plan.HostInfo.Criteria.HostName != nil {
			input.Request.HostInfo.Criteria.HostName = &suxdMuj.HostNameObject{}

			input.Request.HostInfo.Criteria.HostName.Contains = plan.HostInfo.Criteria.HostName.Contains.ValueStringPointer()

			input.Request.HostInfo.Criteria.HostName.Is = plan.HostInfo.Criteria.HostName.Is.ValueStringPointer()

			input.Request.HostInfo.Criteria.HostName.IsNot = plan.HostInfo.Criteria.HostName.IsNot.ValueStringPointer()
		}

		input.Request.HostInfo.Criteria.Managed = plan.HostInfo.Criteria.Managed.ValueBoolPointer()

		if plan.HostInfo.Criteria.Os != nil {
			input.Request.HostInfo.Criteria.Os = &suxdMuj.OsObject{}

			if plan.HostInfo.Criteria.Os.Contains != nil {
				input.Request.HostInfo.Criteria.Os.Contains = &suxdMuj.ContainsObject{}

				input.Request.HostInfo.Criteria.Os.Contains.Apple = plan.HostInfo.Criteria.Os.Contains.Apple.ValueStringPointer()

				input.Request.HostInfo.Criteria.Os.Contains.Google = plan.HostInfo.Criteria.Os.Contains.Google.ValueStringPointer()

				input.Request.HostInfo.Criteria.Os.Contains.Linux = plan.HostInfo.Criteria.Os.Contains.Linux.ValueStringPointer()

				input.Request.HostInfo.Criteria.Os.Contains.Microsoft = plan.HostInfo.Criteria.Os.Contains.Microsoft.ValueStringPointer()

				input.Request.HostInfo.Criteria.Os.Contains.Other = plan.HostInfo.Criteria.Os.Contains.Other.ValueStringPointer()
			}
		}

		if plan.HostInfo.Criteria.SerialNumber != nil {
			input.Request.HostInfo.Criteria.SerialNumber = &suxdMuj.SerialNumberObject{}

			input.Request.HostInfo.Criteria.SerialNumber.Contains = plan.HostInfo.Criteria.SerialNumber.Contains.ValueStringPointer()

			input.Request.HostInfo.Criteria.SerialNumber.Is = plan.HostInfo.Criteria.SerialNumber.Is.ValueStringPointer()

			input.Request.HostInfo.Criteria.SerialNumber.IsNot = plan.HostInfo.Criteria.SerialNumber.IsNot.ValueStringPointer()
		}
	}

	if plan.MobileDevice != nil {
		input.Request.MobileDevice = &suxdMuj.MobileDeviceObject{}

		if plan.MobileDevice.Criteria != nil {
			input.Request.MobileDevice.Criteria = &suxdMuj.MobileDeviceCriteriaObject{}

			if plan.MobileDevice.Criteria.Applications != nil {
				input.Request.MobileDevice.Criteria.Applications = &suxdMuj.ApplicationsObject{}

				if plan.MobileDevice.Criteria.Applications.HasMalware != nil {
					input.Request.MobileDevice.Criteria.Applications.HasMalware = &suxdMuj.HasMalwareObject{}

					if !plan.MobileDevice.Criteria.Applications.HasMalware.No.IsNull() && plan.MobileDevice.Criteria.Applications.HasMalware.No.ValueBool() {
						input.Request.MobileDevice.Criteria.Applications.HasMalware.No = map[string]interface{}{}
					}

					if plan.MobileDevice.Criteria.Applications.HasMalware.Yes != nil {
						input.Request.MobileDevice.Criteria.Applications.HasMalware.Yes = &suxdMuj.YesObject{}

						if len(plan.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes) != 0 {
							input.Request.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = make([]suxdMuj.ExcludeObject, 0, len(plan.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes))
							for _, var29 := range plan.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes {
								var var30 suxdMuj.ExcludeObject

								var30.Hash = var29.Hash.ValueStringPointer()

								var30.Name = var29.Name.ValueString()

								var30.Package = var29.Package.ValueStringPointer()
								input.Request.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = append(input.Request.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes, var30)
							}
						}
					}
				}

				input.Request.MobileDevice.Criteria.Applications.HasUnmanagedApp = plan.MobileDevice.Criteria.Applications.HasUnmanagedApp.ValueBoolPointer()

				if len(plan.MobileDevice.Criteria.Applications.Includes) != 0 {
					input.Request.MobileDevice.Criteria.Applications.Includes = make([]suxdMuj.IncludeObject, 0, len(plan.MobileDevice.Criteria.Applications.Includes))
					for _, var31 := range plan.MobileDevice.Criteria.Applications.Includes {
						var var32 suxdMuj.IncludeObject

						var32.Hash = var31.Hash.ValueStringPointer()

						var32.Name = var31.Name.ValueString()

						var32.Package = var31.Package.ValueStringPointer()
						input.Request.MobileDevice.Criteria.Applications.Includes = append(input.Request.MobileDevice.Criteria.Applications.Includes, var32)
					}
				}
			}

			input.Request.MobileDevice.Criteria.DiskEncrypted = plan.MobileDevice.Criteria.DiskEncrypted.ValueBoolPointer()

			if plan.MobileDevice.Criteria.Imei != nil {
				input.Request.MobileDevice.Criteria.Imei = &suxdMuj.ImeiObject{}

				input.Request.MobileDevice.Criteria.Imei.Contains = plan.MobileDevice.Criteria.Imei.Contains.ValueStringPointer()

				input.Request.MobileDevice.Criteria.Imei.Is = plan.MobileDevice.Criteria.Imei.Is.ValueStringPointer()

				input.Request.MobileDevice.Criteria.Imei.IsNot = plan.MobileDevice.Criteria.Imei.IsNot.ValueStringPointer()
			}

			input.Request.MobileDevice.Criteria.Jailbroken = plan.MobileDevice.Criteria.Jailbroken.ValueBoolPointer()

			if plan.MobileDevice.Criteria.LastCheckinTime != nil {
				input.Request.MobileDevice.Criteria.LastCheckinTime = &suxdMuj.LastCheckinTimeObject{}

				if plan.MobileDevice.Criteria.LastCheckinTime.NotWithin != nil {
					input.Request.MobileDevice.Criteria.LastCheckinTime.NotWithin = &suxdMuj.LastCheckinTimeNotWithinObject{}

					input.Request.MobileDevice.Criteria.LastCheckinTime.NotWithin.Days = plan.MobileDevice.Criteria.LastCheckinTime.NotWithin.Days.ValueInt64()
				}

				if plan.MobileDevice.Criteria.LastCheckinTime.Within != nil {
					input.Request.MobileDevice.Criteria.LastCheckinTime.Within = &suxdMuj.LastCheckinTimeWithinObject{}

					input.Request.MobileDevice.Criteria.LastCheckinTime.Within.Days = plan.MobileDevice.Criteria.LastCheckinTime.Within.Days.ValueInt64()
				}
			}

			if plan.MobileDevice.Criteria.Model != nil {
				input.Request.MobileDevice.Criteria.Model = &suxdMuj.ModelObject{}

				input.Request.MobileDevice.Criteria.Model.Contains = plan.MobileDevice.Criteria.Model.Contains.ValueStringPointer()

				input.Request.MobileDevice.Criteria.Model.Is = plan.MobileDevice.Criteria.Model.Is.ValueStringPointer()

				input.Request.MobileDevice.Criteria.Model.IsNot = plan.MobileDevice.Criteria.Model.IsNot.ValueStringPointer()
			}

			input.Request.MobileDevice.Criteria.PasscodeSet = plan.MobileDevice.Criteria.PasscodeSet.ValueBoolPointer()

			if plan.MobileDevice.Criteria.PhoneNumber != nil {
				input.Request.MobileDevice.Criteria.PhoneNumber = &suxdMuj.PhoneNumberObject{}

				input.Request.MobileDevice.Criteria.PhoneNumber.Contains = plan.MobileDevice.Criteria.PhoneNumber.Contains.ValueStringPointer()

				input.Request.MobileDevice.Criteria.PhoneNumber.Is = plan.MobileDevice.Criteria.PhoneNumber.Is.ValueStringPointer()

				input.Request.MobileDevice.Criteria.PhoneNumber.IsNot = plan.MobileDevice.Criteria.PhoneNumber.IsNot.ValueStringPointer()
			}

			if plan.MobileDevice.Criteria.Tag != nil {
				input.Request.MobileDevice.Criteria.Tag = &suxdMuj.TagObject{}

				input.Request.MobileDevice.Criteria.Tag.Contains = plan.MobileDevice.Criteria.Tag.Contains.ValueStringPointer()

				input.Request.MobileDevice.Criteria.Tag.Is = plan.MobileDevice.Criteria.Tag.Is.ValueStringPointer()

				input.Request.MobileDevice.Criteria.Tag.IsNot = plan.MobileDevice.Criteria.Tag.IsNot.ValueStringPointer()
			}
		}
	}

	input.Request.Name = plan.Name.ValueString()

	if plan.NetworkInfo != nil {
		input.Request.NetworkInfo = &suxdMuj.NetworkInfoObject{}

		if plan.NetworkInfo.Criteria != nil {
			input.Request.NetworkInfo.Criteria = &suxdMuj.NetworkInfoCriteriaObject{}

			if plan.NetworkInfo.Criteria.Network != nil {
				input.Request.NetworkInfo.Criteria.Network = &suxdMuj.NetworkObject{}

				if plan.NetworkInfo.Criteria.Network.Is != nil {
					input.Request.NetworkInfo.Criteria.Network.Is = &suxdMuj.IsObject{}

					if plan.NetworkInfo.Criteria.Network.Is.Mobile != nil {
						input.Request.NetworkInfo.Criteria.Network.Is.Mobile = &suxdMuj.IsMobileObject{}

						input.Request.NetworkInfo.Criteria.Network.Is.Mobile.Carrier = plan.NetworkInfo.Criteria.Network.Is.Mobile.Carrier.ValueStringPointer()
					}

					if !plan.NetworkInfo.Criteria.Network.Is.Unknown.IsNull() && plan.NetworkInfo.Criteria.Network.Is.Unknown.ValueBool() {
						input.Request.NetworkInfo.Criteria.Network.Is.Unknown = map[string]interface{}{}
					}

					if plan.NetworkInfo.Criteria.Network.Is.Wifi != nil {
						input.Request.NetworkInfo.Criteria.Network.Is.Wifi = &suxdMuj.IsWifiObject{}

						input.Request.NetworkInfo.Criteria.Network.Is.Wifi.Ssid = plan.NetworkInfo.Criteria.Network.Is.Wifi.Ssid.ValueStringPointer()
					}
				}

				if plan.NetworkInfo.Criteria.Network.IsNot != nil {
					input.Request.NetworkInfo.Criteria.Network.IsNot = &suxdMuj.IsNotObject{}

					if !plan.NetworkInfo.Criteria.Network.IsNot.Ethernet.IsNull() && plan.NetworkInfo.Criteria.Network.IsNot.Ethernet.ValueBool() {
						input.Request.NetworkInfo.Criteria.Network.IsNot.Ethernet = map[string]interface{}{}
					}

					if plan.NetworkInfo.Criteria.Network.IsNot.Mobile != nil {
						input.Request.NetworkInfo.Criteria.Network.IsNot.Mobile = &suxdMuj.IsNotMobileObject{}

						input.Request.NetworkInfo.Criteria.Network.IsNot.Mobile.Carrier = plan.NetworkInfo.Criteria.Network.IsNot.Mobile.Carrier.ValueStringPointer()
					}

					if !plan.NetworkInfo.Criteria.Network.IsNot.Unknown.IsNull() && plan.NetworkInfo.Criteria.Network.IsNot.Unknown.ValueBool() {
						input.Request.NetworkInfo.Criteria.Network.IsNot.Unknown = map[string]interface{}{}
					}

					if plan.NetworkInfo.Criteria.Network.IsNot.Wifi != nil {
						input.Request.NetworkInfo.Criteria.Network.IsNot.Wifi = &suxdMuj.IsNotWifiObject{}

						input.Request.NetworkInfo.Criteria.Network.IsNot.Wifi.Ssid = plan.NetworkInfo.Criteria.Network.IsNot.Wifi.Ssid.ValueStringPointer()
					}
				}
			}
		}
	}

	if plan.PatchManagement != nil {
		input.Request.PatchManagement = &suxdMuj.PatchManagementObject{}

		if plan.PatchManagement.Criteria != nil {
			input.Request.PatchManagement.Criteria = &suxdMuj.CriteriaObject{}

			input.Request.PatchManagement.Criteria.IsEnabled = plan.PatchManagement.Criteria.IsEnabled.ValueStringPointer()

			input.Request.PatchManagement.Criteria.IsInstalled = plan.PatchManagement.Criteria.IsInstalled.ValueBoolPointer()

			if plan.PatchManagement.Criteria.MissingPatches != nil {
				input.Request.PatchManagement.Criteria.MissingPatches = &suxdMuj.MissingPatchesObject{}

				input.Request.PatchManagement.Criteria.MissingPatches.Check = plan.PatchManagement.Criteria.MissingPatches.Check.ValueString()

				resp.Diagnostics.Append(plan.PatchManagement.Criteria.MissingPatches.Patches.ElementsAs(ctx, &input.Request.PatchManagement.Criteria.MissingPatches.Patches, false)...)
				//if len(plan.PatchManagement.Criteria.MissingPatches.Patches) != 0 {
				//    input.Request.PatchManagement.Criteria.MissingPatches.Patches = make([]string, 0, len(plan.PatchManagement.Criteria.MissingPatches.Patches))
				//    for _, var33 := range plan.PatchManagement.Criteria.MissingPatches.Patches {
				//        input.Request.PatchManagement.Criteria.MissingPatches.Patches = append(input.Request.PatchManagement.Criteria.MissingPatches.Patches, var33.ValueString())
				//    }
				//}

				if plan.PatchManagement.Criteria.MissingPatches.Severity != nil {
					input.Request.PatchManagement.Criteria.MissingPatches.Severity = &suxdMuj.SeverityObject{}

					input.Request.PatchManagement.Criteria.MissingPatches.Severity.GreaterEqual = plan.PatchManagement.Criteria.MissingPatches.Severity.GreaterEqual.ValueInt64Pointer()

					input.Request.PatchManagement.Criteria.MissingPatches.Severity.GreaterThan = plan.PatchManagement.Criteria.MissingPatches.Severity.GreaterThan.ValueInt64Pointer()

					input.Request.PatchManagement.Criteria.MissingPatches.Severity.Is = plan.PatchManagement.Criteria.MissingPatches.Severity.Is.ValueInt64Pointer()

					input.Request.PatchManagement.Criteria.MissingPatches.Severity.IsNot = plan.PatchManagement.Criteria.MissingPatches.Severity.IsNot.ValueInt64Pointer()

					input.Request.PatchManagement.Criteria.MissingPatches.Severity.LessEqual = plan.PatchManagement.Criteria.MissingPatches.Severity.LessEqual.ValueInt64Pointer()

					input.Request.PatchManagement.Criteria.MissingPatches.Severity.LessThan = plan.PatchManagement.Criteria.MissingPatches.Severity.LessThan.ValueInt64Pointer()
				}
			}
		}

		input.Request.PatchManagement.ExcludeVendor = plan.PatchManagement.ExcludeVendor.ValueBoolPointer()

		if len(plan.PatchManagement.Vendors) != 0 {
			input.Request.PatchManagement.Vendors = make([]suxdMuj.PatchManagementVendorObject, 0, len(plan.PatchManagement.Vendors))
			for _, var34 := range plan.PatchManagement.Vendors {
				var var35 suxdMuj.PatchManagementVendorObject

				var35.Name = var34.Name.ValueString()

				resp.Diagnostics.Append(var34.Products.ElementsAs(ctx, &var35.Products, false)...)
				//if len(var34.Products) != 0 {
				//    var35.Products = make([]string, 0, len(var34.Products))
				//    for _, var36 := range var34.Products {
				//        var35.Products = append(var35.Products, var36.ValueString())
				//    }
				//}
				input.Request.PatchManagement.Vendors = append(input.Request.PatchManagement.Vendors, var35)
			}
		}
	}

	// Perform the operation.
	ans, err := svc.Update(ctx, input)
	if err != nil {
		if IsObjectNotFound(err) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error updating resource", err.Error())
		}
		return
	}

	// Store the answer to state.
	// Note: when supporting importing a resource, this will need to change to taking
	// values from the savestate.Tfid param and locMap.

	if ans.AntiMalware == nil {
		state.AntiMalware = nil
	} else {
		state.AntiMalware = &hipObjectRsModel_suxdMuj_AntiMalwareObject{}

		if ans.AntiMalware.Criteria == nil {
			state.AntiMalware.Criteria = nil
		} else {
			state.AntiMalware.Criteria = &hipObjectRsModel_suxdMuj_AntiMalwareCriteriaObject{}

			state.AntiMalware.Criteria.IsInstalled = types.BoolPointerValue(ans.AntiMalware.Criteria.IsInstalled)

			if ans.AntiMalware.Criteria.LastScanTime == nil {
				state.AntiMalware.Criteria.LastScanTime = nil
			} else {
				state.AntiMalware.Criteria.LastScanTime = &hipObjectRsModel_suxdMuj_LastScanTimeObject{}

				if ans.AntiMalware.Criteria.LastScanTime.NotAvailable != nil {
					state.AntiMalware.Criteria.LastScanTime.NotAvailable = types.BoolValue(true)
				} else {
					state.AntiMalware.Criteria.LastScanTime.NotAvailable = types.BoolPointerValue(nil)
				}
				//state.AntiMalware.Criteria.LastScanTime.NotAvailable = types.BoolValue(ans.AntiMalware.Criteria.LastScanTime.NotAvailable != nil)

				if ans.AntiMalware.Criteria.LastScanTime.NotWithin == nil {
					state.AntiMalware.Criteria.LastScanTime.NotWithin = nil
				} else {
					state.AntiMalware.Criteria.LastScanTime.NotWithin = &hipObjectRsModel_suxdMuj_LastScanTimeNotWithinObject{}

					state.AntiMalware.Criteria.LastScanTime.NotWithin.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.NotWithin.Days)

					state.AntiMalware.Criteria.LastScanTime.NotWithin.Hours = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.NotWithin.Hours)
				}

				if ans.AntiMalware.Criteria.LastScanTime.Within == nil {
					state.AntiMalware.Criteria.LastScanTime.Within = nil
				} else {
					state.AntiMalware.Criteria.LastScanTime.Within = &hipObjectRsModel_suxdMuj_LastScanTimeWithinObject{}

					state.AntiMalware.Criteria.LastScanTime.Within.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.Within.Days)

					state.AntiMalware.Criteria.LastScanTime.Within.Hours = types.Int64PointerValue(ans.AntiMalware.Criteria.LastScanTime.Within.Hours)
				}
			}

			if ans.AntiMalware.Criteria.ProductVersion == nil {
				state.AntiMalware.Criteria.ProductVersion = nil
			} else {
				state.AntiMalware.Criteria.ProductVersion = &hipObjectRsModel_suxdMuj_ProductVersionObject{}

				state.AntiMalware.Criteria.ProductVersion.Contains = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.Contains)

				state.AntiMalware.Criteria.ProductVersion.GreaterEqual = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.GreaterEqual)

				state.AntiMalware.Criteria.ProductVersion.GreaterThan = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.GreaterThan)

				state.AntiMalware.Criteria.ProductVersion.Is = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.Is)

				state.AntiMalware.Criteria.ProductVersion.IsNot = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.IsNot)

				state.AntiMalware.Criteria.ProductVersion.LessEqual = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.LessEqual)

				state.AntiMalware.Criteria.ProductVersion.LessThan = types.StringPointerValue(ans.AntiMalware.Criteria.ProductVersion.LessThan)

				if ans.AntiMalware.Criteria.ProductVersion.NotWithin == nil {
					state.AntiMalware.Criteria.ProductVersion.NotWithin = nil
				} else {
					state.AntiMalware.Criteria.ProductVersion.NotWithin = &hipObjectRsModel_suxdMuj_ProductVersionNotWithinObject{}

					state.AntiMalware.Criteria.ProductVersion.NotWithin.Versions = types.Int64Value(ans.AntiMalware.Criteria.ProductVersion.NotWithin.Versions)
				}

				if ans.AntiMalware.Criteria.ProductVersion.Within == nil {
					state.AntiMalware.Criteria.ProductVersion.Within = nil
				} else {
					state.AntiMalware.Criteria.ProductVersion.Within = &hipObjectRsModel_suxdMuj_ProductVersionWithinObject{}

					state.AntiMalware.Criteria.ProductVersion.Within.Versions = types.Int64Value(ans.AntiMalware.Criteria.ProductVersion.Within.Versions)
				}
			}

			state.AntiMalware.Criteria.RealTimeProtection = types.StringPointerValue(ans.AntiMalware.Criteria.RealTimeProtection)

			if ans.AntiMalware.Criteria.VirdefVersion == nil {
				state.AntiMalware.Criteria.VirdefVersion = nil
			} else {
				state.AntiMalware.Criteria.VirdefVersion = &hipObjectRsModel_suxdMuj_VirdefVersionObject{}

				if ans.AntiMalware.Criteria.VirdefVersion.NotWithin == nil {
					state.AntiMalware.Criteria.VirdefVersion.NotWithin = nil
				} else {
					state.AntiMalware.Criteria.VirdefVersion.NotWithin = &hipObjectRsModel_suxdMuj_VirdefVersionNotWithinObject{}

					state.AntiMalware.Criteria.VirdefVersion.NotWithin.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.NotWithin.Days)

					state.AntiMalware.Criteria.VirdefVersion.NotWithin.Versions = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.NotWithin.Versions)
				}

				if ans.AntiMalware.Criteria.VirdefVersion.Within == nil {
					state.AntiMalware.Criteria.VirdefVersion.Within = nil
				} else {
					state.AntiMalware.Criteria.VirdefVersion.Within = &hipObjectRsModel_suxdMuj_VirdefVersionWithinObject{}

					state.AntiMalware.Criteria.VirdefVersion.Within.Days = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.Within.Days)

					state.AntiMalware.Criteria.VirdefVersion.Within.Versions = types.Int64PointerValue(ans.AntiMalware.Criteria.VirdefVersion.Within.Versions)
				}
			}
		}

		state.AntiMalware.ExcludeVendor = types.BoolPointerValue(ans.AntiMalware.ExcludeVendor)

		if len(ans.AntiMalware.Vendors) == 0 {
			state.AntiMalware.Vendors = nil
		} else {
			state.AntiMalware.Vendors = make([]hipObjectRsModel_suxdMuj_AntiMalwareVendorObject, 0, len(ans.AntiMalware.Vendors))
			for _, var37 := range ans.AntiMalware.Vendors {
				var38 := hipObjectRsModel_suxdMuj_AntiMalwareVendorObject{}

				var38.Name = types.StringValue(var37.Name)

				var39, var40 := types.ListValueFrom(ctx, types.StringType, var37.Products)
				var38.Products = var39
				resp.Diagnostics.Append(var40.Errors()...)
				state.AntiMalware.Vendors = append(state.AntiMalware.Vendors, var38)
			}
		}
	}

	if ans.Certificate == nil {
		state.Certificate = nil
	} else {
		state.Certificate = &hipObjectRsModel_suxdMuj_CertificateObject{}

		if ans.Certificate.Criteria == nil {
			state.Certificate.Criteria = nil
		} else {
			state.Certificate.Criteria = &hipObjectRsModel_suxdMuj_CertificateCriteriaObject{}

			if len(ans.Certificate.Criteria.CertificateAttributes) == 0 {
				state.Certificate.Criteria.CertificateAttributes = nil
			} else {
				state.Certificate.Criteria.CertificateAttributes = make([]hipObjectRsModel_suxdMuj_CertificateAttributeObject, 0, len(ans.Certificate.Criteria.CertificateAttributes))
				for _, var41 := range ans.Certificate.Criteria.CertificateAttributes {
					var42 := hipObjectRsModel_suxdMuj_CertificateAttributeObject{}

					var42.Name = types.StringValue(var41.Name)

					var42.Value = types.StringPointerValue(var41.Value)
					state.Certificate.Criteria.CertificateAttributes = append(state.Certificate.Criteria.CertificateAttributes, var42)
				}
			}

			state.Certificate.Criteria.CertificateProfile = types.StringPointerValue(ans.Certificate.Criteria.CertificateProfile)
		}
	}

	if ans.CustomChecks == nil {
		state.CustomChecks = nil
	} else {
		state.CustomChecks = &hipObjectRsModel_suxdMuj_CustomChecksObject{}

		state.CustomChecks.Criteria = hipObjectRsModel_suxdMuj_CustomChecksCriteriaObject{}

		if len(ans.CustomChecks.Criteria.Plist) == 0 {
			state.CustomChecks.Criteria.Plist = nil
		} else {
			state.CustomChecks.Criteria.Plist = make([]hipObjectRsModel_suxdMuj_PlistObject, 0, len(ans.CustomChecks.Criteria.Plist))
			for _, var43 := range ans.CustomChecks.Criteria.Plist {
				var44 := hipObjectRsModel_suxdMuj_PlistObject{}

				if len(var43.Keys) == 0 {
					var44.Keys = nil
				} else {
					var44.Keys = make([]hipObjectRsModel_suxdMuj_KeyObject, 0, len(var43.Keys))
					for _, var45 := range var43.Keys {
						var46 := hipObjectRsModel_suxdMuj_KeyObject{}

						var46.Name = types.StringValue(var45.Name)

						var46.Negate = types.BoolPointerValue(var45.Negate)

						var46.Value = types.StringPointerValue(var45.Value)
						var44.Keys = append(var44.Keys, var46)
					}
				}

				var44.Name = types.StringValue(var43.Name)

				var44.Negate = types.BoolPointerValue(var43.Negate)
				state.CustomChecks.Criteria.Plist = append(state.CustomChecks.Criteria.Plist, var44)
			}
		}

		if len(ans.CustomChecks.Criteria.ProcessList) == 0 {
			state.CustomChecks.Criteria.ProcessList = nil
		} else {
			state.CustomChecks.Criteria.ProcessList = make([]hipObjectRsModel_suxdMuj_ProcessListObject, 0, len(ans.CustomChecks.Criteria.ProcessList))
			for _, var47 := range ans.CustomChecks.Criteria.ProcessList {
				var48 := hipObjectRsModel_suxdMuj_ProcessListObject{}

				var48.Name = types.StringValue(var47.Name)

				var48.Running = types.BoolPointerValue(var47.Running)
				state.CustomChecks.Criteria.ProcessList = append(state.CustomChecks.Criteria.ProcessList, var48)
			}
		}

		if len(ans.CustomChecks.Criteria.RegistryKeys) == 0 {
			state.CustomChecks.Criteria.RegistryKeys = nil
		} else {
			state.CustomChecks.Criteria.RegistryKeys = make([]hipObjectRsModel_suxdMuj_RegistryKeyObject, 0, len(ans.CustomChecks.Criteria.RegistryKeys))
			for _, var49 := range ans.CustomChecks.Criteria.RegistryKeys {
				var50 := hipObjectRsModel_suxdMuj_RegistryKeyObject{}

				var50.DefaultValueData = types.StringPointerValue(var49.DefaultValueData)

				var50.Name = types.StringValue(var49.Name)

				var50.Negate = types.BoolPointerValue(var49.Negate)

				if len(var49.RegistryValues) == 0 {
					var50.RegistryValues = nil
				} else {
					var50.RegistryValues = make([]hipObjectRsModel_suxdMuj_RegistryValueObject, 0, len(var49.RegistryValues))
					for _, var51 := range var49.RegistryValues {
						var52 := hipObjectRsModel_suxdMuj_RegistryValueObject{}

						var52.Name = types.StringValue(var51.Name)

						var52.Negate = types.BoolPointerValue(var51.Negate)

						var52.ValueData = types.StringPointerValue(var51.ValueData)
						var50.RegistryValues = append(var50.RegistryValues, var52)
					}
				}
				state.CustomChecks.Criteria.RegistryKeys = append(state.CustomChecks.Criteria.RegistryKeys, var50)
			}
		}
	}

	if ans.DataLossPrevention == nil {
		state.DataLossPrevention = nil
	} else {
		state.DataLossPrevention = &hipObjectRsModel_suxdMuj_DataLossPreventionObject{}

		if ans.DataLossPrevention.Criteria == nil {
			state.DataLossPrevention.Criteria = nil
		} else {
			state.DataLossPrevention.Criteria = &hipObjectRsModel_suxdMuj_DataLossPreventionCriteriaObject{}

			state.DataLossPrevention.Criteria.IsEnabled = types.StringPointerValue(ans.DataLossPrevention.Criteria.IsEnabled)

			state.DataLossPrevention.Criteria.IsInstalled = types.BoolPointerValue(ans.DataLossPrevention.Criteria.IsInstalled)
		}

		state.DataLossPrevention.ExcludeVendor = types.BoolPointerValue(ans.DataLossPrevention.ExcludeVendor)

		if len(ans.DataLossPrevention.Vendors) == 0 {
			state.DataLossPrevention.Vendors = nil
		} else {
			state.DataLossPrevention.Vendors = make([]hipObjectRsModel_suxdMuj_DataLossPreventionVendorObject, 0, len(ans.DataLossPrevention.Vendors))
			for _, var53 := range ans.DataLossPrevention.Vendors {
				var54 := hipObjectRsModel_suxdMuj_DataLossPreventionVendorObject{}

				var54.Name = types.StringValue(var53.Name)

				var55, var56 := types.ListValueFrom(ctx, types.StringType, var53.Products)
				var54.Products = var55
				resp.Diagnostics.Append(var56.Errors()...)
				state.DataLossPrevention.Vendors = append(state.DataLossPrevention.Vendors, var54)
			}
		}
	}

	state.Description = types.StringPointerValue(ans.Description)

	if ans.DiskBackup == nil {
		state.DiskBackup = nil
	} else {
		state.DiskBackup = &hipObjectRsModel_suxdMuj_DiskBackupObject{}

		if ans.DiskBackup.Criteria == nil {
			state.DiskBackup.Criteria = nil
		} else {
			state.DiskBackup.Criteria = &hipObjectRsModel_suxdMuj_DiskBackupCriteriaObject{}

			state.DiskBackup.Criteria.IsInstalled = types.BoolPointerValue(ans.DiskBackup.Criteria.IsInstalled)

			if ans.DiskBackup.Criteria.LastBackupTime == nil {
				state.DiskBackup.Criteria.LastBackupTime = nil
			} else {
				state.DiskBackup.Criteria.LastBackupTime = &hipObjectRsModel_suxdMuj_LastBackupTimeObject{}

				if ans.DiskBackup.Criteria.LastBackupTime.NotAvailable != nil {
					state.DiskBackup.Criteria.LastBackupTime.NotAvailable = types.BoolValue(true)
				} else {
					state.DiskBackup.Criteria.LastBackupTime.NotAvailable = types.BoolPointerValue(nil)
				}
				//state.DiskBackup.Criteria.LastBackupTime.NotAvailable = types.BoolValue(ans.DiskBackup.Criteria.LastBackupTime.NotAvailable != nil)

				if ans.DiskBackup.Criteria.LastBackupTime.NotWithin == nil {
					state.DiskBackup.Criteria.LastBackupTime.NotWithin = nil
				} else {
					state.DiskBackup.Criteria.LastBackupTime.NotWithin = &hipObjectRsModel_suxdMuj_LastBackupTimeNotWithinObject{}

					state.DiskBackup.Criteria.LastBackupTime.NotWithin.Days = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.NotWithin.Days)

					state.DiskBackup.Criteria.LastBackupTime.NotWithin.Hours = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.NotWithin.Hours)
				}

				if ans.DiskBackup.Criteria.LastBackupTime.Within == nil {
					state.DiskBackup.Criteria.LastBackupTime.Within = nil
				} else {
					state.DiskBackup.Criteria.LastBackupTime.Within = &hipObjectRsModel_suxdMuj_LastBackupTimeWithinObject{}

					state.DiskBackup.Criteria.LastBackupTime.Within.Days = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.Within.Days)

					state.DiskBackup.Criteria.LastBackupTime.Within.Hours = types.Int64PointerValue(ans.DiskBackup.Criteria.LastBackupTime.Within.Hours)
				}
			}
		}

		state.DiskBackup.ExcludeVendor = types.BoolPointerValue(ans.DiskBackup.ExcludeVendor)

		if len(ans.DiskBackup.Vendors) == 0 {
			state.DiskBackup.Vendors = nil
		} else {
			state.DiskBackup.Vendors = make([]hipObjectRsModel_suxdMuj_DiskBackupVendorObject, 0, len(ans.DiskBackup.Vendors))
			for _, var57 := range ans.DiskBackup.Vendors {
				var58 := hipObjectRsModel_suxdMuj_DiskBackupVendorObject{}

				var58.Name = types.StringValue(var57.Name)

				var59, var60 := types.ListValueFrom(ctx, types.StringType, var57.Products)
				var58.Products = var59
				resp.Diagnostics.Append(var60.Errors()...)
				state.DiskBackup.Vendors = append(state.DiskBackup.Vendors, var58)
			}
		}
	}

	if ans.DiskEncryption == nil {
		state.DiskEncryption = nil
	} else {
		state.DiskEncryption = &hipObjectRsModel_suxdMuj_DiskEncryptionObject{}

		if ans.DiskEncryption.Criteria == nil {
			state.DiskEncryption.Criteria = nil
		} else {
			state.DiskEncryption.Criteria = &hipObjectRsModel_suxdMuj_DiskEncryptionCriteriaObject{}

			if len(ans.DiskEncryption.Criteria.EncryptedLocations) == 0 {
				state.DiskEncryption.Criteria.EncryptedLocations = nil
			} else {
				state.DiskEncryption.Criteria.EncryptedLocations = make([]hipObjectRsModel_suxdMuj_EncryptedLocationObject, 0, len(ans.DiskEncryption.Criteria.EncryptedLocations))
				for _, var61 := range ans.DiskEncryption.Criteria.EncryptedLocations {
					var62 := hipObjectRsModel_suxdMuj_EncryptedLocationObject{}

					if var61.EncryptionState == nil {
						var62.EncryptionState = nil
					} else {
						var62.EncryptionState = &hipObjectRsModel_suxdMuj_EncryptionStateObject{}

						var62.EncryptionState.Is = types.StringPointerValue(var61.EncryptionState.Is)

						var62.EncryptionState.IsNot = types.StringPointerValue(var61.EncryptionState.IsNot)
					}

					var62.Name = types.StringValue(var61.Name)
					state.DiskEncryption.Criteria.EncryptedLocations = append(state.DiskEncryption.Criteria.EncryptedLocations, var62)
				}
			}

			state.DiskEncryption.Criteria.IsInstalled = types.BoolPointerValue(ans.DiskEncryption.Criteria.IsInstalled)
		}

		state.DiskEncryption.ExcludeVendor = types.BoolPointerValue(ans.DiskEncryption.ExcludeVendor)

		if len(ans.DiskEncryption.Vendors) == 0 {
			state.DiskEncryption.Vendors = nil
		} else {
			state.DiskEncryption.Vendors = make([]hipObjectRsModel_suxdMuj_DiskEncryptionVendorObject, 0, len(ans.DiskEncryption.Vendors))
			for _, var63 := range ans.DiskEncryption.Vendors {
				var64 := hipObjectRsModel_suxdMuj_DiskEncryptionVendorObject{}

				var64.Name = types.StringValue(var63.Name)

				var65, var66 := types.ListValueFrom(ctx, types.StringType, var63.Products)
				var64.Products = var65
				resp.Diagnostics.Append(var66.Errors()...)
				state.DiskEncryption.Vendors = append(state.DiskEncryption.Vendors, var64)
			}
		}
	}

	if ans.Firewall == nil {
		state.Firewall = nil
	} else {
		state.Firewall = &hipObjectRsModel_suxdMuj_FirewallObject{}

		if ans.Firewall.Criteria == nil {
			state.Firewall.Criteria = nil
		} else {
			state.Firewall.Criteria = &hipObjectRsModel_suxdMuj_FirewallCriteriaObject{}

			state.Firewall.Criteria.IsEnabled = types.StringPointerValue(ans.Firewall.Criteria.IsEnabled)

			state.Firewall.Criteria.IsInstalled = types.BoolPointerValue(ans.Firewall.Criteria.IsInstalled)
		}

		state.Firewall.ExcludeVendor = types.BoolPointerValue(ans.Firewall.ExcludeVendor)

		if len(ans.Firewall.Vendors) == 0 {
			state.Firewall.Vendors = nil
		} else {
			state.Firewall.Vendors = make([]hipObjectRsModel_suxdMuj_FirewallVendorObject, 0, len(ans.Firewall.Vendors))
			for _, var67 := range ans.Firewall.Vendors {
				var68 := hipObjectRsModel_suxdMuj_FirewallVendorObject{}

				var68.Name = types.StringValue(var67.Name)

				var69, var70 := types.ListValueFrom(ctx, types.StringType, var67.Products)
				var68.Products = var69
				resp.Diagnostics.Append(var70.Errors()...)
				state.Firewall.Vendors = append(state.Firewall.Vendors, var68)
			}
		}
	}

	if ans.HostInfo == nil {
		state.HostInfo = nil
	} else {
		state.HostInfo = &hipObjectRsModel_suxdMuj_HostInfoObject{}

		state.HostInfo.Criteria = hipObjectRsModel_suxdMuj_HostInfoCriteriaObject{}

		if ans.HostInfo.Criteria.ClientVersion == nil {
			state.HostInfo.Criteria.ClientVersion = nil
		} else {
			state.HostInfo.Criteria.ClientVersion = &hipObjectRsModel_suxdMuj_ClientVersionObject{}

			state.HostInfo.Criteria.ClientVersion.Contains = types.StringPointerValue(ans.HostInfo.Criteria.ClientVersion.Contains)

			state.HostInfo.Criteria.ClientVersion.Is = types.StringPointerValue(ans.HostInfo.Criteria.ClientVersion.Is)

			state.HostInfo.Criteria.ClientVersion.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.ClientVersion.IsNot)
		}

		if ans.HostInfo.Criteria.Domain == nil {
			state.HostInfo.Criteria.Domain = nil
		} else {
			state.HostInfo.Criteria.Domain = &hipObjectRsModel_suxdMuj_DomainObject{}

			state.HostInfo.Criteria.Domain.Contains = types.StringPointerValue(ans.HostInfo.Criteria.Domain.Contains)

			state.HostInfo.Criteria.Domain.Is = types.StringPointerValue(ans.HostInfo.Criteria.Domain.Is)

			state.HostInfo.Criteria.Domain.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.Domain.IsNot)
		}

		if ans.HostInfo.Criteria.HostId == nil {
			state.HostInfo.Criteria.HostId = nil
		} else {
			state.HostInfo.Criteria.HostId = &hipObjectRsModel_suxdMuj_HostIdObject{}

			state.HostInfo.Criteria.HostId.Contains = types.StringPointerValue(ans.HostInfo.Criteria.HostId.Contains)

			state.HostInfo.Criteria.HostId.Is = types.StringPointerValue(ans.HostInfo.Criteria.HostId.Is)

			state.HostInfo.Criteria.HostId.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.HostId.IsNot)
		}

		if ans.HostInfo.Criteria.HostName == nil {
			state.HostInfo.Criteria.HostName = nil
		} else {
			state.HostInfo.Criteria.HostName = &hipObjectRsModel_suxdMuj_HostNameObject{}

			state.HostInfo.Criteria.HostName.Contains = types.StringPointerValue(ans.HostInfo.Criteria.HostName.Contains)

			state.HostInfo.Criteria.HostName.Is = types.StringPointerValue(ans.HostInfo.Criteria.HostName.Is)

			state.HostInfo.Criteria.HostName.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.HostName.IsNot)
		}

		state.HostInfo.Criteria.Managed = types.BoolPointerValue(ans.HostInfo.Criteria.Managed)

		if ans.HostInfo.Criteria.Os == nil {
			state.HostInfo.Criteria.Os = nil
		} else {
			state.HostInfo.Criteria.Os = &hipObjectRsModel_suxdMuj_OsObject{}

			if ans.HostInfo.Criteria.Os.Contains == nil {
				state.HostInfo.Criteria.Os.Contains = nil
			} else {
				state.HostInfo.Criteria.Os.Contains = &hipObjectRsModel_suxdMuj_ContainsObject{}

				state.HostInfo.Criteria.Os.Contains.Apple = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Apple)

				state.HostInfo.Criteria.Os.Contains.Google = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Google)

				state.HostInfo.Criteria.Os.Contains.Linux = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Linux)

				state.HostInfo.Criteria.Os.Contains.Microsoft = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Microsoft)

				state.HostInfo.Criteria.Os.Contains.Other = types.StringPointerValue(ans.HostInfo.Criteria.Os.Contains.Other)
			}
		}

		if ans.HostInfo.Criteria.SerialNumber == nil {
			state.HostInfo.Criteria.SerialNumber = nil
		} else {
			state.HostInfo.Criteria.SerialNumber = &hipObjectRsModel_suxdMuj_SerialNumberObject{}

			state.HostInfo.Criteria.SerialNumber.Contains = types.StringPointerValue(ans.HostInfo.Criteria.SerialNumber.Contains)

			state.HostInfo.Criteria.SerialNumber.Is = types.StringPointerValue(ans.HostInfo.Criteria.SerialNumber.Is)

			state.HostInfo.Criteria.SerialNumber.IsNot = types.StringPointerValue(ans.HostInfo.Criteria.SerialNumber.IsNot)
		}
	}

	state.Id = types.StringPointerValue(ans.Id)

	if ans.MobileDevice == nil {
		state.MobileDevice = nil
	} else {
		state.MobileDevice = &hipObjectRsModel_suxdMuj_MobileDeviceObject{}

		if ans.MobileDevice.Criteria == nil {
			state.MobileDevice.Criteria = nil
		} else {
			state.MobileDevice.Criteria = &hipObjectRsModel_suxdMuj_MobileDeviceCriteriaObject{}

			if ans.MobileDevice.Criteria.Applications == nil {
				state.MobileDevice.Criteria.Applications = nil
			} else {
				state.MobileDevice.Criteria.Applications = &hipObjectRsModel_suxdMuj_ApplicationsObject{}

				if ans.MobileDevice.Criteria.Applications.HasMalware == nil {
					state.MobileDevice.Criteria.Applications.HasMalware = nil
				} else {
					state.MobileDevice.Criteria.Applications.HasMalware = &hipObjectRsModel_suxdMuj_HasMalwareObject{}

					if ans.MobileDevice.Criteria.Applications.HasMalware.No != nil {
						state.MobileDevice.Criteria.Applications.HasMalware.No = types.BoolValue(true)
					} else {
						state.MobileDevice.Criteria.Applications.HasMalware.No = types.BoolPointerValue(nil)
					}
					//state.MobileDevice.Criteria.Applications.HasMalware.No = types.BoolValue(ans.MobileDevice.Criteria.Applications.HasMalware.No != nil)

					if ans.MobileDevice.Criteria.Applications.HasMalware.Yes == nil {
						state.MobileDevice.Criteria.Applications.HasMalware.Yes = nil
					} else {
						state.MobileDevice.Criteria.Applications.HasMalware.Yes = &hipObjectRsModel_suxdMuj_YesObject{}

						if len(ans.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes) == 0 {
							state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = nil
						} else {
							state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = make([]hipObjectRsModel_suxdMuj_ExcludeObject, 0, len(ans.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes))
							for _, var71 := range ans.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes {
								var72 := hipObjectRsModel_suxdMuj_ExcludeObject{}

								var72.Hash = types.StringPointerValue(var71.Hash)

								var72.Name = types.StringValue(var71.Name)

								var72.Package = types.StringPointerValue(var71.Package)
								state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes = append(state.MobileDevice.Criteria.Applications.HasMalware.Yes.Excludes, var72)
							}
						}
					}
				}

				state.MobileDevice.Criteria.Applications.HasUnmanagedApp = types.BoolPointerValue(ans.MobileDevice.Criteria.Applications.HasUnmanagedApp)

				if len(ans.MobileDevice.Criteria.Applications.Includes) == 0 {
					state.MobileDevice.Criteria.Applications.Includes = nil
				} else {
					state.MobileDevice.Criteria.Applications.Includes = make([]hipObjectRsModel_suxdMuj_IncludeObject, 0, len(ans.MobileDevice.Criteria.Applications.Includes))
					for _, var73 := range ans.MobileDevice.Criteria.Applications.Includes {
						var74 := hipObjectRsModel_suxdMuj_IncludeObject{}

						var74.Hash = types.StringPointerValue(var73.Hash)

						var74.Name = types.StringValue(var73.Name)

						var74.Package = types.StringPointerValue(var73.Package)
						state.MobileDevice.Criteria.Applications.Includes = append(state.MobileDevice.Criteria.Applications.Includes, var74)
					}
				}
			}

			state.MobileDevice.Criteria.DiskEncrypted = types.BoolPointerValue(ans.MobileDevice.Criteria.DiskEncrypted)

			if ans.MobileDevice.Criteria.Imei == nil {
				state.MobileDevice.Criteria.Imei = nil
			} else {
				state.MobileDevice.Criteria.Imei = &hipObjectRsModel_suxdMuj_ImeiObject{}

				state.MobileDevice.Criteria.Imei.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.Imei.Contains)

				state.MobileDevice.Criteria.Imei.Is = types.StringPointerValue(ans.MobileDevice.Criteria.Imei.Is)

				state.MobileDevice.Criteria.Imei.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.Imei.IsNot)
			}

			state.MobileDevice.Criteria.Jailbroken = types.BoolPointerValue(ans.MobileDevice.Criteria.Jailbroken)

			if ans.MobileDevice.Criteria.LastCheckinTime == nil {
				state.MobileDevice.Criteria.LastCheckinTime = nil
			} else {
				state.MobileDevice.Criteria.LastCheckinTime = &hipObjectRsModel_suxdMuj_LastCheckinTimeObject{}

				if ans.MobileDevice.Criteria.LastCheckinTime.NotWithin == nil {
					state.MobileDevice.Criteria.LastCheckinTime.NotWithin = nil
				} else {
					state.MobileDevice.Criteria.LastCheckinTime.NotWithin = &hipObjectRsModel_suxdMuj_LastCheckinTimeNotWithinObject{}

					state.MobileDevice.Criteria.LastCheckinTime.NotWithin.Days = types.Int64Value(ans.MobileDevice.Criteria.LastCheckinTime.NotWithin.Days)
				}

				if ans.MobileDevice.Criteria.LastCheckinTime.Within == nil {
					state.MobileDevice.Criteria.LastCheckinTime.Within = nil
				} else {
					state.MobileDevice.Criteria.LastCheckinTime.Within = &hipObjectRsModel_suxdMuj_LastCheckinTimeWithinObject{}

					state.MobileDevice.Criteria.LastCheckinTime.Within.Days = types.Int64Value(ans.MobileDevice.Criteria.LastCheckinTime.Within.Days)
				}
			}

			if ans.MobileDevice.Criteria.Model == nil {
				state.MobileDevice.Criteria.Model = nil
			} else {
				state.MobileDevice.Criteria.Model = &hipObjectRsModel_suxdMuj_ModelObject{}

				state.MobileDevice.Criteria.Model.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.Model.Contains)

				state.MobileDevice.Criteria.Model.Is = types.StringPointerValue(ans.MobileDevice.Criteria.Model.Is)

				state.MobileDevice.Criteria.Model.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.Model.IsNot)
			}

			state.MobileDevice.Criteria.PasscodeSet = types.BoolPointerValue(ans.MobileDevice.Criteria.PasscodeSet)

			if ans.MobileDevice.Criteria.PhoneNumber == nil {
				state.MobileDevice.Criteria.PhoneNumber = nil
			} else {
				state.MobileDevice.Criteria.PhoneNumber = &hipObjectRsModel_suxdMuj_PhoneNumberObject{}

				state.MobileDevice.Criteria.PhoneNumber.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.PhoneNumber.Contains)

				state.MobileDevice.Criteria.PhoneNumber.Is = types.StringPointerValue(ans.MobileDevice.Criteria.PhoneNumber.Is)

				state.MobileDevice.Criteria.PhoneNumber.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.PhoneNumber.IsNot)
			}

			if ans.MobileDevice.Criteria.Tag == nil {
				state.MobileDevice.Criteria.Tag = nil
			} else {
				state.MobileDevice.Criteria.Tag = &hipObjectRsModel_suxdMuj_TagObject{}

				state.MobileDevice.Criteria.Tag.Contains = types.StringPointerValue(ans.MobileDevice.Criteria.Tag.Contains)

				state.MobileDevice.Criteria.Tag.Is = types.StringPointerValue(ans.MobileDevice.Criteria.Tag.Is)

				state.MobileDevice.Criteria.Tag.IsNot = types.StringPointerValue(ans.MobileDevice.Criteria.Tag.IsNot)
			}
		}
	}

	state.Name = types.StringValue(ans.Name)

	if ans.NetworkInfo == nil {
		state.NetworkInfo = nil
	} else {
		state.NetworkInfo = &hipObjectRsModel_suxdMuj_NetworkInfoObject{}

		if ans.NetworkInfo.Criteria == nil {
			state.NetworkInfo.Criteria = nil
		} else {
			state.NetworkInfo.Criteria = &hipObjectRsModel_suxdMuj_NetworkInfoCriteriaObject{}

			if ans.NetworkInfo.Criteria.Network == nil {
				state.NetworkInfo.Criteria.Network = nil
			} else {
				state.NetworkInfo.Criteria.Network = &hipObjectRsModel_suxdMuj_NetworkObject{}

				if ans.NetworkInfo.Criteria.Network.Is == nil {
					state.NetworkInfo.Criteria.Network.Is = nil
				} else {
					state.NetworkInfo.Criteria.Network.Is = &hipObjectRsModel_suxdMuj_IsObject{}

					if ans.NetworkInfo.Criteria.Network.Is.Mobile == nil {
						state.NetworkInfo.Criteria.Network.Is.Mobile = nil
					} else {
						state.NetworkInfo.Criteria.Network.Is.Mobile = &hipObjectRsModel_suxdMuj_IsMobileObject{}

						state.NetworkInfo.Criteria.Network.Is.Mobile.Carrier = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.Is.Mobile.Carrier)
					}

					if ans.NetworkInfo.Criteria.Network.Is.Unknown != nil {
						state.NetworkInfo.Criteria.Network.Is.Unknown = types.BoolValue(true)
					} else {
						state.NetworkInfo.Criteria.Network.Is.Unknown = types.BoolPointerValue(nil)
					}
					//state.NetworkInfo.Criteria.Network.Is.Unknown = types.BoolValue(ans.NetworkInfo.Criteria.Network.Is.Unknown != nil)

					if ans.NetworkInfo.Criteria.Network.Is.Wifi == nil {
						state.NetworkInfo.Criteria.Network.Is.Wifi = nil
					} else {
						state.NetworkInfo.Criteria.Network.Is.Wifi = &hipObjectRsModel_suxdMuj_IsWifiObject{}

						state.NetworkInfo.Criteria.Network.Is.Wifi.Ssid = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.Is.Wifi.Ssid)
					}
				}

				if ans.NetworkInfo.Criteria.Network.IsNot == nil {
					state.NetworkInfo.Criteria.Network.IsNot = nil
				} else {
					state.NetworkInfo.Criteria.Network.IsNot = &hipObjectRsModel_suxdMuj_IsNotObject{}

					if ans.NetworkInfo.Criteria.Network.IsNot.Ethernet != nil {
						state.NetworkInfo.Criteria.Network.IsNot.Ethernet = types.BoolValue(true)
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Ethernet = types.BoolPointerValue(nil)
					}
					//state.NetworkInfo.Criteria.Network.IsNot.Ethernet = types.BoolValue(ans.NetworkInfo.Criteria.Network.IsNot.Ethernet != nil)

					if ans.NetworkInfo.Criteria.Network.IsNot.Mobile == nil {
						state.NetworkInfo.Criteria.Network.IsNot.Mobile = nil
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Mobile = &hipObjectRsModel_suxdMuj_IsNotMobileObject{}

						state.NetworkInfo.Criteria.Network.IsNot.Mobile.Carrier = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.IsNot.Mobile.Carrier)
					}

					if ans.NetworkInfo.Criteria.Network.IsNot.Unknown != nil {
						state.NetworkInfo.Criteria.Network.IsNot.Unknown = types.BoolValue(true)
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Unknown = types.BoolPointerValue(nil)
					}
					//state.NetworkInfo.Criteria.Network.IsNot.Unknown = types.BoolValue(ans.NetworkInfo.Criteria.Network.IsNot.Unknown != nil)

					if ans.NetworkInfo.Criteria.Network.IsNot.Wifi == nil {
						state.NetworkInfo.Criteria.Network.IsNot.Wifi = nil
					} else {
						state.NetworkInfo.Criteria.Network.IsNot.Wifi = &hipObjectRsModel_suxdMuj_IsNotWifiObject{}

						state.NetworkInfo.Criteria.Network.IsNot.Wifi.Ssid = types.StringPointerValue(ans.NetworkInfo.Criteria.Network.IsNot.Wifi.Ssid)
					}
				}
			}
		}
	}

	if ans.PatchManagement == nil {
		state.PatchManagement = nil
	} else {
		state.PatchManagement = &hipObjectRsModel_suxdMuj_PatchManagementObject{}

		if ans.PatchManagement.Criteria == nil {
			state.PatchManagement.Criteria = nil
		} else {
			state.PatchManagement.Criteria = &hipObjectRsModel_suxdMuj_CriteriaObject{}

			state.PatchManagement.Criteria.IsEnabled = types.StringPointerValue(ans.PatchManagement.Criteria.IsEnabled)

			state.PatchManagement.Criteria.IsInstalled = types.BoolPointerValue(ans.PatchManagement.Criteria.IsInstalled)

			if ans.PatchManagement.Criteria.MissingPatches == nil {
				state.PatchManagement.Criteria.MissingPatches = nil
			} else {
				state.PatchManagement.Criteria.MissingPatches = &hipObjectRsModel_suxdMuj_MissingPatchesObject{}

				state.PatchManagement.Criteria.MissingPatches.Check = types.StringValue(ans.PatchManagement.Criteria.MissingPatches.Check)

				var75, var76 := types.ListValueFrom(ctx, types.StringType, ans.PatchManagement.Criteria.MissingPatches.Patches)
				state.PatchManagement.Criteria.MissingPatches.Patches = var75
				resp.Diagnostics.Append(var76.Errors()...)

				if ans.PatchManagement.Criteria.MissingPatches.Severity == nil {
					state.PatchManagement.Criteria.MissingPatches.Severity = nil
				} else {
					state.PatchManagement.Criteria.MissingPatches.Severity = &hipObjectRsModel_suxdMuj_SeverityObject{}

					state.PatchManagement.Criteria.MissingPatches.Severity.GreaterEqual = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.GreaterEqual)

					state.PatchManagement.Criteria.MissingPatches.Severity.GreaterThan = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.GreaterThan)

					state.PatchManagement.Criteria.MissingPatches.Severity.Is = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.Is)

					state.PatchManagement.Criteria.MissingPatches.Severity.IsNot = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.IsNot)

					state.PatchManagement.Criteria.MissingPatches.Severity.LessEqual = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.LessEqual)

					state.PatchManagement.Criteria.MissingPatches.Severity.LessThan = types.Int64PointerValue(ans.PatchManagement.Criteria.MissingPatches.Severity.LessThan)
				}
			}
		}

		state.PatchManagement.ExcludeVendor = types.BoolPointerValue(ans.PatchManagement.ExcludeVendor)

		if len(ans.PatchManagement.Vendors) == 0 {
			state.PatchManagement.Vendors = nil
		} else {
			state.PatchManagement.Vendors = make([]hipObjectRsModel_suxdMuj_PatchManagementVendorObject, 0, len(ans.PatchManagement.Vendors))
			for _, var77 := range ans.PatchManagement.Vendors {
				var78 := hipObjectRsModel_suxdMuj_PatchManagementVendorObject{}

				var78.Name = types.StringValue(var77.Name)

				var79, var80 := types.ListValueFrom(ctx, types.StringType, var77.Products)
				var78.Products = var79
				resp.Diagnostics.Append(var80.Errors()...)
				state.PatchManagement.Vendors = append(state.PatchManagement.Vendors, var78)
			}
		}
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Delete performs delete for the struct.
func (r *hipObjectResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var idType types.String
	resp.Diagnostics.Append(req.State.GetAttribute(ctx, path.Root("tfid"), &idType)...)
	if resp.Diagnostics.HasError() {
		return
	}
	tfid := idType.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 4 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 4 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"terraform_provider_function": "Delete",
		"resource_name":               "scm_hip_object",
		"locMap":                      map[string]int{"device": 2, "folder": 0, "id": 3, "snippet": 1},
		"tokens":                      tokens,
	})

	svc := sdhSKaQ.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := sdhSKaQ.DeleteInput{}

	input.Id = tokens[3]

	// Perform the operation.
	if _, err := svc.Delete(ctx, input); err != nil && !IsObjectNotFound(err) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}
}

func (r *hipObjectResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("tfid"), req, resp)
}
