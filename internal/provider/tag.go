package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"strconv"
	"strings"

	"github.com/paloaltonetworks/scm-go"
	qFWAgJG "github.com/paloaltonetworks/scm-go/netsec/schemas/tags"
	mIAatvm "github.com/paloaltonetworks/scm-go/netsec/services/tags"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Data source (listing).
var (
	_ datasource.DataSource              = &tagListDataSource{}
	_ datasource.DataSourceWithConfigure = &tagListDataSource{}
)

func NewTagListDataSource() datasource.DataSource {
	return &tagListDataSource{}
}

type tagListDataSource struct {
	client *scm.Client
}

// tagListDsModel is the model.
type tagListDsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	Device  types.String `tfsdk:"device"`
	Folder  types.String `tfsdk:"folder"`
	Limit   types.Int64  `tfsdk:"limit"`
	Name    types.String `tfsdk:"name"`
	Offset  types.Int64  `tfsdk:"offset"`
	Snippet types.String `tfsdk:"snippet"`

	// Output.
	Data []tagListDsModel_qFWAgJG_Config `tfsdk:"data"`
	// omit input: limit
	// omit input: offset
	Total types.Int64 `tfsdk:"total"`
}

type tagListDsModel_qFWAgJG_Config struct {
	Color    types.String `tfsdk:"color"`
	Comments types.String `tfsdk:"comments"`
	Id       types.String `tfsdk:"id"`
	Name     types.String `tfsdk:"name"`
}

// Metadata returns the data source type name.
func (d *tagListDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_tag_list"
}

// Schema defines the schema for this listing data source.
func (d *tagListDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = dsschema.Schema{
		Description: "Retrieves a listing of config items.",

		Attributes: map[string]dsschema.Attribute{
			// inputs:map[string]bool{"device":true, "folder":true, "limit":true, "name":true, "offset":true, "snippet":true} outputs:map[string]bool{"data":true, "limit":true, "offset":true, "tfid":true, "total":true} forceNew:map[string]bool{"device":true, "folder":true, "limit":true, "name":true, "offset":true, "snippet":true}
			"data": dsschema.ListNestedAttribute{
				Description: "The Data param.",
				Computed:    true,
				NestedObject: dsschema.NestedAttributeObject{
					Attributes: map[string]dsschema.Attribute{
						// inputs:map[string]bool{} outputs:map[string]bool{"color":true, "comments":true, "id":true, "name":true} forceNew:map[string]bool(nil)
						"color": dsschema.StringAttribute{
							Description: "The Color param. String must be one of these: `\"Red\"`, `\"Green\"`, `\"Blue\"`, `\"Yellow\"`, `\"Copper\"`, `\"Orange\"`, `\"Purple\"`, `\"Gray\"`, `\"Light Green\"`, `\"Cyan\"`, `\"Light Gray\"`, `\"Blue Gray\"`, `\"Lime\"`, `\"Black\"`, `\"Gold\"`, `\"Brown\"`, `\"Olive\"`, `\"Maroon\"`, `\"Red-Orange\"`, `\"Yellow-Orange\"`, `\"Forest Green\"`, `\"Turquoise Blue\"`, `\"Azure Blue\"`, `\"Cerulean Blue\"`, `\"Midnight Blue\"`, `\"Medium Blue\"`, `\"Cobalt Blue\"`, `\"Violet Blue\"`, `\"Blue Violet\"`, `\"Medium Violet\"`, `\"Medium Rose\"`, `\"Lavender\"`, `\"Orchid\"`, `\"Thistle\"`, `\"Peach\"`, `\"Salmon\"`, `\"Magenta\"`, `\"Red Violet\"`, `\"Mahogany\"`, `\"Burnt Sienna\"`, `\"Chestnut\"`.",
							Computed:    true,
						},
						"comments": dsschema.StringAttribute{
							Description: "The Comments param. String length must not exceed 1023 characters.",
							Computed:    true,
						},
						"id": dsschema.StringAttribute{
							Description: "UUID of the resource.",
							Computed:    true,
						},
						"name": dsschema.StringAttribute{
							Description: "The Name param. String length must not exceed 127 characters.",
							Computed:    true,
						},
					},
				},
			},
			"device": dsschema.StringAttribute{
				Description: "The Device param.",
				Optional:    true,
			},
			"folder": dsschema.StringAttribute{
				Description: "The Folder param.",
				Optional:    true,
			},
			"limit": dsschema.Int64Attribute{
				Description: "The Limit param. A limit of -1 will return all configured items. Default: `200`.",
				Optional:    true,
				Computed:    true,
			},
			"name": dsschema.StringAttribute{
				Description: "The Name param.",
				Optional:    true,
			},
			"offset": dsschema.Int64Attribute{
				Description: "The Offset param. Default: `0`.",
				Optional:    true,
				Computed:    true,
			},
			"snippet": dsschema.StringAttribute{
				Description: "The Snippet param.",
				Optional:    true,
			},
			"tfid": dsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
			},
			"total": dsschema.Int64Attribute{
				Description: "The Total param.",
				Computed:    true,
			},
		},
	}
}

// Configure prepares the struct.
func (d *tagListDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*scm.Client)
}

// Read performs Read for the struct.
func (d *tagListDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state tagListDsModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing data source listing", map[string]any{
		"data_source_name":            "scm_tag_list",
		"terraform_provider_function": "Read",
		"name":                        state.Name.ValueString(),
		"folder":                      state.Folder.ValueString(),
		"snippet":                     state.Snippet.ValueString(),
		"device":                      state.Device.ValueString(),
		"offset":                      state.Offset.ValueInt64(),
		"limit":                       state.Limit.ValueInt64(),
	})

	// Prepare to run the command.
	svc := mIAatvm.NewClient(d.client)

	// Prepare input for the API endpoint.
	input := mIAatvm.ListInput{}

	input.Name = state.Name.ValueStringPointer()

	input.Folder = state.Folder.ValueStringPointer()

	input.Snippet = state.Snippet.ValueStringPointer()

	input.Device = state.Device.ValueStringPointer()

	input.Offset = state.Offset.ValueInt64Pointer()

	input.Limit = state.Limit.ValueInt64Pointer()

	// Perform the operation.
	ans, err := svc.List(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error getting listing", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	if input.Name != nil {
		idBuilder.WriteString(*input.Name)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Folder != nil {
		idBuilder.WriteString(*input.Folder)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Snippet != nil {
		idBuilder.WriteString(*input.Snippet)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Device != nil {
		idBuilder.WriteString(*input.Device)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Offset != nil {
		idBuilder.WriteString(strconv.FormatInt(*input.Offset, 10))
	}

	idBuilder.WriteString(IdSeparator)
	if input.Limit != nil {
		idBuilder.WriteString(strconv.FormatInt(*input.Limit, 10))
	}

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	if len(ans.Data) == 0 {
		state.Data = nil
	} else {
		state.Data = make([]tagListDsModel_qFWAgJG_Config, 0, len(ans.Data))
		for _, var0 := range ans.Data {
			var1 := tagListDsModel_qFWAgJG_Config{}

			var1.Color = types.StringPointerValue(var0.Color)

			var1.Comments = types.StringPointerValue(var0.Comments)

			var1.Id = types.StringPointerValue(var0.Id)

			var1.Name = types.StringValue(var0.Name)
			state.Data = append(state.Data, var1)
		}
	}

	state.Limit = types.Int64PointerValue(ans.Limit)

	state.Offset = types.Int64PointerValue(ans.Offset)

	state.Total = types.Int64PointerValue(ans.Total)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Data source.
var (
	_ datasource.DataSource              = &tagDataSource{}
	_ datasource.DataSourceWithConfigure = &tagDataSource{}
)

func NewTagDataSource() datasource.DataSource {
	return &tagDataSource{}
}

type tagDataSource struct {
	client *scm.Client
}

// tagDsModel is the model.
type tagDsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	Id types.String `tfsdk:"id"`

	// Output.
	Color    types.String `tfsdk:"color"`
	Comments types.String `tfsdk:"comments"`
	// omit input: id
	Name types.String `tfsdk:"name"`
}

// Metadata returns the data source type name.
func (d *tagDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_tag"
}

// Schema defines the schema for this data source.
func (d *tagDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = dsschema.Schema{
		Description: "Retrieves a config item.",

		Attributes: map[string]dsschema.Attribute{
			// inputs:map[string]bool{"id":true} outputs:map[string]bool{"color":true, "comments":true, "id":true, "name":true, "tfid":true} forceNew:map[string]bool{"id":true}
			"color": dsschema.StringAttribute{
				Description: "The Color param. String must be one of these: `\"Red\"`, `\"Green\"`, `\"Blue\"`, `\"Yellow\"`, `\"Copper\"`, `\"Orange\"`, `\"Purple\"`, `\"Gray\"`, `\"Light Green\"`, `\"Cyan\"`, `\"Light Gray\"`, `\"Blue Gray\"`, `\"Lime\"`, `\"Black\"`, `\"Gold\"`, `\"Brown\"`, `\"Olive\"`, `\"Maroon\"`, `\"Red-Orange\"`, `\"Yellow-Orange\"`, `\"Forest Green\"`, `\"Turquoise Blue\"`, `\"Azure Blue\"`, `\"Cerulean Blue\"`, `\"Midnight Blue\"`, `\"Medium Blue\"`, `\"Cobalt Blue\"`, `\"Violet Blue\"`, `\"Blue Violet\"`, `\"Medium Violet\"`, `\"Medium Rose\"`, `\"Lavender\"`, `\"Orchid\"`, `\"Thistle\"`, `\"Peach\"`, `\"Salmon\"`, `\"Magenta\"`, `\"Red Violet\"`, `\"Mahogany\"`, `\"Burnt Sienna\"`, `\"Chestnut\"`.",
				Computed:    true,
			},
			"comments": dsschema.StringAttribute{
				Description: "The Comments param. String length must not exceed 1023 characters.",
				Computed:    true,
			},
			"id": dsschema.StringAttribute{
				Description: "The Id param.",
				Required:    true,
			},
			"name": dsschema.StringAttribute{
				Description: "The Name param. String length must not exceed 127 characters.",
				Computed:    true,
			},
			"tfid": dsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
			},
		},
	}
}

// Configure prepares the struct.
func (d *tagDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*scm.Client)
}

// Read performs Read for the struct.
func (d *tagDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state tagDsModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing data source read", map[string]any{
		"data_source_name":            "scm_tag",
		"terraform_provider_function": "Read",
		"id":                          state.Id.ValueString(),
	})

	// Prepare to run the command.
	svc := mIAatvm.NewClient(d.client)

	// Prepare input for the API endpoint.
	input := mIAatvm.ReadInput{}

	input.Id = state.Id.ValueString()

	// Perform the operation.
	ans, err := svc.Read(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error reading config", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	idBuilder.WriteString(input.Id)

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	state.Color = types.StringPointerValue(ans.Color)

	state.Comments = types.StringPointerValue(ans.Comments)

	state.Id = types.StringPointerValue(ans.Id)

	state.Name = types.StringValue(ans.Name)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Resource.
var (
	_ resource.Resource                = &tagResource{}
	_ resource.ResourceWithConfigure   = &tagResource{}
	_ resource.ResourceWithImportState = &tagResource{}
)

func NewTagResource() resource.Resource {
	return &tagResource{}
}

type tagResource struct {
	client *scm.Client
}

// tagRsModel is the model.
type tagRsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	Color    types.String `tfsdk:"color"`
	Comments types.String `tfsdk:"comments"`
	Device   types.String `tfsdk:"device"`
	Folder   types.String `tfsdk:"folder"`
	Id       types.String `tfsdk:"id"`
	Name     types.String `tfsdk:"name"`
	Snippet  types.String `tfsdk:"snippet"`

	// Output.
	// omit input: color
	// omit input: comments
	// omit input: id
	// omit input: name
}

// Metadata returns the data source type name.
func (r *tagResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_tag"
}

// Schema defines the schema for this data source.
func (r *tagResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = rsschema.Schema{
		Description: "Retrieves a config item.",

		Attributes: map[string]rsschema.Attribute{
			// inputs:map[string]bool{"color":true, "comments":true, "device":true, "folder":true, "id":true, "name":true, "snippet":true} outputs:map[string]bool{"color":true, "comments":true, "id":true, "name":true, "tfid":true} forceNew:map[string]bool{"device":true, "folder":true, "snippet":true}
			"color": rsschema.StringAttribute{
				Description: "The Color param. String must be one of these: `\"Red\"`, `\"Green\"`, `\"Blue\"`, `\"Yellow\"`, `\"Copper\"`, `\"Orange\"`, `\"Purple\"`, `\"Gray\"`, `\"Light Green\"`, `\"Cyan\"`, `\"Light Gray\"`, `\"Blue Gray\"`, `\"Lime\"`, `\"Black\"`, `\"Gold\"`, `\"Brown\"`, `\"Olive\"`, `\"Maroon\"`, `\"Red-Orange\"`, `\"Yellow-Orange\"`, `\"Forest Green\"`, `\"Turquoise Blue\"`, `\"Azure Blue\"`, `\"Cerulean Blue\"`, `\"Midnight Blue\"`, `\"Medium Blue\"`, `\"Cobalt Blue\"`, `\"Violet Blue\"`, `\"Blue Violet\"`, `\"Medium Violet\"`, `\"Medium Rose\"`, `\"Lavender\"`, `\"Orchid\"`, `\"Thistle\"`, `\"Peach\"`, `\"Salmon\"`, `\"Magenta\"`, `\"Red Violet\"`, `\"Mahogany\"`, `\"Burnt Sienna\"`, `\"Chestnut\"`.",
				Optional:    true,
				Validators: []validator.String{
					stringvalidator.OneOf("Red", "Green", "Blue", "Yellow", "Copper", "Orange", "Purple", "Gray", "Light Green", "Cyan", "Light Gray", "Blue Gray", "Lime", "Black", "Gold", "Brown", "Olive", "Maroon", "Red-Orange", "Yellow-Orange", "Forest Green", "Turquoise Blue", "Azure Blue", "Cerulean Blue", "Midnight Blue", "Medium Blue", "Cobalt Blue", "Violet Blue", "Blue Violet", "Medium Violet", "Medium Rose", "Lavender", "Orchid", "Thistle", "Peach", "Salmon", "Magenta", "Red Violet", "Mahogany", "Burnt Sienna", "Chestnut"),
				},
			},
			"comments": rsschema.StringAttribute{
				Description: "The Comments param. String length must not exceed 1023 characters.",
				Optional:    true,
				Validators: []validator.String{
					stringvalidator.LengthAtMost(1023),
				},
			},
			"device": rsschema.StringAttribute{
				Description: "The Device param.",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"folder": rsschema.StringAttribute{
				Description: "The Folder param.",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"id": rsschema.StringAttribute{
				Description: "UUID of the resource.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"name": rsschema.StringAttribute{
				Description: "The Name param. String length must not exceed 127 characters.",
				Required:    true,
				Validators: []validator.String{
					stringvalidator.LengthAtMost(127),
				},
			},
			"snippet": rsschema.StringAttribute{
				Description: "The Snippet param.",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"tfid": rsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
	}
}

// Configure prepares the struct.
func (r *tagResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*scm.Client)
}

// Create resource.
func (r *tagResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state tagRsModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name":               "scm_tag",
		"terraform_provider_function": "Create",
		"folder":                      state.Folder.ValueString(),
		"snippet":                     state.Snippet.ValueString(),
		"device":                      state.Device.ValueString(),
	})

	// Prepare to create the config.
	svc := mIAatvm.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := mIAatvm.CreateInput{}

	input.Folder = state.Folder.ValueStringPointer()

	input.Snippet = state.Snippet.ValueStringPointer()

	input.Device = state.Device.ValueStringPointer()
	input.Request = &qFWAgJG.Config{}

	input.Request.Color = state.Color.ValueStringPointer()

	input.Request.Comments = state.Comments.ValueStringPointer()

	input.Request.Name = state.Name.ValueString()

	// Perform the operation.
	ans, err := svc.Create(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error creating config", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	if input.Folder != nil {
		idBuilder.WriteString(*input.Folder)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Snippet != nil {
		idBuilder.WriteString(*input.Snippet)
	}

	idBuilder.WriteString(IdSeparator)
	if input.Device != nil {
		idBuilder.WriteString(*input.Device)
	}

	idBuilder.WriteString(IdSeparator)
	if ans.Id == nil {
		resp.Diagnostics.AddError("Undefined param required for ID", "Id")
		return
	}
	if ans.Id != nil {
		idBuilder.WriteString(*ans.Id)
	}

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	state.Color = types.StringPointerValue(ans.Color)

	state.Comments = types.StringPointerValue(ans.Comments)

	state.Id = types.StringPointerValue(ans.Id)

	state.Name = types.StringValue(ans.Name)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Read performs Read for the struct.
func (r *tagResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var savestate, state tagRsModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	tfid := savestate.Tfid.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 4 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 4 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"terraform_provider_function": "Read",
		"resource_name":               "scm_tag",
		"locMap":                      map[string]int{"device": 2, "folder": 0, "id": 3, "snippet": 1},
		"tokens":                      tokens,
	})

	// Prepare to read the config.
	svc := mIAatvm.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := mIAatvm.ReadInput{}

	input.Id = tokens[3]

	// Perform the operation.
	ans, err := svc.Read(ctx, input)
	if err != nil {
		if IsObjectNotFound(err) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading config", err.Error())
		}
		return
	}

	// Store the answer to state.

	if tokens[0] == "" {
		state.Folder = types.StringNull()
	} else {
		state.Folder = types.StringValue(tokens[0])
	}

	if tokens[1] == "" {
		state.Snippet = types.StringNull()
	} else {
		state.Snippet = types.StringValue(tokens[1])
	}

	if tokens[2] == "" {
		state.Device = types.StringNull()
	} else {
		state.Device = types.StringValue(tokens[2])
	}
	state.Tfid = savestate.Tfid

	state.Color = types.StringPointerValue(ans.Color)

	state.Comments = types.StringPointerValue(ans.Comments)

	state.Id = types.StringPointerValue(ans.Id)

	state.Name = types.StringValue(ans.Name)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Update performs the Update for the struct.
func (r *tagResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, state tagRsModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	tfid := state.Tfid.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 4 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 4 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"terraform_provider_function": "Update",
		"resource_name":               "scm_tag",
		"tfid":                        state.Tfid.ValueString(),
	})

	// Prepare to update the config.
	svc := mIAatvm.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := mIAatvm.UpdateInput{}

	if tokens[3] != "" {
		input.Id = tokens[3]
	}
	input.Request = &qFWAgJG.Config{}

	input.Request.Color = plan.Color.ValueStringPointer()

	input.Request.Comments = plan.Comments.ValueStringPointer()

	input.Request.Name = plan.Name.ValueString()

	// Perform the operation.
	ans, err := svc.Update(ctx, input)
	if err != nil {
		if IsObjectNotFound(err) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error updating resource", err.Error())
		}
		return
	}

	// Store the answer to state.
	// Note: when supporting importing a resource, this will need to change to taking
	// values from the savestate.Tfid param and locMap.

	state.Color = types.StringPointerValue(ans.Color)

	state.Comments = types.StringPointerValue(ans.Comments)

	state.Id = types.StringPointerValue(ans.Id)

	state.Name = types.StringValue(ans.Name)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Delete performs delete for the struct.
func (r *tagResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var idType types.String
	resp.Diagnostics.Append(req.State.GetAttribute(ctx, path.Root("tfid"), &idType)...)
	if resp.Diagnostics.HasError() {
		return
	}
	tfid := idType.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 4 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 4 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"terraform_provider_function": "Delete",
		"resource_name":               "scm_tag",
		"locMap":                      map[string]int{"device": 2, "folder": 0, "id": 3, "snippet": 1},
		"tokens":                      tokens,
	})

	svc := mIAatvm.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := mIAatvm.DeleteInput{}

	input.Id = tokens[3]

	// Perform the operation.
	if _, err := svc.Delete(ctx, input); err != nil && !IsObjectNotFound(err) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}
}

func (r *tagResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("tfid"), req, resp)
}
